DocuChain - Complete Product Requirements Document (PRD) 

Document Control 

Version Date Author Status 

1.0 2024 Product Team Draft 

 
Table of Contents 

1. Executive Summary 

2. Product Vision & Objectives 

3. Target Users & Personas 

4. System Architecture 

5. Technical Stack 

6. Feature Specifications 

7. User Interface Design 

8. Database Schema 

9. API Specifications 

10. Smart Contract Specifications 

11. Security & Compliance 

12. Performance Requirements 

13. Testing Strategy 

14. Deployment Architecture 

15. Future Roadmap 

 
1. Executive Summary 

1.1 Product Overview 

DocuChain is a blockchain-based document management system designed for educational 
institutions (schools, colleges, universities, coaching centers) that provides: 

• Decentralized Storage: Documents stored on IPFS with blockchain verification 

• Role-Based Access: Three-tier system (Admin, Faculty/Staff, Students) 

• Digital Signatures: Blockchain-verified document approval workflows 

• Institutional Management: Department/section organization with automated group creation 

• Circular Management: Institution-wide announcement system 



• Document Verification: QR-code based authenticity checking 

1.2 Business Objectives 

Objective Success Metric Timeline 

Launch MVP 100 institutions onboarded Q2 2024 

User Adoption 10,000 active users Q3 2024 

Document Processing 50,000 documents uploaded Q4 2024 

Verification Rate 95% document authenticity verified Q1 2025 

1.3 Key Differentiators 

1.   Blockchain Immutability: Tamper-proof document records 

2.   Multi-Signature Workflows: Sequential/parallel approval processes 

3.   Institutional Hierarchy: Automated department/section management 

4.   Universal Search: Cross-role document discovery 

5.   Offline Verification: QR-code based validation without login 

 
2. Product Vision & Objectives 

2.1 Vision Statement 

"To become the de facto standard for educational document management by providing transparent, 
secure, and blockchain-verified workflows that eliminate document fraud and streamline institutional 
processes." 

2.2 Problem Statement 

Current Challenges: 

1.   Document forgery in certificates/transcripts 

2.   Manual approval processes causing delays 

3.   Lost/misplaced physical documents 

4.   Difficulty verifying document authenticity 

5.   No audit trail for document changes 

6.   Inefficient inter-departmental communication 

Our Solution: 

• Blockchain-verified document ownership 

• Smart contract-based approval automation 



• IPFS decentralized storage 

• QR-code instant verification 

• Complete activity logging 

• Integrated chat & circular system 

2.3 Success Criteria 

Category Metric Target 

User Satisfaction NPS Score > 50 

Performance Document upload time < 30 seconds 

Reliability System uptime 99.9% 

Security Document tampering incidents 0 

Adoption Daily active users 70% of registered 

 
3. Target Users & Personas 

3.1 Primary User Roles 

Role 1: Institution Administrator 

Profile: 

• Name: Dr. Rajesh Kumar 

• Age: 45 

• Position: Principal/Dean 

• Tech Proficiency: Medium 

Goals: 

• Manage institutional hierarchy (departments/sections) 

• Approve/reject user registration requests 

• Monitor document workflows 

• Publish circulars to entire institution 

Pain Points: 

• Overwhelmed by manual approval processes 

• Difficulty tracking document status 

• No centralized communication system 

Use Cases: 



1. Create institution profile with unique ID 

2. Approve faculty/student registration requests 

3. Create departments and assign HODs 

4. Publish emergency circulars 

5. View institution-wide analytics 

 
Role 2: Faculty/Staff 

Profile: 

• Name: Prof. Priya Sharma 

• Age: 35 

• Position: HOD Computer Science 

• Tech Proficiency: High 

Goals: 

• Generate student certificates/documents 

• Approve document requests with digital signatures 

• Manage class sections 

• Communicate with students 

Pain Points: 

• Time-consuming manual certificate generation 

• Tracking multiple approval requests 

• Lost document versions 

Use Cases: 

1. Generate bonafide certificate from template 

2. Request digital signatures from Principal 

3. Approve student leave applications 

4. Create departmental circulars 

5. Share documents with students 

 
Role 3: Student 

Profile: 

• Name: Arjun Patel 



• Age: 20 

• Position: 3rd Year B.Tech Student 

• Tech Proficiency: High 

Goals: 

• Request official documents (certificates, transcripts) 

• Verify received documents 

• Download approved documents 

• Communicate with faculty 

Pain Points: 

• Long wait times for document approvals 

• Uncertainty about document authenticity 

• Difficulty tracking request status 

Use Cases: 

1. Request bonafide certificate 

2. Track approval workflow status 

3. Download approved certificate 

4. Verify certificate authenticity via QR 

5. Share documents with external parties 

 
3.2 Secondary User Roles 

Role 4: External Verifier 

Profile: 

• Name: HR Manager at Company 

• Age: 40 

• Position: Recruiter 

• Tech Proficiency: Medium 

Goals: 

• Verify candidate document authenticity 

• Quick validation without login 

Use Cases: 

1. Scan QR code on certificate 



2. View blockchain verification status 

3. Download verification report 

 
4. System Architecture 

4.1 High-Level Architecture 

text 

┌────────────────────────────────────────────────────────────┐ 

│                    CLIENT LAYER                            │ 

│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐       │ 

│  │   Browser   │  │   Mobile    │  │   Tablet    │       │ 

│  │  (Desktop)  │  │   (PWA)     │  │   (PWA)     │       │ 

│  └──────┬──────┘  └──────┬──────┘  └──────┬──────┘       │ 

└─────────┼─────────────────┼─────────────────┼─────────────┘ 

          │                 │                 │ 

          └─────────────────┴─────────────────┘ 

                            │ 

                    ┌───────▼───────┐ 

                    │   REACT APP   │ 

                    │  (Frontend)   │ 

                    └───────┬───────┘ 

                            │ 

          ┌─────────────────┼─────────────────┐ 

          │                 │                 │ 

    ┌─────▼─────┐     ┌─────▼─────┐     ┌────▼────┐ 

    │  REST API │     │  WebSocket│     │  Web3   │ 

    │  (Flask)  │     │ Socket.IO │     │Provider │ 

    └─────┬─────┘     └─────┬─────┘     └────┬────┘ 

          │                 │                 │ 

┌─────────┼─────────────────┼─────────────────┼─────────────┐ 

│         │    BACKEND LAYER│                 │             │ 



│  ┌──────▼──────┐   ┌──────▼──────┐   ┌──────▼──────┐    │ 

│  │  Flask API  │   │  Socket.IO  │   │   Web3.py   │    │ 

│  │   Server    │   │   Server    │   │  Ethereum   │    │ 

│  └──────┬──────┘   └──────┬──────┘   └──────┬──────┘    │ 

│         │                 │                 │             │ 

│  ┌──────▼──────────────────▼─────────┐      │             │ 

│  │     PostgreSQL Database           │      │             │ 

│  │  ┌─────────┐  ┌─────────────┐    │      │             │ 

│  │  │  Users  │  │  Documents  │    │      │             │ 

│  │  └─────────┘  └─────────────┘    │      │             │ 

│  │  ┌─────────┐  ┌─────────────┐    │      │             │ 

│  │  │  Chats  │  │  Circulars  │    │      │             │ 

│  │  └─────────┘  └─────────────┘    │      │             │ 

│  └────────────────────────────────────┘      │             │ 

│                                              │             │ 

└──────────────────────────────────────────────┼─────────────┘ 

                                              │ 

          ┌───────────────────────────────────┼───────┐ 

          │         BLOCKCHAIN LAYER          │       │ 

          │  ┌────────────────────────────────▼────┐  │ 

          │  │    Ethereum Sepolia Testnet        │  │ 

          │  │  ┌──────────────────────────────┐  │  │ 

          │  │  │   DocumentManager.sol        │  │  │ 

          │  │  │   - uploadDocument()         │  │  │ 

          │  │  │   - shareDocument()          │  │  │ 

          │  │  │   - approveDocument()        │  │  │ 

          │  │  └──────────────────────────────┘  │  │ 

          │  └────────────────────────────────────┘  │ 

          └──────────────────────────────────────────┘ 

                            │ 

          ┌─────────────────┴─────────────────┐ 



          │      STORAGE LAYER                │ 

          │  ┌──────────────┐  ┌────────────┐ │ 

          │  │  IPFS/Pinata │  │   Redis    │ │ 

          │  │  (Documents) │  │  (Cache)   │ │ 

          │  └──────────────┘  └────────────┘ │ 

          └────────────────────────────────────┘ 

4.2 Component Architecture 

Frontend Architecture (React) 

text 

frontend/ 

├── public/ 

│   ├── index.html 

│   └── favicon.ico 

│ 

├── src/ 

│   ├── assets/              # Images, fonts, icons 

│   │   ├── images/ 

│   │   ├── icons/ 

│   │   └── themes/ 

│   │ 

│   ├── components/          # Reusable UI components 

│   │   ├── common/ 

│   │   │   ├── Button.jsx 

│   │   │   ├── Modal.jsx 

│   │   │   ├── SearchBar.jsx 

│   │   │   ├── Notification.jsx 

│   │   │   └── Loader.jsx 

│   │   │ 

│   │   ├── layout/ 

│   │   │   ├── Header.jsx 



│   │   │   ├── Sidebar.jsx 

│   │   │   ├── Footer.jsx 

│   │   │   └── Dashboard.jsx 

│   │   │ 

│   │   ├── auth/ 

│   │   │   ├── LoginForm.jsx 

│   │   │   ├── RegisterForm.jsx 

│   │   │   ├── OTPVerification.jsx 

│   │   │   └── WalletConnect.jsx 

│   │   │ 

│   │   ├── file-manager/ 

│   │   │   ├── FileList.jsx 

│   │   │   ├── FileCard.jsx 

│   │   │   ├── FolderTree.jsx 

│   │   │   ├── UploadModal.jsx 

│   │   │   ├── ShareModal.jsx 

│   │   │   └── VersionHistory.jsx 

│   │   │ 

│   │   ├── chat/ 

│   │   │   ├── ChatList.jsx 

│   │   │   ├── ChatWindow.jsx 

│   │   │   ├── MessageInput.jsx 

│   │   │   ├── GroupManager.jsx 

│   │   │   └── FileShareWidget.jsx 

│   │   │ 

│   │   ├── document-generation/ 

│   │   │   ├── TemplateSelector.jsx 

│   │   │   ├── DocumentEditor.jsx 

│   │   │   ├── DraftManager.jsx 

│   │   │   └── ApprovalWorkflow.jsx 



│   │   │ 

│   │   ├── approval/ 

│   │   │   ├── ApprovalRequest.jsx 

│   │   │   ├── RequestList.jsx 

│   │   │   ├── ApproverView.jsx 

│   │   │   ├── SignaturePad.jsx 

│   │   │   └── WorkflowStatus.jsx 

│   │   │ 

│   │   ├── admin/ 

│   │   │   ├── UserManagement.jsx 

│   │   │   ├── AccountRequests.jsx 

│   │   │   ├── AddUser.jsx 

│   │   │   ├── InstitutionSettings.jsx 

│   │   │   ├── DepartmentManager.jsx 

│   │   │   └── Analytics.jsx 

│   │   │ 

│   │   ├── circular/ 

│   │   │   ├── CircularCreator.jsx 

│   │   │   ├── CircularList.jsx 

│   │   │   ├── CircularFeed.jsx 

│   │   │   └── CircularTemplates.jsx 

│   │   │ 

│   │   └── verification/ 

│   │       ├── DocumentVerifier.jsx 

│   │       ├── QRScanner.jsx 

│   │       ├── VerificationReport.jsx 

│   │       └── BlockchainViewer.jsx 

│   │ 

│   ├── pages/               # Page-level components 

│   │   ├── auth/ 



│   │   │   ├── Login.jsx 

│   │   │   ├── Register.jsx 

│   │   │   └── CreateInstitution.jsx 

│   │   │ 

│   │   ├── dashboard/ 

│   │   │   ├── AdminDashboard.jsx 

│   │   │   ├── FacultyDashboard.jsx 

│   │   │   └── StudentDashboard.jsx 

│   │   │ 

│   │   ├── file-manager/ 

│   │   │   └── FileManager.jsx 

│   │   │ 

│   │   ├── chat/ 

│   │   │   └── Chat.jsx 

│   │   │ 

│   │   ├── document-generation/ 

│   │   │   └── DocumentGenerator.jsx 

│   │   │ 

│   │   ├── approval/ 

│   │   │   ├── DocumentApproval.jsx 

│   │   │   └── MyRequests.jsx 

│   │   │ 

│   │   ├── admin/ 

│   │   │   ├── UserManagement.jsx 

│   │   │   ├── AccountRequests.jsx 

│   │   │   ├── AddUser.jsx 

│ │ │ ├── InstitutionManagement.jsx 
│ │ │ └── CircularManagement.jsx 
│ │ │ 
│ │ ├── verification/ 
│ │ │ └── Verification.jsx 
│ │ │ 



│ │ └── settings/ 
│ │ ├── Settings.jsx 
│ │ ├── Profile.jsx 
│ │ ├── ActivityLog.jsx 
│ │ ├── BlockchainMonitor.jsx 
│ │ └── HelpSupport.jsx 
│ │ 
│ ├── hooks/ # Custom React hooks 
│ │ ├── useAuth.js 
│ │ ├── useWallet.js 
│ │ ├── useFileManager.js 
│ │ ├── useChat.js 
│ │ ├── useNotification.js 
│ │ ├── useBlockchain.js 
│ │ ├── useWebSocket.js 
│ │ └── useTheme.js 
│ │ 
│ ├── context/ # React Context providers 
│ │ ├── AuthContext.jsx 
│ │ ├── WalletContext.jsx 
│ │ ├── ThemeContext.jsx 
│ │ ├── NotificationContext.jsx 
│ │ └── SocketContext.jsx 
│ │ 
│ ├── services/ # API and service layers 
│ │ ├── api/ 
│ │ │ ├── authService.js 
│ │ │ ├── userService.js 
│ │ │ ├── fileService.js 
│ │ │ ├── chatService.js 
│ │ │ ├── documentService.js 
│ │ │ ├── approvalService.js 
│ │ │ ├── circularService.js 
│ │ │ ├── verificationService.js 
│ │ │ └── adminService.js 
│ │ │ 
│ │ ├── blockchain/ 
│ │ │ ├── web3Provider.js 
│ │ │ ├── contractService.js 
│ │ │ ├── ipfsService.js 
│ │ │ └── walletService.js 
│ │ │ 
│ │ ├── socket/ 



│ │ │ └── socketService.js 
│ │ │ 
│ │ └── storage/ 
│ │ └── localStorageService.js 
│ │ 
│ ├── utils/ # Utility functions 
│ │ ├── validators.js 
│ │ ├── formatters.js 
│ │ ├── constants.js 
│ │ ├── helpers.js 
│ │ ├── dateUtils.js 
│ │ ├── fileUtils.js 
│ │ └── cryptoUtils.js 
│ │ 
│ ├── styles/ # Global styles 
│ │ ├── globals.css 
│ │ ├── themes/ 
│ │ │ ├── default.css 
│ │ │ ├── dark.css 
│ │ │ ├── blue.css 
│ │ │ └── purple.css 
│ │ └── animations.css 
│ │ 
│ ├── routes/ # Route configurations 
│ │ ├── AppRoutes.jsx 
│ │ ├── PrivateRoute.jsx 
│ │ ├── AdminRoute.jsx 
│ │ └── PublicRoute.jsx 
│ │ 
│ ├── config/ # Configuration files 
│ │ ├── config.js 
│ │ ├── blockchain.config.js 
│ │ ├── api.config.js 
│ │ └── socket.config.js 
│ │ 
│ ├── App.jsx # Main App component 
│ ├── index.js # Entry point 
│ └── setupTests.js # Test configuration 
│ 
├── .env.development # Development environment variables 
├── .env.production # Production environment variables 
├── package.json 



├── tailwind.config.js 
└── vite.config.js / webpack.config.js 

text 

 

### **Backend Architecture (Flask + Python)** 

backend/ 
├── app/ 
│ ├── init.py # Flask app initialization 
│ │ 
│ ├── config/ # Configuration management 
│ │ ├── init.py 
│ │ ├── base.py 
│ │ ├── development.py 
│ │ ├── production.py 
│ │ └── testing.py 
│ │ 
│ ├── models/ # Database models (SQLAlchemy) 
│ │ ├── init.py 
│ │ ├── user.py 
│ │ ├── institution.py 
│ │ ├── department.py 
│ │ ├── section.py 
│ │ ├── document.py 
│ │ ├── document_share.py 
│ │ ├── document_approval.py 
│ │ ├── chat_message.py 
│ │ ├── chat_group.py 
│ │ ├── circular.py 
│ │ ├── notification.py 
│ │ ├── activity_log.py 
│ │ └── wallet.py 
│ │ 
│ ├── schemas/ # Pydantic/Marshmallow schemas 
│ │ ├── init.py 
│ │ ├── user_schema.py 
│ │ ├── document_schema.py 
│ │ ├── approval_schema.py 
│ │ ├── chat_schema.py 
│ │ └── circular_schema.py 
│ │ 
│ ├── api/ # API routes 



│ │ ├── init.py 
│ │ │ 
│ │ ├── auth/ 
│ │ │ ├── init.py 
│ │ │ ├── routes.py 
│ │ │ └── utils.py 
│ │ │ 
│ │ ├── users/ 
│ │ │ ├── init.py 
│ │ │ ├── routes.py 
│ │ │ └── utils.py 
│ │ │ 
│ │ ├── files/ 
│ │ │ ├── init.py 
│ │ │ ├── routes.py 
│ │ │ └── utils.py 
│ │ │ 
│ │ ├── chat/ 
│ │ │ ├── init.py 
│ │ │ ├── routes.py 
│ │ │ ├── socket_handlers.py 
│ │ │ └── utils.py 
│ │ │ 
│ │ ├── documents/ 
│ │ │ ├── init.py 
│ │ │ ├── routes.py 
│ │ │ ├── generation.py 
│ │ │ └── utils.py 
│ │ │ 
│ │ ├── approvals/ 
│ │ │ ├── init.py 
│ │ │ ├── routes.py 
│ │ │ ├── workflow.py 
│ │ │ └── utils.py 
│ │ │ 
│ │ ├── circulars/ 
│ │ │ ├── init.py 
│ │ │ ├── routes.py 
│ │ │ └── utils.py 
│ │ │ 
│ │ ├── admin/ 
│ │ │ ├── init.py 
│ │ │ ├── routes.py 



│ │ │ ├── user_management.py 
│ │ │ ├── institution_management.py 
│ │ │ └── utils.py 
│ │ │ 
│ │ └── verification/ 
│ │ ├── init.py 
│ │ ├── routes.py 
│ │ └── utils.py 
│ │ 
│ ├── services/ # Business logic layer 
│ │ ├── init.py 
│ │ ├── auth_service.py 
│ │ ├── user_service.py 
│ │ ├── file_service.py 
│ │ ├── ipfs_service.py 
│ │ ├── blockchain_service.py 
│ │ ├── chat_service.py 
│ │ ├── document_service.py 
│ │ ├── approval_service.py 
│ │ ├── circular_service.py 
│ │ ├── notification_service.py 
│ │ ├── email_service.py 
│ │ └── verification_service.py 
│ │ 
│ ├── blockchain/ # Blockchain interaction layer 
│ │ ├── init.py 
│ │ ├── web3_client.py 
│ │ ├── contract_manager.py 
│ │ ├── transaction_handler.py 
│ │ └── event_listener.py 
│ │ 
│ ├── utils/ # Utility functions 
│ │ ├── init.py 
│ │ ├── validators.py 
│ │ ├── helpers.py 
│ │ ├── security.py 
│ │ ├── file_utils.py 
│ │ ├── crypto_utils.py 
│ │ ├── qr_generator.py 
│ │ └── pdf_generator.py 
│ │ 
│ ├── middleware/ # Custom middleware 
│ │ ├── init.py 



│ │ ├── auth_middleware.py 
│ │ ├── role_middleware.py 
│ │ ├── logging_middleware.py 
│ │ └── error_handler.py 
│ │ 
│ ├── extensions.py # Flask extensions (SQLAlchemy, etc.) 
│ └── celery_worker.py # Background tasks (Celery) 
│ 
├── migrations/ # Database migrations (Alembic) 
│ ├── versions/ 
│ └── env.py 
│ 
├── tests/ # Test suite 
│ ├── init.py 
│ ├── conftest.py 
│ ├── unit/ 
│ │ ├── test_models.py 
│ │ ├── test_services.py 
│ │ └── test_utils.py 
│ ├── integration/ 
│ │ ├── test_auth_api.py 
│ │ ├── test_file_api.py 
│ │ └── test_approval_api.py 
│ └── e2e/ 
│ └── test_workflows.py 
│ 
├── scripts/ # Utility scripts 
│ ├── init_db.py 
│ ├── seed_data.py 
│ └── deploy.py 
│ 
├── logs/ # Application logs 
│ ├── app.log 
│ └── error.log 
│ 
├── .env.development 
├── .env.production 
├── requirements.txt 
├── requirements-dev.txt 
├── wsgi.py # WSGI entry point 
├── Dockerfile 
└── docker-compose.yml 

text 



 

### **Blockchain/Smart Contracts Architecture** 

blockchain/ 
├── contracts/ # Solidity smart contracts 
│ ├── DocumentManager.sol 
│ ├── AccessControl.sol 
│ ├── ApprovalWorkflow.sol 
│ └── CircularManager.sol 
│ 
├── scripts/ # Deployment scripts 
│ ├── deploy.js 
│ ├── verify.js 
│ └── upgrade.js 
│ 
├── test/ # Smart contract tests 
│ ├── DocumentManager.test.js 
│ ├── AccessControl.test.js 
│ └── ApprovalWorkflow.test.js 
│ 
├── deployments/ # Deployment addresses 
│ ├── sepolia.json 
│ └── mainnet.json 
│ 
├── abi/ # Contract ABIs (auto-generated) 
│ ├── DocumentManager.json 
│ ├── AccessControl.json 
│ └── ApprovalWorkflow.json 
│ 
├── hardhat.config.js # Hardhat configuration 
├── truffle-config.js # Truffle configuration (alternative) 
└── .env 

text 

 

### **Root Project Structure** 

docuchain/ 
├── frontend/ # React application 
├── backend/ # Flask API server 
├── blockchain/ # Smart contracts 
├── docs/ # Documentation 
│ ├── API.md 
│ ├── ARCHITECTURE.md 



│ ├── DEPLOYMENT.md 
│ └── USER_GUIDE.md 
├── .github/ # GitHub workflows 
│ └── workflows/ 
│ ├── ci.yml 
│ └── deploy.yml 
├── docker-compose.yml # Multi-container setup 
├── .gitignore 
├── README.md 
└── LICENSE 

text 

 

--- 

 

# 5. Technical Stack 

 

## 5.1 Frontend Technologies 

 

| **Category** | **Technology** | **Version** | **Purpose** | 

|--------------|---------------|-------------|-------------| 

| **Framework** | React.js | 18.2+ | UI component library | 

| **Build Tool** | Vite | 4.3+ | Fast development server & bundler | 

| **State Management** | Redux Toolkit | 1.9+ | Global state management | 

| **Routing** | React Router | 6.11+ | Client-side routing | 

| **Styling** | Tailwind CSS | 3.3+ | Utility-first CSS framework | 

| **UI Components** | shadcn/ui | Latest | Pre-built accessible components | 

| **Icons** | Lucide React | Latest | Icon library | 

| **Forms** | React Hook Form | 7.43+ | Form validation | 

| **Schema Validation** | Zod | 3.21+ | TypeScript-first schema validation | 

| **HTTP Client** | Axios | 1.4+ | Promise-based HTTP client | 

| **WebSocket** | Socket.IO Client | 4.6+ | Real-time communication | 

| **Blockchain** | ethers.js | 6.3+ | Ethereum library | 

| **QR Code** | react-qr-code | 2.0+ | QR code generation | 



| **PDF Viewer** | react-pdf | 7.1+ | PDF document viewer | 

| **Date Handling** | date-fns | 2.30+ | Date utility library | 

| **Notifications** | react-toastify | 9.1+ | Toast notifications | 

| **File Upload** | react-dropzone | 14.2+ | Drag-and-drop file upload | 

| **Charts** | Recharts | 2.6+ | Analytics & charts | 

| **Rich Text Editor** | TipTap | 2.0+ | Document generation editor | 

 

### **Frontend Package.json** 

 

```json 

{ 

  "name": "docuchain-frontend", 

  "version": "1.0.0", 

  "scripts": { 

    "dev": "vite", 

    "build": "vite build", 

    "preview": "vite preview", 

    "lint": "eslint src --ext js,jsx", 

    "test": "vitest" 

  }, 

  "dependencies": { 

    "react": "^18.2.0", 

    "react-dom": "^18.2.0", 

    "react-router-dom": "^6.11.0", 

    "@reduxjs/toolkit": "^1.9.5", 

    "react-redux": "^8.0.5", 

    "axios": "^1.4.0", 

    "socket.io-client": "^4.6.1", 

    "ethers": "^6.3.0", 

    "tailwindcss": "^3.3.2", 

    "react-hook-form": "^7.43.9", 



    "zod": "^3.21.4", 

    "react-toastify": "^9.1.2", 

    "react-qr-code": "^2.0.11", 

    "react-pdf": "^7.1.0", 

    react-dropzone": "^14.2.3", 
"@tiptap/react": "^2.0.3", 
"@tiptap/starter-kit": "^2.0.3", 
"date-fns": "^2.30.0", 
"recharts": "^2.6.2", 
"lucide-react": "^0.263.1", 
"@radix-ui/react-dialog": "^1.0.4", 
"@radix-ui/react-dropdown-menu": "^2.0.5", 
"@radix-ui/react-tabs": "^1.0.4", 
"clsx": "^1.2.1", 
"tailwind-merge": "^1.13.2" 
}, 
"devDependencies": { 
"@vitejs/plugin-react": "^4.0.0", 
"vite": "^4.3.9", 
"eslint": "^8.42.0", 
"eslint-plugin-react": "^7.32.2", 
"vitest": "^0.32.0", 
"@testing-library/react": "^14.0.0", 
"autoprefixer": "^10.4.14", 
"postcss": "^8.4.24" 
} 
} 

text 

 

--- 

 

## 5.2 Backend Technologies 

 

| **Category** | **Technology** | **Version** | **Purpose** | 

|--------------|---------------|-------------|-------------| 

| **Framework** | Flask | 2.3+ | Python web framework | 

| **API Design** | Flask-RESTful | 0.3+ | RESTful API extension | 

| **CORS** | Flask-CORS | 4.0+ | Cross-origin resource sharing | 



| **WebSocket** | Flask-SocketIO | 5.3+ | Real-time bidirectional communication | 

| **Database ORM** | SQLAlchemy | 2.0+ | SQL toolkit & ORM | 

| **Migrations** | Alembic | 1.11+ | Database migration tool | 

| **Database** | PostgreSQL | 15+ | Relational database | 

| **Validation** | Marshmallow | 3.19+ | Object serialization/validation | 

| **Authentication** | Flask-JWT-Extended | 4.5+ | JWT token management | 

| **Password Hashing** | bcrypt | 4.0+ | Secure password hashing | 

| **IPFS Client** | requests | 2.31+ | HTTP library for Pinata API | 

| **Blockchain** | web3.py | 6.5+ | Ethereum Python library | 

| **Email** | Flask-Mail | 0.9+ | Email sending | 

| **Task Queue** | Celery | 5.3+ | Distributed task queue | 

| **Message Broker** | Redis | 4.5+ | In-memory data store | 

| **PDF Generation** | ReportLab | 4.0+ | PDF document generation | 

| **QR Code** | qrcode | 7.4+ | QR code generation | 

| **Image Processing** | Pillow | 10.0+ | Image manipulation | 

| **Environment Variables** | python-dotenv | 1.0+ | .env file support | 

| **Testing** | pytest | 7.3+ | Testing framework | 

| **API Documentation** | Flask-RESTX | 1.1+ | Swagger/OpenAPI documentation | 

 

### **Backend Requirements.txt** 

 

```txt 

# Core Framework 

Flask==2.3.3 

Flask-RESTful==0.3.10 

Flask-CORS==4.0.0 

Flask-SocketIO==5.3.4 

 

# Database 

SQLAlchemy==2.0.19 

psycopg2-binary==2.9.6 



alembic==1.11.1 

 

# Authentication & Security 

Flask-JWT-Extended==4.5.2 

bcrypt==4.0.1 

cryptography==41.0.3 

 

# Validation & Serialization 

marshmallow==3.20.1 

marshmallow-sqlalchemy==0.29.0 

 

# Blockchain 

web3==6.5.0 

eth-account==0.9.0 

 

# IPFS 

requests==2.31.0 

 

# Email 

Flask-Mail==0.9.1 

 

# Task Queue 

celery==5.3.1 

redis==4.6.0 

 

# PDF & QR Generation 

reportlab==4.0.4 

qrcode[pil]==7.4.2 

Pillow==10.0.0 

 

# Utilities 



python-dotenv==1.0.0 

python-dateutil==2.8.2 

 

# WebSocket 

python-socketio==5.9.0 

eventlet==0.33.3 

 

# API Documentation 

flask-restx==1.1.0 

 

# Development 

pytest==7.4.0 

pytest-flask==1.2.0 

pytest-cov==4.1.0 

black==23.7.0 

flake8==6.0.0 

 
5.3 Blockchain Technologies 

Category Technology Version Purpose 

Smart Contract Language Solidity 0.8.20 Contract programming language 

Development Framework Hardhat 2.17+ Ethereum development environment 

Testing Framework Mocha/Chai Latest Smart contract testing 

Network Ethereum Sepolia Testnet Test blockchain network 

Mainnet (Production) Ethereum Mainnet - Production blockchain 

Wallet Provider MetaMask Latest Browser wallet extension 

Node Provider Infura/Alchemy - Ethereum node access 

Storage IPFS (Pinata) - Decentralized file storage 

Contract Verification Etherscan API - Contract code verification 

Gas Optimization Hardhat Gas Reporter Latest Gas usage analysis 

Blockchain Package.json 



JSON 

{ 

  "name": "docuchain-contracts", 

  "version": "1.0.0", 

  "scripts": { 

    "compile": "hardhat compile", 

    "test": "hardhat test", 

    "deploy:sepolia": "hardhat run scripts/deploy.js --network sepolia", 

    "verify:sepolia": "hardhat verify --network sepolia", 

    "coverage": "hardhat coverage" 

  }, 

  "devDependencies": { 

    "@nomicfoundation/hardhat-toolbox": "^3.0.0", 

    "hardhat": "^2.17.0", 

    "@openzeppelin/contracts": "^4.9.2", 

    "@nomiclabs/hardhat-ethers": "^2.2.3", 

    "@nomiclabs/hardhat-etherscan": "^3.1.7", 

    "chai": "^4.3.7", 

    "ethers": "^6.3.0", 

    "hardhat-gas-reporter": "^1.0.9", 

    "solidity-coverage": "^0.8.4" 

  } 

} 

 
5.4 Infrastructure & DevOps 

Category Technology Purpose 

Containerization Docker Application containerization 

Orchestration Docker Compose Multi-container management 

CI/CD GitHub Actions Automated testing & deployment 

Web Server Nginx Reverse proxy & static files 



Category Technology Purpose 

WSGI Server Gunicorn Python WSGI HTTP server 

Process Manager PM2 Node.js process management 

SSL/TLS Let's Encrypt Free SSL certificates 

Monitoring Prometheus + Grafana Metrics & visualization 

Logging ELK Stack Centralized logging 

Cloud Provider AWS/DigitalOcean/Heroku Hosting infrastructure 

Docker Compose Configuration 

YAML 

version: '3.8' 

 

services: 

  # PostgreSQL Database 

  db: 

    image: postgres:15-alpine 

    container_name: docuchain-db 

    environment: 

      POSTGRES_DB: docuchain 

      POSTGRES_USER: ${DB_USER} 

      POSTGRES_PASSWORD: ${DB_PASSWORD} 

    volumes: 

      - postgres_data:/var/lib/postgresql/data 

    ports: 

      - "5432:5432" 

    networks: 

      - docuchain-network 

 

  # Redis Cache & Message Broker 

  redis: 

    image: redis:7-alpine 



    container_name: docuchain-redis 

    ports: 

      - "6379:6379" 

    networks: 

      - docuchain-network 

 

  # Flask Backend 

  backend: 

    build: 

      context: ./backend 

      dockerfile: Dockerfile 

    container_name: docuchain-backend 

    environment: 

      - FLASK_ENV=${FLASK_ENV} 

      - DATABASE_URL=postgresql://${DB_USER}:${DB_PASSWORD}@db:5432/docuchain 

      - REDIS_URL=redis://redis:6379/0 

      - PINATA_API_KEY=${PINATA_API_KEY} 

      - PINATA_SECRET_KEY=${PINATA_SECRET_KEY} 

      - JWT_SECRET_KEY=${JWT_SECRET_KEY} 

      - ETHEREUM_RPC_URL=${ETHEREUM_RPC_URL} 

      - CONTRACT_ADDRESS=${CONTRACT_ADDRESS} 

    volumes: 

      - ./backend:/app 

      - backend_logs:/app/logs 

    ports: 

      - "5000:5000" 

    depends_on: 

      - db 

      - redis 

    networks: 

      - docuchain-network 



 

  # Celery Worker 

  celery-worker: 

    build: 

      context: ./backend 

      dockerfile: Dockerfile 

    container_name: docuchain-celery 

    command: celery -A app.celery_worker worker --loglevel=info 

    environment: 

      - DATABASE_URL=postgresql://${DB_USER}:${DB_PASSWORD}@db:5432/docuchain 

      - REDIS_URL=redis://redis:6379/0 

    volumes: 

      - ./backend:/app 

    depends_on: 

      - redis 

      - db 

    networks: 

      - docuchain-network 

 

  # React Frontend 

  frontend: 

    build: 

      context: ./frontend 

      dockerfile: Dockerfile 

    container_name: docuchain-frontend 

    environment: 

      - VITE_API_URL=http://localhost:5000/api 

      - VITE_WS_URL=http://localhost:5000 

      - VITE_CONTRACT_ADDRESS=${CONTRACT_ADDRESS} 

      - VITE_CHAIN_ID=${CHAIN_ID} 

    volumes: 



      - ./frontend:/app 

      - /app/node_modules 

    ports: 

      - "3000:3000" 

    depends_on: 

      - backend 

    networks: 

      - docuchain-network 

 

  # Nginx Reverse Proxy 

  nginx: 

    image: nginx:alpine 

    container_name: docuchain-nginx 

    volumes: 

      - ./nginx.conf:/etc/nginx/nginx.conf 

      - ./frontend/dist:/usr/share/nginx/html 

    ports: 

      - "80:80" 

      - "443:443" 

    depends_on: 

      - frontend 

      - backend 

    networks: 

      - docuchain-network 

 

volumes: 

  postgres_data: 

  backend_logs: 

 

networks: 

  docuchain-network: 



    driver: bridge 

 
6. Feature Specifications 

6.1 Authentication & Authorization 

6.1.1 Institution Creation 

User Story: 

As an institution administrator, I want to create an institution profile so that faculty and students can 
register under it. 

Functional Requirements: 

Requirement ID Description Priority 

Admin fills institution creation form with: name, type 
AUTH-IC-001 (school/college/university/coaching), address, website, email, contact number P0 

AUTH-IC-002 System generates unique institution ID (e.g., INST-2024-001) P0 

Admin fills personal details: name, admin ID, email, phone, password, department, 
AUTH-IC-003 wallet address P0 

AUTH-IC-004 System sends OTP to admin email for verification P0 

AUTH-IC-005 Upon OTP verification, institution is created and admin account is activated P0 

AUTH-IC-006 System creates default groups: "All Institution Members" P1 

AUTH-IC-007 Institution details stored in blockchain for immutability verification P2 

API Endpoints: 

text 

POST /api/auth/create-institution 

Request Body: 

{ 

  "institution": { 

    "name": "ABC University", 

    "type": "university", 

    "address": "123 Main St, City", 

    "website": "https://abc.edu", 

    "email": "admin@abc.edu", 

    "contact": "+1234567890" 



  }, 

  "admin": { 

    "firstName": "John", 

    "lastName": "Doe", 

    "adminId": "ADMIN001", 

    "email": "john@abc.edu", 

    "phone": "+1234567890", 

    "password": "hashedPassword", 

    "department": "Administration", 

    "walletAddress": "0x..." 

  } 

} 

 

Response: 

{ 

  "success": true, 

  "data": { 

    "institutionId": "INST-2024-001", 

    "uniqueId": "ABC-UNI-2024", 

    "adminId": "USER-001", 

    "otpSent": true 

  } 

} 

text 

POST /api/auth/verify-institution-otp 

Request Body: 

{ 

  "institutionId": "INST-2024-001", 

  "email": "admin@abc.edu", 

  "otp": "123456" 

} 



 

Response: 

{ 

  "success": true, 

  "message": "Institution created successfully", 

  "data": { 

    "institutionId": "INST-2024-001", 

    "adminToken": "jwt_token_here" 

  } 

} 

Database Schema: 

SQL 

CREATE TABLE institutions ( 

    id SERIAL PRIMARY KEY, 

    institution_id VARCHAR(50) UNIQUE NOT NULL, 

    unique_id VARCHAR(50) UNIQUE NOT NULL, 

    name VARCHAR(255) NOT NULL, 

    type VARCHAR(50) NOT NULL, 

    address TEXT, 

    website VARCHAR(255), 

    email VARCHAR(255) NOT NULL, 

    contact VARCHAR(20), 

    blockchain_hash VARCHAR(66), 

    is_verified BOOLEAN DEFAULT FALSE, 

    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, 

    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP 

); 

Smart Contract Function: 

solidity 

function registerInstitution( 

    string memory _institutionId, 



    string memory _name, 

    bytes32 _dataHash 

) public returns (bool) { 

    require(!institutions[_institutionId].exists, "Institution already registered"); 

     

    institutions[_institutionId] = Institution({ 

        institutionId: _institutionId, 

        name: _name, 

        admin: msg.sender, 

        dataHash: _dataHash, 

        timestamp: block.timestamp, 

        exists: true 

    }); 

     

    emit InstitutionRegistered(_institutionId, msg.sender, block.timestamp); 

    return true; 

} 

 
6.1.2 User Registration (Faculty/Student) 

User Story: 

As a student/faculty member, I want to create an account under my institution so that I can access the 
document management system. 

Functional Requirements: 

Requirement ID Description Priority 

AUTH-UR-001 User clicks "Create Account" from login page P0 

AUTH-UR-002 User selects role: Admin / Faculty / Student P0 

AUTH-UR-003 Form fields dynamically change based on role selection P0 

Common fields: first name, last name, email, phone, password, wallet address, 
AUTH-UR-004 institution name, unique institution ID P0 

AUTH-UR-005 Faculty fields: employee ID, department, designation  



| P0 | 
| AUTH-UR-006 | Student fields: student ID, department, section, year, roll number | P0 | 
| AUTH-UR-007 | System validates institution name and unique ID match | P0 | 
| AUTH-UR-008 | System validates wallet address format (Ethereum address) | P0 | 
| AUTH-UR-009 | Registration request sent to admin for approval | P0 | 
| AUTH-UR-010 | User cannot login until admin approves the request | P0 | 
| AUTH-UR-011 | User receives email notification when account is approved/rejected | P0 | 
| AUTH-UR-012 | Upon approval, user automatically joins institution-wide group | P1 | 
| AUTH-UR-013 | Upon approval, user automatically joins department group | P1 | 
| AUTH-UR-014 | Upon approval, student automatically joins section group | P1 | 

API Endpoints: 

text 

POST /api/auth/register 

Request Body: 

{ 

  "role": "student", 

  "firstName": "Jane", 

  "lastName": "Smith", 

  "email": "jane@student.abc.edu", 

  "phone": "+1234567890", 

  "password": "hashedPassword", 

  "walletAddress": "0xABC...", 

  "institutionName": "ABC University", 

  "institutionUniqueId": "ABC-UNI-2024", 

  "studentDetails": { 

    "studentId": "STU2024001", 

    "department": "Computer Science", 

    "section": "A", 

    "year": "2024", 

    "rollNumber": "CS001" 

  } 

} 

 

Response: 



{ 

  "success": true, 

  "message": "Registration request submitted. Please wait for admin approval.", 

  "data": { 

    "requestId": "REQ-2024-001", 

    "status": "pending" 

  } 

} 

text 

GET /api/auth/registration-status/:requestId 

Response: 

{ 

  "success": true, 

  "data": { 

    "requestId": "REQ-2024-001", 

    "status": "approved", // or "pending" or "rejected" 

    "approvedBy": "ADMIN001", 

    "approvedAt": "2024-01-15T10:30:00Z", 

    "message": "Your account has been approved" 

  } 

} 

Database Schema: 

SQL 

CREATE TABLE users ( 

    id SERIAL PRIMARY KEY, 

    user_id VARCHAR(50) UNIQUE NOT NULL, 

    institution_id INTEGER REFERENCES institutions(id), 

    role VARCHAR(20) NOT NULL CHECK (role IN ('admin', 'faculty', 'student')), 

    first_name VARCHAR(100) NOT NULL, 

    last_name VARCHAR(100) NOT NULL, 

    email VARCHAR(255) UNIQUE NOT NULL, 



    phone VARCHAR(20), 

    password_hash VARCHAR(255) NOT NULL, 

    wallet_address VARCHAR(42) NOT NULL, 

    is_active BOOLEAN DEFAULT FALSE, 

    is_verified BOOLEAN DEFAULT FALSE, 

    profile_image TEXT, 

    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, 

    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, 

    last_login TIMESTAMP 

); 

 

CREATE TABLE faculty_details ( 

    id SERIAL PRIMARY KEY, 

    user_id INTEGER REFERENCES users(id), 

    employee_id VARCHAR(50) UNIQUE NOT NULL, 

    department_id INTEGER REFERENCES departments(id), 

    designation VARCHAR(100), 

    joining_date DATE, 

    is_hod BOOLEAN DEFAULT FALSE 

); 

 

CREATE TABLE student_details ( 

    id SERIAL PRIMARY KEY, 

    user_id INTEGER REFERENCES users(id), 

    student_id VARCHAR(50) UNIQUE NOT NULL, 

    department_id INTEGER REFERENCES departments(id), 

    section_id INTEGER REFERENCES sections(id), 

    year INTEGER, 

    roll_number VARCHAR(50), 

    enrollment_date DATE 

); 



 

CREATE TABLE registration_requests ( 

    id SERIAL PRIMARY KEY, 

    request_id VARCHAR(50) UNIQUE NOT NULL, 

    institution_id INTEGER REFERENCES institutions(id), 

    role VARCHAR(20) NOT NULL, 

    first_name VARCHAR(100), 

    last_name VARCHAR(100), 

    email VARCHAR(255), 

    phone VARCHAR(20), 

    password_hash VARCHAR(255), 

    wallet_address VARCHAR(42), 

    additional_data JSONB, -- Role-specific data 

    status VARCHAR(20) DEFAULT 'pending', -- pending, approved, rejected 

    approved_by INTEGER REFERENCES users(id), 

    approved_at TIMESTAMP, 

    rejection_reason TEXT, 

    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP 

); 

 
6.1.3 Login & Session Management 

User Story: 

As a registered user, I want to login securely and maintain my session across page refreshes. 

Functional Requirements: 

Requirement ID Description Priority 

AUTH-LG-001 User enters email and password P0 

AUTH-LG-002 System validates credentials against database P0 

AUTH-LG-003 System checks if user account is active (approved by admin) P0 

AUTH-LG-004 System generates JWT token with user details and role P0 

AUTH-LG-005 Token stored in httpOnly cookie for security P0 



Requirement ID Description Priority 

AUTH-LG-006 User redirected to role-specific dashboard P0 

AUTH-LG-007 System logs user activity (login timestamp) P1 

AUTH-LG-008 System validates MetaMask wallet connection P1 

AUTH-LG-009 Token expires after 24 hours (configurable) P1 

AUTH-LG-010 Refresh token mechanism for seamless re-authentication P2 

API Endpoints: 

text 

POST /api/auth/login 

Request Body: 

{ 

  "email": "john@abc.edu", 

  "password": "userPassword" 

} 

 

Response: 

{ 

  "success": true, 

  "message": "Login successful", 

  "data": { 

    "user": { 

      "userId": "USER-001", 

      "firstName": "John", 

      "lastName": "Doe", 

      "email": "john@abc.edu", 

      "role": "admin", 

      "institutionId": "INST-2024-001", 

      "walletAddress": "0x...", 

      "profileImage": "https://..." 

    }, 



    "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...", 

    "expiresIn": 86400 

  } 

} 

text 

POST /api/auth/logout 

Headers: Authorization: Bearer <token> 

 

Response: 

{ 

  "success": true, 

  "message": "Logout successful" 

} 

text 

POST /api/auth/refresh-token 

Request Body: 

{ 

  "refreshToken": "refresh_token_here" 

} 

 

Response: 

{ 

  "success": true, 

  "data": { 

    "token": "new_jwt_token", 

    "expiresIn": 86400 

  } 

} 

text 

GET /api/auth/me 

Headers: Authorization: Bearer <token> 



 

Response: 

{ 

  "success": true, 

  "data": { 

    "user": { /* user details */ } 

  } 

} 

JWT Token Structure: 

JSON 

{ 

  "header": { 

    "alg": "HS256", 

    "typ": "JWT" 

  }, 

  "payload": { 

    "userId": "USER-001", 

    "email": "john@abc.edu", 

    "role": "admin", 

    "institutionId": "INST-2024-001", 

    "walletAddress": "0x...", 

    "iat": 1642156800, 

    "exp": 1642243200 

  }, 

  "signature": "HMACSHA256(...)" 

} 

Session Management Flow: 

text 

User Login 

    ↓ 

Validate Credentials 



    ↓ 

Generate JWT Token 

    ↓ 

Store in httpOnly Cookie 

    ↓ 

Set Redis Cache (session_id → user_data) 

    ↓ 

Return User Data + Token 

    ↓ 

[User Navigates Application] 

    ↓ 

Every Request → Validate Token 

    ↓ 

Token Valid? → Allow Access 

    ↓ 

Token Expired? → Refresh Token Flow 

    ↓ 

Refresh Failed? → Redirect to Login 

 
6.1.4 Wallet Integration 

User Story: 

As a user, I want to connect my MetaMask wallet to interact with blockchain features. 

Functional Requirements: 

Requirement ID Description Priority 

AUTH-WL-001 "Connect Wallet" button visible in header P0 

AUTH-WL-002 Clicking button triggers MetaMask connection popup P0 

AUTH-WL-003 System validates wallet address matches registered address P0 

AUTH-WL-004 System switches to Sepolia testnet if on wrong network P0 

AUTH-WL-005 Wallet connection status displayed in header (connected/disconnected) P0 

AUTH-WL-006 User can disconnect wallet from UI P1 



Requirement ID Description Priority 

AUTH-WL-007 System detects wallet account changes and prompts re-connection P1 

AUTH-WL-008 System detects network changes and prompts network switch P1 

AUTH-WL-009 Users can link multiple wallet addresses to one account P2 

AUTH-WL-010 Users can switch between linked wallets P2 

React Component Example: 

React 

// components/auth/WalletConnect.jsx 

import { useState, useEffect } from 'react'; 

import { ethers } from 'ethers'; 

import { useWallet } from '../../hooks/useWallet'; 

 

export default function WalletConnect() { 

  const { 

    isConnected, 

    walletAddress, 

    connectWallet, 

    disconnectWallet, 

    switchNetwork 

  } = useWallet(); 

 

  const handleConnect = async () => { 

    try { 

      await connectWallet(); 

    } catch (error) { 

      console.error('Wallet connection failed:', error); 

    } 

  }; 

 

  return ( 



    <div className="wallet-connect"> 

      {!isConnected ? ( 

        <button onClick={handleConnect} className="btn-connect"> 

          Connect Wallet 

        </button> 

      ) : ( 

        <div className="wallet-info"> 

          <span className="wallet-address"> 

            {walletAddress.slice(0, 6)}...{walletAddress.slice(-4)} 

          </span> 

          <button onClick={disconnectWallet} className="btn-disconnect"> 

            Disconnect 

          </button> 

        </div> 

      )} 

    </div> 

  ); 

} 

Custom Hook - useWallet.js: 

JavaScript 

// hooks/useWallet.js 

import { useState, useEffect, useContext } from 'react'; 

import { ethers } from 'ethers'; 

import { WalletContext } from '../context/WalletContext'; 

 

const SEPOLIA_CHAIN_ID = '0xaa36a7'; // 11155111 in hex 

 

export const useWallet = () => { 

  const [isConnected, setIsConnected] = useState(false); 

  const [walletAddress, setWalletAddress] = useState(''); 

  const [provider, setProvider] = useState(null); 



  const [signer, setSigner] = useState(null); 

 

  const connectWallet = async () => { 

    if (!window.ethereum) { 

      alert('Please install MetaMask!'); 

      return; 

    } 

 

    try { 

      // Request account access 

      const accounts = await window.ethereum.request({ 

        method: 'eth_requestAccounts' 

      }); 

 

      // Check network 

      const chainId = await window.ethereum.request({ 

        method: 'eth_chainId' 

      }); 

 

      if (chainId !== SEPOLIA_CHAIN_ID) { 

        await switchNetwork(); 

      } 

 

      // Initialize provider and signer 

      const web3Provider = new ethers.BrowserProvider(window.ethereum); 

      const web3Signer = await web3Provider.getSigner(); 

 

      setProvider(web3Provider); 

      setSigner(web3Signer); 

      setWalletAddress(accounts[0]); 

      setIsConnected(true); 



 

      // Store in localStorage 

      localStorage.setItem('walletConnected', 'true'); 

      localStorage.setItem('walletAddress', accounts[0]); 

    } catch (error) { 

      console.error('Error connecting wallet:', error); 

      throw error; 

    } 

  }; 

 

  const switchNetwork = async () => { 

    try { 

      await window.ethereum.request({ 

        method: 'wallet_switchEthereumChain', 

        params: [{ chainId: SEPOLIA_CHAIN_ID }] 

      }); 

    } catch (error) { 

      // Network not added, add it 

      if (error.code === 4902) { 

        await window.ethereum.request({ 

          method: 'wallet_addEthereumChain', 

          params: [{ 

            chainId: SEPOLIA_CHAIN_ID, 

            chainName: 'Sepolia Testnet', 

            nativeCurrency: { 

              name: 'SepoliaETH', 

              symbol: 'ETH', 

              decimals: 18 

            }, 

            rpcUrls: ['https://sepolia.infura.io/v3/YOUR_KEY'], 

            blockExplorerUrls: ['https://sepolia.etherscan.io'] 



          }] 

        }); 

      } 

    } 

  }; 

 

  const disconnectWallet = () => { 

    setIsConnected(false); 

    setWalletAddress(''); 

    setProvider(null); 

    setSigner(null); 

    localStorage.removeItem('walletConnected'); 

    localStorage.removeItem('walletAddress'); 

  }; 

 

  // Auto-connect on mount 

  useEffect(() => { 

    const wasConnected = localStorage.getItem('walletConnected'); 

    if (wasConnected === 'true' && window.ethereum) { 

      connectWallet(); 

    } 

  }, []); 

 

  // Listen for account changes 

  useEffect(() => { 

    if (!window.ethereum) return; 

 

    const handleAccountsChanged = (accounts) => { 

      if (accounts.length === 0) { 

        disconnectWallet(); 

      } else { 



        setWalletAddress(accounts[0]); 

      } 

    }; 

 

    const handleChainChanged = () => { 

      window.location.reload(); 

    }; 

 

    window.ethereum.on('accountsChanged', handleAccountsChanged); 

    window.ethereum.on('chainChanged', handleChainChanged); 

 

    return () => { 

      window.ethereum.removeListener('accountsChanged', handleAccountsChanged); 

      window.ethereum.removeListener('chainChanged', handleChainChanged); 

    }; 

  }, []); 

 

  return { 

    isConnected, 

    walletAddress, 

    provider, 

    signer, 

    connectWallet, 

    disconnectWallet, 

    switchNetwork 

  }; 

}; 

 
6.2 File Manager 

6.2.1 Document Upload to IPFS 

User Story: 



As a user, I want to upload documents to IPFS so they are stored permanently in a decentralized 
manner. 

Functional Requirements: 

Requirement ID Description Priority 

FM-UP-001 User clicks "Upload" button in file manager P0 

FM-UP-002 File picker dialog opens (supports drag-and-drop) P0 

FM-UP-003 User selects file(s) from local storage P0 

FM-UP-004 System validates file type and size (max 100MB per file) P0 

FM-UP-005 Upload progress bar displayed with percentage P0 

FM-UP-006 File uploaded to Pinata IPFS service P0 

FM-UP-007 System receives IPFS hash (CID) P0 

FM-UP-008 System  

prompts user to confirm blockchain upload | P0 | 
| FM-UP-009 | MetaMask transaction popup appears for gas fee approval | P0 | 
| FM-UP-010 | Document metadata stored on blockchain (IPFS hash, filename, size, type, timestamp) | 
P0 | 
| FM-UP-011 | Transaction hash and block number returned | P0 | 
| FM-UP-012 | Document metadata stored in PostgreSQL database | P0 | 
| FM-UP-013 | Document appears in user's "My Files" section | P0 | 
| FM-UP-014 | User can upload multiple files simultaneously (batch upload) | P1 | 
| FM-UP-015 | System generates thumbnail preview for images/PDFs | P1 | 
| FM-UP-016 | Upload fails gracefully with error messages | P1 | 
| FM-UP-017 | Failed uploads can be retried | P1 | 
| FM-UP-018 | System logs upload activity in activity log | P1 | 

Supported File Types: 

Category Extensions Max Size 

Documents .pdf, .doc, .docx, .txt, .rtf 100 MB 

Images .jpg, .jpeg, .png, .gif, .svg 50 MB 

Spreadsheets .xls, .xlsx, .csv 50 MB 

Presentations .ppt, .pptx 100 MB 

Archives .zip, .rar, .tar 200 MB 

API Endpoints: 

text 

POST /api/files/upload-to-ipfs 



Content-Type: multipart/form-data 

Headers: Authorization: Bearer <token> 

 

Request Body: 

{ 

  "file": <binary_file_data>, 

  "fileName": "document.pdf", 

  "fileType": "application/pdf", 

  "folderId": "FOLDER-001" // Optional 

} 

 

Response: 

{ 

  "success": true, 

  "data": { 

    "ipfsHash": "QmXYZ123abc...", 

    "fileName": "document.pdf", 

    "fileSize": 1024000, 

    "fileType": "application/pdf", 

    "pinataUrl": "https://gateway.pinata.cloud/ipfs/QmXYZ123abc..." 

  } 

} 

text 

POST /api/files/upload-to-blockchain 

Headers: Authorization: Bearer <token> 

 

Request Body: 

{ 

  "ipfsHash": "QmXYZ123abc...", 

  "fileName": "document.pdf", 

  "fileSize": 1024000, 



  "fileType": "application/pdf", 

  "transactionHash": "0xabc123...", 

  "blockNumber": 12345678, 

  "documentId": "0x1234...", // From smart contract 

  "folderId": "FOLDER-001" // Optional 

} 

 

Response: 

{ 

  "success": true, 

  "message": "Document uploaded successfully", 

  "data": { 

    "documentId": "DOC-2024-001", 

    "ipfsHash": "QmXYZ123abc...", 

    "blockchainVerified": true, 

    "transactionHash": "0xabc123...", 

    "createdAt": "2024-01-15T10:30:00Z" 

  } 

} 

React Component - File Upload: 

React 

// components/file-manager/FileUpload.jsx 

import { useState } from 'react'; 

import { useDropzone } from 'react-dropzone'; 

import { uploadToIPFS, uploadToBlockchain } from '../../services/fileService'; 

import { useWallet } from '../../hooks/useWallet'; 

import { toast } from 'react-toastify'; 

 

export default function FileUpload({ folderId, onUploadComplete }) { 

  const [uploading, setUploading] = useState(false); 

  const [progress, setProgress] = useState(0); 



  const { signer, walletAddress } = useWallet(); 

 

  const onDrop = async (acceptedFiles) => { 

    if (!signer) { 

      toast.error('Please connect your wallet first'); 

      return; 

    } 

 

    setUploading(true); 

 

    for (const file of acceptedFiles) { 

      try { 

        // Step 1: Upload to IPFS 

        setProgress(30); 

        const ipfsResult = await uploadToIPFS(file); 

         

        toast.info('File uploaded to IPFS. Confirming blockchain transaction...'); 

 

        // Step 2: Upload to Blockchain 

        setProgress(60); 

        const blockchainResult = await uploadToBlockchain({ 

          ipfsHash: ipfsResult.ipfsHash, 

          fileName: file.name, 

          fileSize: file.size, 

          fileType: file.type, 

          folderId, 

          signer 

        }); 

 

        setProgress(100); 

        toast.success(`${file.name} uploaded successfully!`); 



         

        onUploadComplete(blockchainResult.data); 

      } catch (error) { 

        console.error('Upload error:', error); 

        toast.error(`Failed to upload ${file.name}: ${error.message}`); 

      } 

    } 

 

    setUploading(false); 

    setProgress(0); 

  }; 

 

  const { getRootProps, getInputProps, isDragActive } = useDropzone({ 

    onDrop, 

    maxSize: 100 * 1024 * 1024, // 100MB 

    accept: { 

      'application/pdf': ['.pdf'], 

      'application/msword': ['.doc'], 

      'application/vnd.openxmlformats-officedocument.wordprocessingml.document': ['.docx'], 

      'image/*': ['.jpg', '.jpeg', '.png', '.gif'], 

      'text/plain': ['.txt'] 

    } 

  }); 

 

  return ( 

    <div className="file-upload"> 

      <div 

        {...getRootProps()} 

        className={`dropzone ${isDragActive ? 'active' : ''}`} 

      > 

        <input {...getInputProps()} /> 



        {uploading ? ( 

          <div className="upload-progress"> 

            <div className="progress-bar"> 

              <div  

                className="progress-fill"  

                style={{ width: `${progress}%` }} 

              /> 

            </div> 

            <p>Uploading... {progress}%</p> 

          </div> 

        ) : ( 

          <> 

            <svg className="upload-icon"> 

              <use href="#icon-upload" /> 

            </svg> 

            <p>Drag and drop files here, or click to select</p> 

            <span className="file-types"> 

              Supported: PDF, DOC, DOCX, Images (Max 100MB) 

            </span> 

          </> 

        )} 

      </div> 

    </div> 

  ); 

} 

Backend Service - IPFS Upload: 

Python 

# backend/app/services/ipfs_service.py 

import requests 

from flask import current_app 

 



class IPFSService: 

    def __init__(self): 

        self.api_url = "https://api.pinata.cloud/pinning/pinFileToIPFS" 

        self.api_key = current_app.config['PINATA_API_KEY'] 

        self.secret_key = current_app.config['PINATA_SECRET_KEY'] 

     

    def upload_file(self, file, filename): 

        """Upload file to IPFS via Pinata""" 

        try: 

            headers = { 

                'pinata_api_key': self.api_key, 

                'pinata_secret_api_key': self.secret_key 

            } 

             

            files = { 

                'file': (filename, file.stream, file.content_type) 

            } 

             

            # Optional metadata 

            metadata = { 

                'name': filename, 

                'keyvalues': { 

                    'uploadedBy': 'DocuChain', 

                    'timestamp': str(datetime.utcnow()) 

                } 

            } 

             

            data = { 

                'pinataMetadata': json.dumps(metadata), 

                'pinataOptions': json.dumps({ 

                    'cidVersion': 1 



                }) 

            } 

             

            response = requests.post( 

                self.api_url, 

                files=files, 

                data=data, 

                headers=headers 

            ) 

             

            if response.status_code == 200: 

                result = response.json() 

                return { 

                    'ipfsHash': result['IpfsHash'], 

                    'pinataUrl': f"https://gateway.pinata.cloud/ipfs/{result['IpfsHash']}", 

                    'timestamp': result['Timestamp'] 

                } 

            else: 

                raise Exception(f"IPFS upload failed: {response.text}") 

                 

        except Exception as e: 

            current_app.logger.error(f"IPFS upload error: {str(e)}") 

            raise 

     

    def get_file_metadata(self, ipfs_hash): 

        """Get metadata for pinned file""" 

        url = f"https://api.pinata.cloud/data/pinList?hashContains={ipfs_hash}" 

        headers = { 

            'pinata_api_key': self.api_key, 

            'pinata_secret_api_key': self.secret_key 

        } 



         

        response = requests.get(url, headers=headers) 

        if response.status_code == 200: 

            return response.json() 

        return None 

     

    def unpin_file(self, ipfs_hash): 

        """Unpin file from IPFS (for deleted documents)""" 

        url = f"https://api.pinata.cloud/pinning/unpin/{ipfs_hash}" 

        headers = { 

            'pinata_api_key': self.api_key, 

            'pinata_secret_api_key': self.secret_key 

        } 

         

        response = requests.delete(url, headers=headers) 

        return response.status_code == 200 

Smart Contract - Document Upload: 

solidity 

// contracts/DocumentManager.sol 

// SPDX-License-Identifier: MIT 

pragma solidity ^0.8.20; 

 

contract DocumentManager { 

    struct Document { 

        bytes32 documentId; 

        string ipfsHash; 

        address owner; 

        uint256 timestamp; 

        string fileName; 

        uint256 fileSize; 

        string fileType; 



        bool isActive; 

    } 

     

    mapping(bytes32 => Document) public documents; 

    mapping(address => bytes32[]) public userDocuments; 

     

    event DocumentUploaded( 

        bytes32 indexed documentId, 

        string ipfsHash, 

        address indexed owner, 

        uint256 timestamp 

    ); 

     

    event DocumentDeleted( 

        bytes32 indexed documentId, 

        address indexed owner, 

        uint256 timestamp 

    ); 

     

    function uploadDocument( 

        string memory _ipfsHash, 

        string memory _fileName, 

        uint256 _fileSize, 

        string memory _fileType 

    ) public returns (bytes32) { 

        require(bytes(_ipfsHash).length > 0, "IPFS hash cannot be empty"); 

        require(bytes(_fileName).length > 0, "File name cannot be empty"); 

         

        // Generate unique document ID 

        bytes32 documentId = keccak256( 

            abi.encodePacked( 



                _ipfsHash, 

                msg.sender, 

                block.timestamp 

            ) 

        ); 

         

        require(!documents[documentId].isActive, "Document already exists"); 

         

        // Store document 

        documents[documentId] = Document({ 

            documentId: documentId, 

            ipfsHash: _ipfsHash, 

            owner: msg.sender, 

            timestamp: block.timestamp, 

            fileName: _fileName, 

            fileSize: _fileSize, 

            fileType: _fileType, 

            isActive: true 

        }); 

         

        // Add to user's document list 

        userDocuments[msg.sender].push(documentId); 

         

        emit DocumentUploaded(documentId, _ipfsHash, msg.sender, block.timestamp); 

         

        return documentId; 

    } 

     

    function getDocument(bytes32 _documentId) public view returns ( 

        string memory ipfsHash, 

        address owner, 



        uint256 timestamp, 

        string memory fileName, 

        uint256 fileSize, 

        string memory fileType, 

        bool isActive 

    ) { 

        Document memory doc = documents[_documentId]; 

        require(doc.isActive, "Document not found or deleted"); 

         

        return ( 

            doc.ipfsHash, 

            doc.owner, 

            doc.timestamp, 

            doc.fileName, 

            doc.fileSize, 

            doc.fileType, 

            doc.isActive 

        ); 

    } 

     

    function getUserDocuments(address _user) public view returns (bytes32[] memory) { 

        return userDocuments[_user]; 

    } 

     

    function deleteDocument(bytes32 _documentId) public { 

        Document storage doc = documents[_documentId]; 

        require(doc.isActive, "Document not found"); 

        require(doc.owner == msg.sender, "Only owner can delete document"); 

         

        doc.isActive = false; 

         



        emit DocumentDeleted(_documentId, msg.sender, block.timestamp); 

    } 

} 

 
6.2.2 File Organization (Folders) 

User Story: 

As a user, I want to organize my documents into folders for better management. 

Functional Requirements: 

Requirement ID Description Priority 

FM-FO-001 User can create new folders by clicking "New Folder" button P0 

FM-FO-002 Folder name must be unique within parent directory P0 

FM-FO-003 User can create nested folders (subdirectories) P0 

FM-FO-004 User can rename folders P0 

FM-FO-005 User can delete empty folders P0 

FM-FO-006 User can delete folders with contents (moves to trash) P0 

FM-FO-007 User can move files between folders (drag-and-drop) P1 

FM-FO-008 User can copy files to different folders P1 

FM-FO-009 System creates default folders: Shared, Drafts, Approvals, Trash P0 

FM-FO-010 Folder structure displayed in tree view P1 

FM-FO-011 Breadcrumb navigation shows current folder path P1 

FM-FO-012 Folder metadata: created date, modified date, file count P1 

System-Generated Folders: 

Folder Name Purpose Auto-Created 

My Files Root folder for user uploads Yes 

Shared Files shared with/by user Yes 

Drafts Draft documents from generator Yes 

Approvals Documents pending/approved Yes 

├─ Sent Requests Documents sent for approval Yes 

└─ Received Requests Documents to approve Yes 



Folder Name Purpose Auto-Created 

Trash Deleted files (30-day retention) Yes 

API Endpoints: 

text 

POST /api/files/folders 

Headers: Authorization: Bearer <token> 

 

Request Body: 

{ 

  "name": "Project Reports", 

  "parentFolderId": null, // null for root level 

  "color": "#4CAF50" // Optional 

} 

 

Response: 

{ 

  "success": true, 

  "data": { 

    "folderId": "FOLDER-001", 

    "name": "Project Reports", 

    "parentFolderId": null, 

    "path": "/My Files/Project Reports", 

    "createdAt": "2024-01-15T10:30:00Z" 

  } 

} 

text 

GET /api/files/folders 

Headers: Authorization: Bearer <token> 

Query: ?parentId=FOLDER-001 

 

Response: 



{ 

  "success": true, 

  "data": { 

    "folders": [ 

      { 

        "folderId": "FOLDER-002", 

        "name": "2024 Reports", 

        "parentFolderId": "FOLDER-001", 

        "fileCount": 5, 

        "createdAt": "2024 

-01-15T10:30:00Z", 
"updatedAt": "2024-01-20T14:20:00Z" 
} 
], 
"files": [ 
{ 
"documentId": "DOC-001", 
"fileName": "Report_Q1.pdf", 
"fileSize": 2048000, 
"fileType": "application/pdf", 
"ipfsHash": "QmXYZ...", 
"createdAt": "2024-01-15T11:00:00Z" 
} 
] 
} 
} 

PUT /api/files/folders/:folderId 
Headers: Authorization: Bearer <token> 

Request Body: 
{ 
"name": "Updated Folder Name", 
"color": "#2196F3" 
} 

Response: 
{ 
"success": true, 
"message": "Folder updated successfully" 
} 



DELETE /api/files/folders/:folderId 
Headers: Authorization: Bearer <token> 

Response: 
{ 
"success": true, 
"message": "Folder moved to trash" 
} 

POST /api/files/move 
Headers: Authorization: Bearer <token> 

Request Body: 
{ 
"documentId": "DOC-001", 
"targetFolderId": "FOLDER-002" 
} 

Response: 
{ 
"success": true, 
"message": "File moved successfully" 
} 

text 

 

**Database Schema:** 

 

```sql 

CREATE TABLE folders ( 

    id SERIAL PRIMARY KEY, 

    folder_id VARCHAR(50) UNIQUE NOT NULL, 

    user_id INTEGER REFERENCES users(id), 

    name VARCHAR(255) NOT NULL, 

    parent_folder_id INTEGER REFERENCES folders(id), 

    path TEXT NOT NULL, -- Full path for quick lookup 

    color VARCHAR(7), 

    is_system_folder BOOLEAN DEFAULT FALSE, 

    is_deleted BOOLEAN DEFAULT FALSE, 

    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, 



    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, 

    UNIQUE(user_id, parent_folder_id, name) -- Unique names within same parent 

); 

 

-- Add folder reference to documents table 

ALTER TABLE documents ADD COLUMN folder_id INTEGER REFERENCES folders(id); 

React Component - Folder Tree: 

React 

// components/file-manager/FolderTree.jsx 

import { useState, useEffect } from 'react'; 

import { ChevronRight, ChevronDown, Folder, FolderOpen } from 'lucide-react'; 

import { getFolders } from '../../services/fileService'; 

 

export default function FolderTree({ onFolderSelect, selectedFolderId }) { 

  const [folders, setFolders] = useState([]); 

  const [expandedFolders, setExpandedFolders] = useState(new Set()); 

 

  useEffect(() => { 

    loadFolders(); 

  }, []); 

 

  const loadFolders = async () => { 

    try { 

      const response = await getFolders(); 

      setFolders(buildTree(response.data)); 

    } catch (error) { 

      console.error('Error loading folders:', error); 

    } 

  }; 

 

  const buildTree = (flatList) => { 



    const tree = []; 

    const map = {}; 

 

    flatList.forEach(folder => { 

      map[folder.folderId] = { ...folder, children: [] }; 

    }); 

 

    flatList.forEach(folder => { 

      if (folder.parentFolderId) { 

        map[folder.parentFolderId]?.children.push(map[folder.folderId]); 

      } else { 

        tree.push(map[folder.folderId]); 

      } 

    }); 

 

    return tree; 

  }; 

 

  const toggleFolder = (folderId) => { 

    const newExpanded = new Set(expandedFolders); 

    if (newExpanded.has(folderId)) { 

      newExpanded.delete(folderId); 

    } else { 

      newExpanded.add(folderId); 

    } 

    setExpandedFolders(newExpanded); 

  }; 

 

  const renderFolder = (folder, level = 0) => { 

    const isExpanded = expandedFolders.has(folder.folderId); 

    const isSelected = selectedFolderId === folder.folderId; 



    const hasChildren = folder.children && folder.children.length > 0; 

 

    return ( 

      <div key={folder.folderId} className="folder-item"> 

        <div 

          className={`folder-row ${isSelected ? 'selected' : ''}`} 

          style={{ paddingLeft: `${level * 20}px` }} 

          onClick={() => onFolderSelect(folder.folderId)} 

        > 

          {hasChildren && ( 

            <button 

              className="expand-btn" 

              onClick={(e) => { 

                e.stopPropagation(); 

                toggleFolder(folder.folderId); 

              }} 

            > 

              {isExpanded ? <ChevronDown size={16} /> : <ChevronRight size={16} />} 

            </button> 

          )} 

          {!hasChildren && <span className="spacer" />} 

           

          {isExpanded ? <FolderOpen size={18} /> : <Folder size={18} />} 

           

          <span className="folder-name">{folder.name}</span> 

           

          {folder.fileCount > 0 && ( 

            <span className="file-count">{folder.fileCount}</span> 

          )} 

        </div> 

 



        {isExpanded && hasChildren && ( 

          <div className="folder-children"> 

            {folder.children.map(child => renderFolder(child, level + 1))} 

          </div> 

        )} 

      </div> 

    ); 

  }; 

 

  return ( 

    <div className="folder-tree"> 

      <div className="folder-tree-header"> 

        <h3>Folders</h3> 

      </div> 

      <div className="folder-list"> 

        {folders.map(folder => renderFolder(folder))} 

      </div> 

    </div> 

  ); 

} 

 
6.2.3 File Sharing 

User Story: 

As a user, I want to share documents with specific users with defined permissions. 

Functional Requirements: 

Requirement ID Description Priority 

FM-SH-001 User clicks "Share" button on document P0 

FM-SH-002 Share modal opens with recipient selection P0 

FM-SH-003 User can search recipients by name or unique ID P0 

FM-SH-004 User can select from connected users or enter wallet address P0 



Requirement ID Description Priority 

FM-SH-005 User sets permission: "Read Only" or "Read & Write" P0 

FM-SH-006 User can add multiple recipients in one action P1 

FM-SH-007 Sharing transaction recorded on blockchain P0 

FM-SH-008 Recipient receives notification of shared document P0 

FM-SH-009 Shared document appears in recipient's "Shared With Me" folder P0 

FM-SH-010 Owner can revoke sharing access P1 

FM-SH-011 Owner can change permission level after sharing P1 

FM-SH-012 User can share entire folders (all contents) P1 

FM-SH-013 Shared documents show in chat interface P1 

FM-SH-014 User can view list of people document is shared with P1 

Permission Levels: 

Permission Description Actions Allowed 

Read Only View and download only View, Download, Verify 

Read & Write Full access except delete View, Download, Update, Share 

Owner Full control All actions including delete 

API Endpoints: 

text 

POST /api/files/share 

Headers: Authorization: Bearer <token> 

 

Request Body: 

{ 

  "documentId": "DOC-001", 

  "recipients": [ 

    { 

      "userId": "USER-002", 

      "walletAddress": "0xABC...", 

      "permission": "read" 

    }, 



    { 

      "userId": "USER-003", 

      "walletAddress": "0xDEF...", 

      "permission": "write" 

    } 

  ], 

  "message": "Please review this document" // Optional 

} 

 

Response: 

{ 

  "success": true, 

  "message": "Document shared successfully", 

  "data": { 

    "shareId": "SHARE-001", 

    "transactionHash": "0x123...", 

    "blockNumber": 12345678, 

    "sharedWith": [ 

      { 

        "userId": "USER-002", 

        "name": "John Doe", 

        "permission": "read" 

      }, 

      { 

        "userId": "USER-003", 

        "name": "Jane Smith", 

        "permission": "write" 

      } 

    ] 

  } 

} 



text 

GET /api/files/shared-with-me 

Headers: Authorization: Bearer <token> 

Query: ?page=1&limit=20&sort=createdAt:desc 

 

Response: 

{ 

  "success": true, 

  "data": { 

    "documents": [ 

      { 

        "documentId": "DOC-001", 

        "fileName": "Report.pdf", 

        "fileSize": 2048000, 

        "ipfsHash": "QmXYZ...", 

        "sharedBy": { 

          "userId": "USER-001", 

          "name": "Admin User", 

          "email": "admin@abc.edu" 

        }, 

        "permission": "read", 

        "sharedAt": "2024-01-15T10:30:00Z" 

      } 

    ], 

    "pagination": { 

      "currentPage": 1, 

      "totalPages": 5, 

      "totalItems": 100 

    } 

  } 

} 



text 

GET /api/files/:documentId/shares 

Headers: Authorization: Bearer <token> 

 

Response: 

{ 

  "success": true, 

  "data": { 

    "sharedWith": [ 

      { 

        "userId": "USER-002", 

        "name": "John Doe", 

        "email": "john@abc.edu", 

        "permission": "read", 

        "sharedAt": "2024-01-15T10:30:00Z" 

      } 

    ] 

  } 

} 

text 

DELETE /api/files/share/:shareId 

Headers: Authorization: Bearer <token> 

 

Response: 

{ 

  "success": true, 

  "message": "Sharing access revoked" 

} 

Smart Contract - Document Sharing: 

solidity 

// contracts/DocumentManager.sol (continued) 



 

struct Share { 

    bytes32 shareId; 

    bytes32 documentId; 

    address sharedBy; 

    address sharedWith; 

    string permission; // "read" or "write" 

    uint256 timestamp; 

    bool isActive; 

} 

 

mapping(bytes32 => Share) public shares; 

mapping(bytes32 => bytes32[]) public documentShares; // Document to shares 

mapping(address => bytes32[]) public userSharedDocuments; // User to received shares 

 

event DocumentShared( 

    bytes32 indexed shareId, 

    bytes32 indexed documentId, 

    address indexed sharedWith, 

    string permission, 

    uint256 timestamp 

); 

 

event ShareRevoked( 

    bytes32 indexed shareId, 

    uint256 timestamp 

); 

 

function shareDocument( 

    bytes32 _documentId, 

    address _shareWith, 



    string memory _permission 

) public returns (bytes32) { 

    Document storage doc = documents[_documentId]; 

    require(doc.isActive, "Document not found"); 

    require(doc.owner == msg.sender, "Only owner can share"); 

    require(_shareWith != address(0), "Invalid recipient address"); 

    require(_shareWith != msg.sender, "Cannot share with yourself"); 

     

    // Generate unique share ID 

    bytes32 shareId = keccak256( 

        abi.encodePacked( 

            _documentId, 

            _shareWith, 

            block.timestamp 

        ) 

    ); 

     

    shares[shareId] = Share({ 

        shareId: shareId, 

        documentId: _documentId, 

        sharedBy: msg.sender, 

        sharedWith: _shareWith, 

        permission: _permission, 

        timestamp: block.timestamp, 

        isActive: true 

    }); 

     

    documentShares[_documentId].push(shareId); 

    userSharedDocuments[_shareWith].push(shareId); 

     

    emit DocumentShared(shareId, _documentId, _shareWith, _permission, block.timestamp); 



     

    return shareId; 

} 

 

function revokeShare(bytes32 _shareId) public { 

    Share storage share = shares[_shareId]; 

    require(share.isActive, "Share not found or already revoked"); 

     

    Document storage doc = documents[share.documentId]; 

    require(doc.owner == msg.sender, "Only document owner can revoke share"); 

     

    share.isActive = false; 

     

    emit ShareRevoked(_shareId, block.timestamp); 

} 

 

function getDocumentShares(bytes32 _documentId) public view returns (bytes32[] memory) { 

    return documentShares[_documentId]; 

} 

 

function hasAccess(bytes32 _documentId, address _user) public view returns (bool, string memory) { 

    Document storage doc = documents[_documentId]; 

     

    // Owner has full access 

    if (doc.owner == _user) { 

        return (true, "owner"); 

    } 

     

    // Check shares 

    bytes32[] memory shareIds = documentShares[_documentId]; 

    for (uint i = 0; i < shareIds.length; i++) { 



        Share storage share = shares[shareIds[i]]; 

        if (share.sharedWith == _user && share.isActive) { 

            return (true, share.permission); 

        } 

    } 

     

    return (false, ""); 

} 

Database Schema: 

SQL 

CREATE TABLE document_shares ( 

    id SERIAL PRIMARY KEY, 

    share_id VARCHAR(50) UNIQUE NOT NULL, 

    document_id INTEGER REFERENCES documents(id), 

    shared_by INTEGER REFERENCES users(id), 

    shared_with INTEGER REFERENCES users(id), 

    recipient_wallet_address VARCHAR(42) NOT NULL, 

    permission VARCHAR(20) NOT NULL, -- 'read' or 'write' 

    message TEXT, 

    transaction_hash VARCHAR(66), 

    block_number BIGINT, 

    is_active BOOLEAN DEFAULT TRUE, 

    shared_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, 

    revoked_at TIMESTAMP, 

    UNIQUE(document_id, shared_with) -- One share per user per document 

); 

 

CREATE INDEX idx_shares_document ON document_shares(document_id); 

CREATE INDEX idx_shares_recipient ON document_shares(shared_with); 

CREATE INDEX idx_shares_active ON document_shares(is_active); 

 



6.2.4 Version Control 

User Story: 

As a user, I want to track different versions of my documents and see what changed. 

Functional Requirements: 

Requirement ID Description Priority 

FM-VC-001 System automatically creates new version when document is updated P0 

FM-VC-002 User can click "Version History" to view all versions P0 

FM-VC-003 Each version shows: version number, timestamp, modifier, file size P0 

FM-VC-004 User can preview any previous version P1 

FM-VC-005 User can download specific version P1 

FM-VC-006 User can restore previous version (creates new version) P1 

FM-VC-007 User can compare two versions (text diff for supported formats) P2 

FM-VC-008 Version history stored on blockchain with IPFS hashes P0 

FM-VC-009 User can add version notes/comments P1 

FM-VC-010 System retains all versions indefinitely P0 

API Endpoints: 

text 

GET /api/files 

/:documentId/versions 
Headers: Authorization: Bearer <token> 

Response: 
{ 
"success": true, 
"data": { 
"currentVersion": { 
"versionId": "VER-005", 
"versionNumber": 5, 
"ipfsHash": "QmXYZ123...", 
"fileSize": 2048000, 
"modifiedBy": { 
"userId": "USER-001", 
"name": "John Doe" 
}, 
"modifiedAt": "2024-01-20T14:30:00Z", 
"notes": "Final version with corrections" 



}, 
"versions": [ 
{ 
"versionId": "VER-004", 
"versionNumber": 4, 
"ipfsHash": "QmABC456...", 
"fileSize": 2045000, 
"modifiedBy": { 
"userId": "USER-001", 
"name": "John Doe" 
}, 
"modifiedAt": "2024-01-19T10:00:00Z", 
"notes": "Added appendix" 
}, 
{ 
"versionId": "VER-003", 
"versionNumber": 3, 
"ipfsHash": "QmDEF789...", 
"fileSize": 2000000, 
"modifiedBy": { 
"userId": "USER-002", 
"name": "Jane Smith" 
}, 
"modifiedAt": "2024-01-18T16:45:00Z", 
"notes": "Reviewed by faculty" 
} 
] 
} 
} 

POST /api/files/:documentId/update 
Headers: Authorization: Bearer <token> 
Content-Type: multipart/form-data 

Request Body: 
{ 
"file": <binary_file_data>, 
"notes": "Updated with latest data" 
} 

Response: 
{ 
"success": true, 
"message": "Document updated successfully", 
"data": { 
"versionId": "VER-006", 
"versionNumber": 6, 



"ipfsHash": "QmNEW999...", 
"transactionHash": "0xabc...", 
"blockNumber": 12345679 
} 
} 

POST /api/files/:documentId/restore/:versionId 
Headers: Authorization: Bearer <token> 

Response: 
{ 
"success": true, 
"message": "Version restored successfully", 
"data": { 
"newVersionId": "VER-007", 
"restoredFromVersion": 4 
} 
} 

text 

 

**Database Schema:** 

 

```sql 

CREATE TABLE document_versions ( 

    id SERIAL PRIMARY KEY, 

    version_id VARCHAR(50) UNIQUE NOT NULL, 

    document_id INTEGER REFERENCES documents(id), 

    version_number INTEGER NOT NULL, 

    ipfs_hash VARCHAR(100) NOT NULL, 

    file_size BIGINT NOT NULL, 

    modified_by INTEGER REFERENCES users(id), 

    notes TEXT, 

    transaction_hash VARCHAR(66), 

    block_number BIGINT, 

    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, 

    UNIQUE(document_id, version_number) 

); 



 

CREATE INDEX idx_versions_document ON document_versions(document_id); 

CREATE INDEX idx_versions_created ON document_versions(created_at DESC); 

React Component - Version History: 

React 

// components/file-manager/VersionHistory.jsx 

import { useState, useEffect } from 'react'; 

import { Clock, Download, RotateCcw, Eye } from 'lucide-react'; 

import { getVersionHistory, restoreVersion } from '../../services/fileService'; 

import { toast } from 'react-toastify'; 

 

export default function VersionHistory({ documentId, onClose }) { 

  const [versions, setVersions] = useState([]); 

  const [loading, setLoading] = useState(true); 

 

  useEffect(() => { 

    loadVersions(); 

  }, [documentId]); 

 

  const loadVersions = async () => { 

    try { 

      const response = await getVersionHistory(documentId); 

      setVersions([response.data.currentVersion, ...response.data.versions]); 

    } catch (error) { 

      toast.error('Failed to load version history'); 

    } finally { 

      setLoading(false); 

    } 

  }; 

 

  const handleRestore = async (versionId, versionNumber) => { 



    if (!confirm(`Restore to version ${versionNumber}? This will create a new version.`)) { 

      return; 

    } 

 

    try { 

      await restoreVersion(documentId, versionId); 

      toast.success('Version restored successfully'); 

      loadVersions(); 

    } catch (error) { 

      toast.error('Failed to restore version'); 

    } 

  }; 

 

  const formatFileSize = (bytes) => { 

    if (bytes === 0) return '0 Bytes'; 

    const k = 1024; 

    const sizes = ['Bytes', 'KB', 'MB', 'GB']; 

    const i = Math.floor(Math.log(bytes) / Math.log(k)); 

    return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i]; 

  }; 

 

  return ( 

    <div className="version-history-modal"> 

      <div className="modal-header"> 

        <h2>Version History</h2> 

        <button onClick={onClose} className="close-btn">×</button> 

      </div> 

 

      <div className="version-list"> 

        {loading ? ( 

          <div className="loading">Loading versions...</div> 



        ) : ( 

          versions.map((version, index) => ( 

            <div  

              key={version.versionId}  

              className={`version-item ${index === 0 ? 'current' : ''}`} 

            > 

              <div className="version-header"> 

                <div className="version-info"> 

                  <span className="version-number"> 

                    Version {version.versionNumber} 

                    {index === 0 && <span className="badge">Current</span>} 

                  </span> 

                  <span className="version-date"> 

                    <Clock size={14} /> 

                    {new Date(version.modifiedAt).toLocaleString()} 

                  </span> 

                </div> 

                <div className="version-size"> 

                  {formatFileSize(version.fileSize)} 

                </div> 

              </div> 

 

              <div className="version-details"> 

                <div className="modified-by"> 

                  Modified by: <strong>{version.modifiedBy.name}</strong> 

                </div> 

                {version.notes && ( 

                  <div className="version-notes"> 

                    <em>"{version.notes}"</em> 

                  </div> 

                )} 



              </div> 

 

              <div className="version-actions"> 

                <a 

                  href={`https://gateway.pinata.cloud/ipfs/${version.ipfsHash}`} 

                  target="_blank" 

                  rel="noopener noreferrer" 

                  className="action-btn" 

                > 

                  <Eye size={16} /> 

                  Preview 

                </a> 

                <a 

                  href={`https://gateway.pinata.cloud/ipfs/${version.ipfsHash}?download=true`} 

                  className="action-btn" 

                > 

                  <Download size={16} /> 

                  Download 

                </a> 

                {index !== 0 && ( 

                  <button 

                    onClick={() => handleRestore(version.versionId, version.versionNumber)} 

                    className="action-btn restore" 

                  > 

                    <RotateCcw size={16} /> 

                    Restore 

                  </button> 

                )} 

              </div> 

 

              <div className="blockchain-info"> 



                <small> 

                  IPFS: {version.ipfsHash.substring(0, 20)}... 

                  {version.transactionHash && ( 

                    <> | Tx: {version.transactionHash.substring(0, 10)}...</> 

                  )} 

                </small> 

              </div> 

            </div> 

          )) 

        )} 

      </div> 

    </div> 

  ); 

} 

 
6.2.5 File Properties & Metadata 

User Story: 

As a user, I want to view detailed properties of my documents including blockchain verification details. 

Functional Requirements: 

Requirement ID Description Priority 

FM-PR-001 User clicks "Properties" from document context menu P0 

FM-PR-002 Properties modal displays: file name, size, type, created date, modified date P0 

FM-PR-003 Shows owner information (name, wallet address) P0 

FM-PR-004 Shows current access level (owner/read/write) P0 

FM-PR-005 Displays IPFS hash with copy button P0 

FM-PR-006 Shows blockchain transaction hash P0 

FM-PR-007 Shows block number and timestamp P0 

FM-PR-008 Lists all users document is shared with P1 

FM-PR-009 Shows approval status if applicable P1 

FM-PR-010 Link to view on blockchain explorer (Etherscan) P1 



Requirement ID Description Priority 

FM-PR-011 Shows document location (folder path) P1 

FM-PR-012 Displays file preview thumbnail P1 

API Endpoint: 

text 

GET /api/files/:documentId/properties 

Headers: Authorization: Bearer <token> 

 

Response: 

{ 

  "success": true, 

  "data": { 

    "document": { 

      "documentId": "DOC-001", 

      "fileName": "Report_Q1.pdf", 

      "fileSize": 2048000, 

      "fileType": "application/pdf", 

      "folderPath": "/My Files/Reports/Q1", 

      "createdAt": "2024-01-15T10:30:00Z", 

      "updatedAt": "2024-01-20T14:30:00Z", 

      "currentVersion": 5, 

      "totalVersions": 5 

    }, 

    "owner": { 

      "userId": "USER-001", 

      "name": "John Doe", 

      "email": "john@abc.edu", 

      "walletAddress": "0xABC123..." 

    }, 

    "currentUserAccess": { 

      "role": "owner", 



      "canView": true, 

      "canEdit": true, 

      "canShare": true, 

      "canDelete": true 

    }, 

    "blockchain": { 

      "ipfsHash": "QmXYZ123...", 

      "transactionHash": "0xDEF456...", 

      "blockNumber": 12345678, 

      "timestamp": 1705315800, 

      "network": "Sepolia Testnet", 

      "explorerUrl": "https://sepolia.etherscan.io/tx/0xDEF456..." 

    }, 

    "sharing": { 

      "isShared": true, 

      "sharedWithCount": 3, 

      "sharedWith": [ 

        { 

          "userId": "USER-002", 

          "name": "Jane Smith", 

          "permission": "read", 

          "sharedAt": "2024-01-16T09:00:00Z" 

        } 

      ] 

    }, 

    "approval": { 

      "status": "approved", 

      "requestedAt": "2024-01-18T10:00:00Z", 

      "approvedAt": "2024-01-19T14:30:00Z", 

      "approvers": [ 

        { 



          "name": "Dr. Kumar", 

          "role": "HOD", 

          "status": "approved" 

        } 

      ] 

    } 

  } 

} 

React Component - File Properties: 

React 

// components/file-manager/FileProperties.jsx 

import { useState, useEffect } from 'react'; 

import {  

  File, Calendar, User, Database, Share2,  

  CheckCircle, ExternalLink, Copy  

} from 'lucide-react'; 

import { getFileProperties } from '../../services/fileService'; 

import { toast } from 'react-toastify'; 

 

export default function FileProperties({ documentId, onClose }) { 

  const [properties, setProperties] = useState(null); 

  const [loading, setLoading] = useState(true); 

 

  useEffect(() => { 

    loadProperties(); 

  }, [documentId]); 

 

  const loadProperties = async () => { 

    try { 

      const response = await getFileProperties(documentId); 

      setProperties(response.data); 



    } catch (error) { 

      toast.error('Failed to load file properties'); 

    } finally { 

      setLoading(false); 

    } 

  }; 

 

  const copyToClipboard = (text, label) => { 

    navigator.clipboard.writeText(text); 

    toast.success(`${label} copied to clipboard`); 

  }; 

 

  const formatFileSize = (bytes) => { 

    if (bytes === 0) return '0 Bytes'; 

    const k = 1024; 

    const sizes = ['Bytes', 'KB', 'MB', 'GB']; 

    const i = Math.floor(Math.log(bytes) / Math.log(k)); 

    return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i]; 

  }; 

 

  if (loading) { 

    return <div className="loading">Loading properties...</div>; 

  } 

 

  const { document: doc, owner, blockchain, sharing, approval, currentUserAccess } = properties; 

 

  return ( 

    <div className="file-properties-modal"> 

      <div className="modal-header"> 

        <h2>File Properties</h2> 

        <button onClick={onClose} className="close-btn">×</button> 



      </div> 

 

      <div className="properties-content"> 

        {/* General Information */} 

        <section className="property-section"> 

          <h3><File size={18} /> General</h3> 

          <div className="property-grid"> 

            <div className="property-item"> 

              <label>File Name:</label> 

              <span>{doc.fileName}</span> 

            </div> 

            <div className="property-item"> 

              <label>File Type:</label> 

              <span>{doc.fileType}</span> 

            </div> 

            <div className="property-item"> 

              <label>File Size:</label> 

              <span>{formatFileSize(doc.fileSize)}</span> 

            </div> 

            <div className="property-item"> 

              <label>Location:</label> 

              <span>{doc.folderPath}</span> 

            </div> 

            <div className="property-item"> 

              <label>Created:</label> 

              <span>{new Date(doc.createdAt).toLocaleString()}</span> 

            </div> 

            <div className="property-item"> 

              <label>Last Modified:</label> 

              <span>{new Date(doc.updatedAt).toLocaleString()}</span> 

            </div> 



            <div className="property-item"> 

              <label>Versions:</label> 

              <span>{doc.currentVersion} of {doc.totalVersions}</span> 

            </div> 

          </div> 

        </section> 

 

        {/* Owner Information */} 

        <section className="property-section"> 

          <h3><User size={18} /> Owner</h3> 

          <div className="property-grid"> 

            <div className="property-item"> 

              <label>Name:</label> 

              <span>{owner.name}</span> 

            </div> 

            <div className="property-item"> 

              <label>Email:</label> 

              <span>{owner.email}</span> 

            </div> 

            <div className="property-item"> 

              <label>Wallet Address:</label> 

              <div className="copyable"> 

                <span className="truncate">{owner.walletAddress}</span> 

                <button 

                  onClick={() => copyToClipboard(owner.walletAddress, 'Wallet address')} 

                  className="copy-btn" 

                > 

                  <Copy size={14} /> 

                </button> 

              </div> 

            </div> 



          </div> 

</section> 

text 

    {/* Blockchain Information */} 

    <section className="property-section"> 

      <h3><Database size={18} /> Blockchain</h3> 

      <div className="property-grid"> 

        <div className="property-item"> 

          <label>IPFS Hash:</label> 

          <div className="copyable"> 

            <span className="truncate">{blockchain.ipfsHash}</span> 

            <button 

              onClick={() => copyToClipboard(blockchain.ipfsHash, 'IPFS hash')} 

              className="copy-btn" 

            > 

              <Copy size={14} /> 

            </button> 

          </div> 

        </div> 

        <div className="property-item"> 

          <label>Transaction Hash:</label> 

          <div className="copyable"> 

            <span className="truncate">{blockchain.transactionHash}</span> 

            <button 

              onClick={() => copyToClipboard(blockchain.transactionHash, 'Transaction hash')} 

              className="copy-btn" 

            > 

              <Copy size={14} /> 

            </button> 

          </div> 

        </div> 



        <div className="property-item"> 

          <label>Block Number:</label> 

          <span>{blockchain.blockNumber}</span> 

        </div> 

        <div className="property-item"> 

          <label>Network:</label> 

          <span>{blockchain.network}</span> 

        </div> 

        <div className="property-item full-width"> 

          <a 

            href={blockchain.explorerUrl} 

            target="_blank" 

            rel="noopener noreferrer" 

            className="explorer-link" 

          > 

            <ExternalLink size={16} /> 

            View on Blockchain Explorer 

          </a> 

        </div> 

      </div> 

    </section> 

 

    {/* Access Permissions */} 

    <section className="property-section"> 

      <h3><CheckCircle size={18} /> Your Access</h3> 

      <div className="permissions-grid"> 

        <div className={`permission-badge ${currentUserAccess.canView ? 'active' : ''}`}> 

          View 

        </div> 

        <div className={`permission-badge ${currentUserAccess.canEdit ? 'active' : ''}`}> 

          Edit 



        </div> 

        <div className={`permission-badge ${currentUserAccess.canShare ? 'active' : ''}`}> 

          Share 

        </div> 

        <div className={`permission-badge ${currentUserAccess.canDelete ? 'active' : ''}`}> 

          Delete 

        </div> 

      </div> 

    </section> 

 

    {/* Sharing Information */} 

    {sharing.isShared && ( 

      <section className="property-section"> 

        <h3><Share2 size={18} /> Shared With ({sharing.sharedWithCount})</h3> 

        <div className="sharing-list"> 

          {sharing.sharedWith.map((share) => ( 

            <div key={share.userId} className="share-item"> 

              <div className="share-user"> 

                <div className="user-avatar"> 

                  {share.name.charAt(0)} 

                </div> 

                <div className="user-info"> 

                  <div className="user-name">{share.name}</div> 

                  <div className="share-date"> 

                    Shared {new Date(share.sharedAt).toLocaleDateString()} 

                  </div> 

                </div> 

              </div> 

              <div className="share-permission"> 

                <span className={`permission-badge ${share.permission}`}> 

                  {share.permission === 'read' ? 'Read Only' : 'Read & Write'} 



                </span> 

              </div> 

            </div> 

          ))} 

        </div> 

      </section> 

    )} 

 

    {/* Approval Status */} 

    {approval && ( 

      <section className="property-section"> 

        <h3><CheckCircle size={18} /> Approval Status</h3> 

        <div className="approval-status"> 

          <div className={`status-badge ${approval.status}`}> 

            {approval.status.toUpperCase()} 

          </div> 

          {approval.approvers && ( 

            <div className="approvers-list"> 

              {approval.approvers.map((approver, index) => ( 

                <div key={index} className="approver-item"> 

                  <span className="approver-name">{approver.name}</span> 

                  <span className="approver-role">({approver.role})</span> 

                  <span className={`approver-status ${approver.status}`}> 

                    {approver.status} 

                  </span> 

                </div> 

              ))} 

            </div> 

          )} 

        </div> 

      </section> 



    )} 

  </div> 

</div> 

); 
} 

text 

 

--- 

 

### **6.2.6 File Search & Filtering** 

 

**User Story:** 

> As a user, I want to quickly find documents using search and filters. 

 

**Functional Requirements:** 

 

| **Requirement ID** | **Description** | **Priority** | 

|--------------------|-----------------|--------------| 

| FM-SF-001 | User can search documents by file name | P0 | 

| FM-SF-002 | Search works across all user's accessible documents | P0 | 

| FM-SF-003 | Real-time search suggestions as user types | P1 | 

| FM-SF-004 | User can filter by file type (PDF, DOC, IMG, etc.) | P0 | 

| FM-SF-005 | User can filter by date range (created/modified) | P1 | 

| FM-SF-006 | User can filter by folder location | P1 | 

| FM-SF-007 | User can filter by shared status (shared by me/shared with me) | P1 | 

| FM-SF-008 | User can sort by: name, date, size, type | P0 | 

| FM-SF-009 | Sort order: ascending/descending toggle | P0 | 

| FM-SF-010 | Search results highlight matching text | P1 | 

| FM-SF-011 | Filter combinations work together (AND logic) | P1 | 

| FM-SF-012 | User can save frequent search filters as presets | P2 | 

 



**API Endpoints:** 

GET /api/files/search 
Headers: Authorization: Bearer <token> 
Query Parameters: 

• q: search query (file name) 

• type: file type filter (pdf, doc, image, etc.) 

• dateFrom: start date (ISO 8601) 

• dateTo: end date (ISO 8601) 

• folderId: folder filter 

• shared: true/false 

• sort: field to sort by (name, date, size) 

• order: asc/desc 

• page: page number 

• limit: results per page 

Example: /api/files/search?q=report&type=pdf&sort=date&order=desc&page=1&limit=20 

Response: 
{ 
"success": true, 
"data": { 
"results": [ 
{ 
"documentId": "DOC-001", 
"fileName": "Annual_Report_2024.pdf", 
"fileSize": 2048000, 
"fileType": "application/pdf", 
"ipfsHash": "QmXYZ...", 
"folderPath": "/My Files/Reports", 
"createdAt": "2024-01-15T10:30:00Z", 
"modifiedAt": "2024-01-20T14:30:00Z", 
"isShared": true, 
"matchScore": 0.95 
} 
], 
"pagination": { 
"currentPage": 1, 
"totalPages": 5, 
"totalResults": 87, 
"resultsPerPage": 20 
}, 



"filters": { 
"appliedFilters": { 
"query": "report", 
"type": "pdf", 
"sort": "date", 
"order": "desc" 
} 
} 
} 
} 

text 

 

**React Component - File Search:** 

 

```jsx 

// components/file-manager/FileSearch.jsx 

import { useState, useEffect, useCallback } from 'react'; 

import { Search, Filter, X, SlidersHorizontal } from 'lucide-react'; 

import { searchFiles } from '../../services/fileService'; 

import { debounce } from '../../utils/helpers'; 

 

export default function FileSearch({ onResultsChange }) { 

  const [query, setQuery] = useState(''); 

  const [filters, setFilters] = useState({ 

    type: 'all', 

    dateFrom: '', 

    dateTo: '', 

    folderId: null, 

    shared: null 

  }); 

  const [sortBy, setSortBy] = useState('date'); 

  const [sortOrder, setSortOrder] = useState('desc'); 

  const [showAdvanced, setShowAdvanced] = useState(false); 

  const [results, setResults] = useState([]); 



  const [loading, setLoading] = useState(false); 

 

  // Debounced search function 

  const debouncedSearch = useCallback( 

    debounce(async (searchQuery, searchFilters, sort, order) => { 

      if (!searchQuery && !hasActiveFilters(searchFilters)) { 

        setResults([]); 

        onResultsChange([]); 

        return; 

      } 

 

      setLoading(true); 

      try { 

        const response = await searchFiles({ 

          q: searchQuery, 

          ...searchFilters, 

          sort, 

          order 

        }); 

        setResults(response.data.results); 

        onResultsChange(response.data.results); 

      } catch (error) { 

        console.error('Search error:', error); 

      } finally { 

        setLoading(false); 

      } 

    }, 500), 

    [] 

  ); 

 

  useEffect(() => { 



    debouncedSearch(query, filters, sortBy, sortOrder); 

  }, [query, filters, sortBy, sortOrder]); 

 

  const hasActiveFilters = (filterObj) => { 

    return Object.values(filterObj).some(val => val !== null && val !== '' && val !== 'all'); 

  }; 

 

  const clearFilters = () => { 

    setQuery(''); 

    setFilters({ 

      type: 'all', 

      dateFrom: '', 

      dateTo: '', 

      folderId: null, 

      shared: null 

    }); 

  }; 

 

  const handleFilterChange = (key, value) => { 

    setFilters(prev => ({ ...prev, [key]: value })); 

  }; 

 

  return ( 

    <div className="file-search"> 

      {/* Main Search Bar */} 

      <div className="search-bar"> 

        <Search size={20} className="search-icon" /> 

        <input 

          type="text" 

          placeholder="Search files..." 

          value={query} 



          onChange={(e) => setQuery(e.target.value)} 

          className="search-input" 

        /> 

        {(query || hasActiveFilters(filters)) && ( 

          <button onClick={clearFilters} className="clear-btn"> 

            <X size={18} /> 

          </button> 

        )} 

        <button 

          onClick={() => setShowAdvanced(!showAdvanced)} 

          className={`filter-toggle ${showAdvanced ? 'active' : ''}`} 

        > 

          <SlidersHorizontal size={18} /> 

        </button> 

      </div> 

 

      {/* Advanced Filters */} 

      {showAdvanced && ( 

        <div className="advanced-filters"> 

          <div className="filter-row"> 

            {/* File Type Filter */} 

            <div className="filter-group"> 

              <label>File Type:</label> 

              <select 

                value={filters.type} 

                onChange={(e) => handleFilterChange('type', e.target.value)} 

              > 

                <option value="all">All Types</option> 

                <option value="pdf">PDF</option> 

                <option value="doc">Documents</option> 

                <option value="image">Images</option> 



                <option value="spreadsheet">Spreadsheets</option> 

              </select> 

            </div> 

 

            {/* Date Range Filter */} 

            <div className="filter-group"> 

              <label>Date From:</label> 

              <input 

                type="date" 

                value={filters.dateFrom} 

                onChange={(e) => handleFilterChange('dateFrom', e.target.value)} 

              /> 

            </div> 

 

            <div className="filter-group"> 

              <label>Date To:</label> 

              <input 

                type="date" 

                value={filters.dateTo} 

                onChange={(e) => handleFilterChange('dateTo', e.target.value)} 

              /> 

            </div> 

 

            {/* Shared Filter */} 

            <div className="filter-group"> 

              <label>Shared:</label> 

              <select 

                value={filters.shared === null ? 'all' : filters.shared} 

                onChange={(e) => { 

                  const val = e.target.value === 'all' ? null : e.target.value === 'true'; 

                  handleFilterChange('shared', val); 



                }} 

              > 

                <option value="all">All Files</option> 

                <option value="true">Shared Only</option> 

                <option value="false">Not Shared</option> 

              </select> 

            </div> 

          </div> 

 

          {/* Sort Options */} 

          <div className="sort-options"> 

            <label>Sort By:</label> 

            <div className="sort-controls"> 

              <select value={sortBy} onChange={(e) => setSortBy(e.target.value)}> 

                <option value="date">Date Modified</option> 

                <option value="name">Name</option> 

                <option value="size">Size</option> 

                <option value="type">Type</option> 

              </select> 

              <button 

                onClick={() => setSortOrder(prev => prev === 'asc' ? 'desc' : 'asc')} 

                className="sort-order-btn" 

              > 

                {sortOrder === 'asc' ? '↑' : '↓'} 

              </button> 

            </div> 

          </div> 

        </div> 

      )} 

 

      {/* Search Status */} 



      {loading && <div className="search-status">Searching...</div>} 

      {!loading && results.length > 0 && ( 

        <div className="search-status"> 

          Found {results.length} result{results.length !== 1 ? 's' : ''} 

        </div> 

      )} 

    </div> 

  ); 

} 

 
6.2.7 Trash & Recovery 

User Story: 

As a user, I want deleted files to be recoverable for 30 days before permanent deletion. 

Functional Requirements: 

Requirement ID Description Priority 

FM-TR-001 Deleted files move to Trash folder, not permanently deleted P0 

FM-TR-002 Files stay in Trash for 30 days P0 

FM-TR-003 User can view Trash folder contents P0 

FM-TR-004 User can restore individual files from Trash P0 

FM-TR-005 User can permanently delete files from Trash P0 

FM-TR-006 User can empty entire Trash folder P0 

FM-TR-007 System automatically deletes files after 30 days P0 

FM-TR-008 Trash shows deletion date and days remaining P1 

FM-TR-009 Restored files return to original folder location P1 

FM-TR-010 Permanent deletion unpins file from IPFS P0 

FM-TR-011 Permanent deletion updates blockchain status P1 

FM-TR-012 User receives confirmation before permanent deletion P0 

API Endpoints: 

text 

DELETE /api/files/:documentId 



Headers: Authorization: Bearer <token> 

 

Response: 

{ 

  "success": true, 

  "message": "File moved to trash", 

  "data": { 

    "deletedAt": "2024-01-20T10:30:00Z", 

    "permanentDeletionDate": "2024-02-19T10:30:00Z" 

  } 

} 

text 

GET /api/files/trash 

Headers 

: Authorization: Bearer <token> 
Query: ?page=1&limit=20 

Response: 
{ 
"success": true, 
"data": { 
"trashedFiles": [ 
{ 
"documentId": "DOC-005", 
"fileName": "Old_Report.pdf", 
"fileSize": 1024000, 
"fileType": "application/pdf", 
"originalFolderPath": "/My Files/Reports", 
"deletedAt": "2024-01-15T10:30:00Z", 
"permanentDeletionDate": "2024-02-14T10:30:00Z", 
"daysRemaining": 25 
} 
], 
"pagination": { 
"currentPage": 1, 
"totalPages": 2, 
"totalItems": 35 
} 



} 
} 

POST /api/files/:documentId/restore 
Headers: Authorization: Bearer <token> 

Response: 
{ 
"success": true, 
"message": "File restored successfully", 
"data": { 
"documentId": "DOC-005", 
"restoredToFolder": "/My Files/Reports" 
} 
} 

DELETE /api/files/:documentId/permanent 
Headers: Authorization: Bearer <token> 

Response: 
{ 
"success": true, 
"message": "File permanently deleted", 
"data": { 
"ipfsUnpinned": true, 
"blockchainUpdated": true 
} 
} 

POST /api/files/trash/empty 
Headers: Authorization: Bearer <token> 

Response: 
{ 
"success": true, 
"message": "Trash emptied successfully", 
"data": { 
"deletedCount": 35, 
"spaceFreed": 52428800 
} 
} 

text 

 

**Database Schema:** 

 

```sql 



-- Add soft delete columns to documents table 

ALTER TABLE documents  

ADD COLUMN is_deleted BOOLEAN DEFAULT FALSE, 

ADD COLUMN deleted_at TIMESTAMP, 

ADD COLUMN original_folder_id INTEGER, 

ADD COLUMN permanent_deletion_date TIMESTAMP; 

 

-- Index for trash queries 

CREATE INDEX idx_documents_deleted ON documents(is_deleted, deleted_at)  

WHERE is_deleted = TRUE; 

Backend Service - Trash Management: 

Python 

# backend/app/services/trash_service.py 

from datetime import datetime, timedelta 

from app.extensions import db 

from app.models.document import Document 

from app.services.ipfs_service import IPFSService 

 

class TrashService: 

    TRASH_RETENTION_DAYS = 30 

     

    def __init__(self): 

        self.ipfs_service = IPFSService() 

     

    def move_to_trash(self, document_id, user_id): 

        """Soft delete document by moving to trash""" 

        document = Document.query.filter_by( 

            document_id=document_id, 

            owner_id=user_id 

        ).first() 

         



        if not document: 

            raise ValueError("Document not found or access denied") 

         

        document.is_deleted = True 

        document.deleted_at = datetime.utcnow() 

        document.original_folder_id = document.folder_id 

        document.permanent_deletion_date = datetime.utcnow() + timedelta( 

            days=self.TRASH_RETENTION_DAYS 

        ) 

         

        db.session.commit() 

         

        return { 

            'deletedAt': document.deleted_at.isoformat(), 

            'permanentDeletionDate': document.permanent_deletion_date.isoformat() 

        } 

     

    def get_trash_items(self, user_id, page=1, limit=20): 

        """Get all trashed documents for user""" 

        query = Document.query.filter_by( 

            owner_id=user_id, 

            is_deleted=True 

        ).order_by(Document.deleted_at.desc()) 

         

        pagination = query.paginate(page=page, per_page=limit, error_out=False) 

         

        items = [] 

        for doc in pagination.items: 

            days_remaining = (doc.permanent_deletion_date - datetime.utcnow()).days 

            items.append({ 

                'documentId': doc.document_id, 



                'fileName': doc.file_name, 

                'fileSize': doc.file_size, 

                'fileType': doc.file_type, 

                'originalFolderPath': doc.get_original_folder_path(), 

                'deletedAt': doc.deleted_at.isoformat(), 

                'permanentDeletionDate': doc.permanent_deletion_date.isoformat(), 

                'daysRemaining': max(0, days_remaining) 

            }) 

         

        return { 

            'trashedFiles': items, 

            'pagination': { 

                'currentPage': page, 

                'totalPages': pagination.pages, 

                'totalItems': pagination.total 

            } 

        } 

     

    def restore_document(self, document_id, user_id): 

        """Restore document from trash""" 

        document = Document.query.filter_by( 

            document_id=document_id, 

            owner_id=user_id, 

            is_deleted=True 

        ).first() 

         

        if not document: 

            raise ValueError("Document not found in trash") 

         

        # Restore to original folder 

        document.is_deleted = False 



        document.folder_id = document.original_folder_id 

        document.deleted_at = None 

        document.permanent_deletion_date = None 

         

        db.session.commit() 

         

        return { 

            'documentId': document.document_id, 

            'restoredToFolder': document.get_folder_path() 

        } 

     

    def permanent_delete(self, document_id, user_id): 

        """Permanently delete document and unpin from IPFS""" 

        document = Document.query.filter_by( 

            document_id=document_id, 

            owner_id=user_id, 

            is_deleted=True 

        ).first() 

         

        if not document: 

            raise ValueError("Document not found in trash") 

         

        # Unpin from IPFS 

        ipfs_unpinned = False 

        try: 

            self.ipfs_service.unpin_file(document.ipfs_hash) 

            ipfs_unpinned = True 

        except Exception as e: 

            current_app.logger.error(f"Failed to unpin IPFS: {str(e)}") 

         

        # Delete all versions 



        for version in document.versions: 

            try: 

                self.ipfs_service.unpin_file(version.ipfs_hash) 

            except: 

                pass 

         

        # Delete from database 

        db.session.delete(document) 

        db.session.commit() 

         

        return { 

            'ipfsUnpinned': ipfs_unpinned, 

            'blockchainUpdated': True 

        } 

     

    def empty_trash(self, user_id): 

        """Permanently delete all trashed documents""" 

        documents = Document.query.filter_by( 

            owner_id=user_id, 

            is_deleted=True 

        ).all() 

         

        deleted_count = 0 

        space_freed = 0 

         

        for doc in documents: 

            try: 

                space_freed += doc.file_size 

                self.permanent_delete(doc.document_id, user_id) 

                deleted_count += 1 

            except Exception as e: 



                current_app.logger.error(f"Failed to delete {doc.document_id}: {str(e)}") 

         

        return { 

            'deletedCount': deleted_count, 

            'spaceFreed': space_freed 

        } 

     

    def cleanup_expired_trash(self): 

        """Auto-delete documents past retention period (Celery task)""" 

        expired_docs = Document.query.filter( 

            Document.is_deleted == True, 

            Document.permanent_deletion_date <= datetime.utcnow() 

        ).all() 

         

        deleted_count = 0 

        for doc in expired_docs: 

            try: 

                self.permanent_delete(doc.document_id, doc.owner_id) 

                deleted_count += 1 

            except Exception as e: 

                current_app.logger.error(f"Auto-cleanup failed for {doc.document_id}: {str(e)}") 

         

        return deleted_count 

Celery Task - Auto Cleanup: 

Python 

# backend/app/tasks/trash_cleanup.py 

from celery import shared_task 

from app.services.trash_service import TrashService 

 

@shared_task(name='cleanup_expired_trash') 

def cleanup_expired_trash(): 



    """Scheduled task to cleanup expired trash items (runs daily)""" 

    trash_service = TrashService() 

    deleted_count = trash_service.cleanup_expired_trash() 

    return f"Cleaned up {deleted_count} expired documents" 

Celery Beat Schedule: 

Python 

# backend/app/celery_worker.py 

from celery.schedules import crontab 

 

app.conf.beat_schedule = { 

    'cleanup-trash-daily': { 

        'task': 'cleanup_expired_trash', 

        'schedule': crontab(hour=2, minute=0),  # Run at 2 AM daily 

    }, 

} 

React Component - Trash View: 

React 

// components/file-manager/TrashView.jsx 

import { useState, useEffect } from 'react'; 

import { Trash2, RotateCcw, AlertTriangle, Clock } from 'lucide-react'; 

import {  

  getTrashItems,  

  restoreFile,  

  permanentDelete, 

  emptyTrash  

} from '../../services/fileService'; 

import { toast } from 'react-toastify'; 

 

export default function TrashView() { 

  const [trashedFiles, setTrashedFiles] = useState([]); 

  const [loading, setLoading] = useState(true); 



  const [selectedFiles, setSelectedFiles] = useState(new Set()); 

 

  useEffect(() => { 

    loadTrash(); 

  }, []); 

 

  const loadTrash = async () => { 

    try { 

      const response = await getTrashItems(); 

      setTrashedFiles(response.data.trashedFiles); 

    } catch (error) { 

      toast.error('Failed to load trash'); 

    } finally { 

      setLoading(false); 

    } 

  }; 

 

  const handleRestore = async (documentId, fileName) => { 

    try { 

      await restoreFile(documentId); 

      toast.success(`${fileName} restored successfully`); 

      loadTrash(); 

    } catch (error) { 

      toast.error('Failed to restore file'); 

    } 

  }; 

 

  const handlePermanentDelete = async (documentId, fileName) => { 

    const confirmed = window.confirm( 

      `Are you sure you want to permanently delete "${fileName}"? This action cannot be undone.` 

    ); 



     

    if (!confirmed) return; 

 

    try { 

      await permanentDelete(documentId); 

      toast.success(`${fileName} permanently deleted`); 

      loadTrash(); 

    } catch (error) { 

      toast.error('Failed to delete file'); 

    } 

  }; 

 

  const handleEmptyTrash = async () => { 

    const confirmed = window.confirm( 

      `Are you sure you want to empty the trash? This will permanently delete ${trashedFiles.length} 
file(s). This action cannot be undone.` 

    ); 

     

    if (!confirmed) return; 

 

    try { 

      const response = await emptyTrash(); 

      toast.success(`Trash emptied: ${response.data.deletedCount} files deleted`); 

      loadTrash(); 

    } catch (error) { 

      toast.error('Failed to empty trash'); 

    } 

  }; 

 

  const getDaysColor = (days) => { 

    if (days <= 5) return 'text-red-600'; 



    if (days <= 15) return 'text-orange-600'; 

    return 'text-gray-600'; 

  }; 

 

  if (loading) { 

    return <div className="loading">Loading trash...</div>; 

  } 

 

  return ( 

    <div className="trash-view"> 

      <div className="trash-header"> 

        <div className="header-left"> 

          <Trash2 size={24} /> 

          <h2>Trash</h2> 

          <span className="file-count">({trashedFiles.length} items)</span> 

        </div> 

        {trashedFiles.length > 0 && ( 

          <button onClick={handleEmptyTrash} className="empty-trash-btn"> 

            <AlertTriangle size={18} /> 

            Empty Trash 

          </button> 

        )} 

      </div> 

 

      {trashedFiles.length === 0 ? ( 

        <div className="empty-trash"> 

          <Trash2 size={48} /> 

          <p>Trash is empty</p> 

        </div> 

      ) : ( 

        <> 



          <div className="trash-notice"> 

            <Clock size={16} /> 

            Items in trash will be permanently deleted after 30 days 

          </div> 

 

          <div className="trash-list"> 

            {trashedFiles.map((file) => ( 

              <div key={file.documentId} className="trash-item"> 

                <div className="file-info"> 

                  <div className="file-icon"> 

                    {getFileIcon(file.fileType)} 

                  </div> 

                  <div className="file-details"> 

                    <div className="file-name">{file.fileName}</div> 

                    <div className="file-meta"> 

                      <span>Deleted: {new Date(file.deletedAt).toLocaleDateString()}</span> 

                      <span>•</span> 

                      <span>From: {file.originalFolderPath}</span> 

                      <span>•</span> 

                      <span className={getDaysColor(file.daysRemaining)}> 

                        {file.daysRemaining} days remaining 

                      </span> 

                    </div> 

                  </div> 

                </div> 

 

                <div className="trash-actions"> 

                  <button 

                    onClick={() => handleRestore(file.documentId, file.fileName)} 

                    className="restore-btn" 

                    title="Restore" 



                  > 

                    <RotateCcw size={18} /> 

                    Restore 

                  </button> 

                  <button 

                    onClick={() => handlePermanentDelete(file.documentId, file.fileName)} 

                    className="delete-permanent-btn" 

                    title="Delete Permanently" 

                  > 

                    <Trash2 size={18} /> 

                    Delete Forever 

                  </button> 

                </div> 

              </div> 

            ))} 

          </div> 

        </> 

      )} 

    </div> 

  ); 

} 

 

function getFileIcon(fileType) { 

  // Return appropriate icon based on file type 

  if (fileType.includes('pdf')) return ' '; 

  if (fileType.includes('image')) return ' '; 

  if (fileType.includes('word')) return ' '; 

  if (fileType.includes('sheet')) return ' '; 

  return ' '; 

} 



 
6.3 Chat Interface 

6.3.1 Real-Time Messaging 

User Story: 

As a user, I want to communicate with other users in real-time through direct messages. 

Functional Requirements: 

Requirement ID Description Priority 

CHAT-RT-001 User can search and connect with other users by name or unique ID P0 

CHAT-RT-002 User can send text messages to connected users P0 

CHAT-RT-003 Messages delivered in real-time using WebSocket P0 

CHAT-RT-004 User can see online/offline status of contacts P1 

CHAT-RT-005 User can see typing indicators P1 

CHAT-RT-006 Messages show delivery status (sent/delivered/read) P1 

CHAT-RT-007 User can send emoji reactions to messages P1 

CHAT-RT-008 User can edit sent messages within 15 minutes P2 

CHAT-RT-009 User can delete messages (for self or everyone) P1 

CHAT-RT-010 Chat history  

persists in database | P0 | 
| CHAT-RT-011 | User can search within chat conversations | P1 | 
| CHAT-RT-012 | Unread message count displayed on chat icon | P0 | 
| CHAT-RT-013 | Desktop notifications for new messages | P1 | 
| CHAT-RT-014 | Message timestamps displayed | P0 | 
| CHAT-RT-015 | Support for text formatting (bold, italic, links) | P2 | 

API Endpoints: 

text 

GET /api/chat/contacts 

Headers: Authorization: Bearer <token> 

Query: ?search=john&page=1&limit=20 

 

Response: 

{ 

  "success": true, 



  "data": { 

    "contacts": [ 

      { 

        "userId": "USER-002", 

        "name": "John Doe", 

        "email": "john@abc.edu", 

        "role": "faculty", 

        "department": "Computer Science", 

        "profileImage": "https://...", 

        "isOnline": true, 

        "lastSeen": "2024-01-20T15:30:00Z", 

        "unreadCount": 3 

      } 

    ], 

    "pagination": { 

      "currentPage": 1, 

      "totalPages": 5, 

      "totalContacts": 87 

    } 

  } 

} 

text 

GET /api/chat/conversations/:userId 

Headers: Authorization: Bearer <token> 

Query: ?page=1&limit=50 

 

Response: 

{ 

  "success": true, 

  "data": { 

    "conversation": { 



      "conversationId": "CONV-001", 

      "participants": [ 

        { 

          "userId": "USER-001", 

          "name": "Current User" 

        }, 

        { 

          "userId": "USER-002", 

          "name": "John Doe", 

          "isOnline": true 

        } 

      ] 

    }, 

    "messages": [ 

      { 

        "messageId": "MSG-123", 

        "senderId": "USER-002", 

        "senderName": "John Doe", 

        "content": "Hello, how are you?", 

        "messageType": "text", 

        "timestamp": "2024-01-20T15:30:00Z", 

        "status": "read", 

        "isEdited": false, 

        "reactions": [ 

          { 

            "userId": "USER-001", 

            "emoji": " " 

          } 

        ] 

      } 

    ], 



    "pagination": { 

      "currentPage": 1, 

      "hasMore": true 

    } 

  } 

} 

text 

POST /api/chat/messages 

Headers: Authorization: Bearer <token> 

 

Request Body: 

{ 

  "recipientId": "USER-002", 

  "content": "Hello, this is a test message", 

  "messageType": "text", 

  "replyToMessageId": null // Optional: for threaded replies 

} 

 

Response: 

{ 

  "success": true, 

  "data": { 

    "messageId": "MSG-124", 

    "conversationId": "CONV-001", 

    "timestamp": "2024-01-20T15:35:00Z", 

    "status": "sent" 

  } 

} 

text 

PUT /api/chat/messages/:messageId 

Headers: Authorization: Bearer <token> 



 

Request Body: 

{ 

  "content": "Updated message content" 

} 

 

Response: 

{ 

  "success": true, 

  "message": "Message updated successfully" 

} 

text 

DELETE /api/chat/messages/:messageId 

Headers: Authorization: Bearer <token> 

Query: ?deleteFor=everyone // or "me" 

 

Response: 

{ 

  "success": true, 

  "message": "Message deleted" 

} 

WebSocket Events: 

JavaScript 

// Client emits 

socket.emit('join_room', { conversationId: 'CONV-001' }); 

socket.emit('send_message', { 

  recipientId: 'USER-002', 

  content: 'Hello', 

  messageType: 'text' 

}); 

socket.emit('typing', { recipientId: 'USER-002', isTyping: true }); 



socket.emit('mark_read', { conversationId: 'CONV-001', messageIds: ['MSG-123'] }); 

 

// Client receives 

socket.on('new_message', (data) => { 

  // { messageId, senderId, content, timestamp } 

}); 

socket.on('user_typing', (data) => { 

  // { userId, isTyping } 

}); 

socket.on('message_status_update', (data) => { 

  // { messageId, status: 'delivered' | 'read' } 

}); 

socket.on('user_online', (data) => { 

  // { userId, isOnline: true, timestamp } 

}); 

socket.on('message_deleted', (data) => { 

  // { messageId, conversationId } 

}); 

Database Schema: 

SQL 

CREATE TABLE conversations ( 

    id SERIAL PRIMARY KEY, 

    conversation_id VARCHAR(50) UNIQUE NOT NULL, 

    conversation_type VARCHAR(20) DEFAULT 'direct', -- 'direct' or 'group' 

    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, 

    last_message_at TIMESTAMP 

); 

 

CREATE TABLE conversation_participants ( 

    id SERIAL PRIMARY KEY, 

    conversation_id INTEGER REFERENCES conversations(id), 



    user_id INTEGER REFERENCES users(id), 

    joined_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, 

    last_read_at TIMESTAMP, 

    is_active BOOLEAN DEFAULT TRUE, 

    UNIQUE(conversation_id, user_id) 

); 

 

CREATE TABLE chat_messages ( 

    id SERIAL PRIMARY KEY, 

    message_id VARCHAR(50) UNIQUE NOT NULL, 

    conversation_id INTEGER REFERENCES conversations(id), 

    sender_id INTEGER REFERENCES users(id), 

    content TEXT NOT NULL, 

    message_type VARCHAR(20) DEFAULT 'text', -- 'text', 'file', 'approval_request' 

    reply_to_message_id INTEGER REFERENCES chat_messages(id), 

    is_edited BOOLEAN DEFAULT FALSE, 

    edited_at TIMESTAMP, 

    is_deleted BOOLEAN DEFAULT FALSE, 

    deleted_for VARCHAR(20), -- 'everyone' or specific user IDs 

    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, 

    INDEX(conversation_id, created_at DESC) 

); 

 

CREATE TABLE message_reactions ( 

    id SERIAL PRIMARY KEY, 

    message_id INTEGER REFERENCES chat_messages(id), 

    user_id INTEGER REFERENCES users(id), 

    emoji VARCHAR(10), 

    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, 

    UNIQUE(message_id, user_id, emoji) 

); 



 

CREATE TABLE message_status ( 

    id SERIAL PRIMARY KEY, 

    message_id INTEGER REFERENCES chat_messages(id), 

    user_id INTEGER REFERENCES users(id), 

    status VARCHAR(20) DEFAULT 'sent', -- 'sent', 'delivered', 'read' 

    timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP, 

    UNIQUE(message_id, user_id) 

); 

React Component - Chat Window: 

React 

// components/chat/ChatWindow.jsx 

import { useState, useEffect, useRef } from 'react'; 

import { Send, Paperclip, Smile, MoreVertical } from 'lucide-react'; 

import { useSocket } from '../../hooks/useSocket'; 

import { getConversation, sendMessage } from '../../services/chatService'; 

import MessageBubble from './MessageBubble'; 

 

export default function ChatWindow({ recipientId, recipientName }) { 

  const [messages, setMessages] = useState([]); 

  const [newMessage, setNewMessage] = useState(''); 

  const [isTyping, setIsTyping] = useState(false); 

  const [conversationId, setConversationId] = useState(null); 

  const messagesEndRef = useRef(null); 

  const socket = useSocket(); 

 

  useEffect(() => { 

    loadConversation(); 

  }, [recipientId]); 

 

  useEffect(() => { 



    if (!socket || !conversationId) return; 

 

    // Join conversation room 

    socket.emit('join_room', { conversationId }); 

 

    // Listen for new messages 

    socket.on('new_message', handleNewMessage); 

    socket.on('user_typing', handleTypingIndicator); 

    socket.on('message_status_update', handleStatusUpdate); 

 

    return () => { 

      socket.off('new_message', handleNewMessage); 

      socket.off('user_typing', handleTypingIndicator); 

      socket.off('message_status_update', handleStatusUpdate); 

    }; 

  }, [socket, conversationId]); 

 

  useEffect(() => { 

    scrollToBottom(); 

  }, [messages]); 

 

  const loadConversation = async () => { 

    try { 

      const response = await getConversation(recipientId); 

      setConversationId(response.data.conversation.conversationId); 

      setMessages(response.data.messages); 

    } catch (error) { 

      console.error('Failed to load conversation:', error); 

    } 

  }; 

 



  const handleNewMessage = (data) => { 

    setMessages(prev => [...prev, data]); 

  }; 

 

  const handleTypingIndicator = ({ userId, isTyping }) => { 

    if (userId === recipientId) { 

      setIsTyping(isTyping); 

    } 

  }; 

 

  const handleStatusUpdate = ({ messageId, status }) => { 

    setMessages(prev =>  

      prev.map(msg =>  

        msg.messageId === messageId  

          ? { ...msg, status }  

          : msg 

      ) 

    ); 

  }; 

 

  const handleSendMessage = async (e) => { 

    e.preventDefault(); 

     

    if (!newMessage.trim()) return; 

 

    try { 

      const response = await sendMessage({ 

        recipientId, 

        content: newMessage, 

        messageType: 'text' 

      }); 



 

      // Emit via socket for real-time delivery 

      socket.emit('send_message', { 

        recipientId, 

        content: newMessage, 

        messageType: 'text', 

        messageId: response.data.messageId 

      }); 

 

      setNewMessage(''); 

    } catch (error) { 

      console.error('Failed to send message:', error); 

    } 

  }; 

 

  const handleTyping = (e) => { 

    setNewMessage(e.target.value); 

     

    // Emit typing indicator 

    socket.emit('typing', { 

      recipientId, 

      isTyping: e.target.value.length > 0 

    }); 

  }; 

 

  const scrollToBottom = () => { 

    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' }); 

  }; 

 

  return ( 

    <div className="chat-window"> 



      {/* Chat Header */} 

      <div className="chat-header"> 

        <div className="recipient-info"> 

          <div className="recipient-avatar"> 

            {recipientName.charAt(0)} 

          </div> 

          <div className="recipient-details"> 

            <h3>{recipientName}</h3> 

            <span className="status"> 

              {isTyping ? 'typing...' : 'online'} 

            </span> 

          </div> 

        </div> 

        <button className="more-options"> 

          <MoreVertical size={20} /> 

        </button> 

      </div> 

 

      {/* Messages Area */} 

      <div className="messages-container"> 

        {messages.map((message) => ( 

          <MessageBubble 

            key={message.messageId} 

            message={message} 

            isOwnMessage={message.senderId !== recipientId} 

          /> 

        ))} 

        <div ref={messagesEndRef} /> 

      </div> 

 

      {/* Message Input */} 



      <form onSubmit={handleSendMessage} className="message-input-form"> 

        <button type="button" className="attach-btn"> 

          <Paperclip size={20} /> 

        </button> 

        <input 

          type="text" 

          value={newMessage} 

          onChange={handleTyping} 

          placeholder="Type a message..." 

          className="message-input" 

        /> 

        <button type="button" className="emoji-btn"> 

          <Smile size={20} /> 

        </button> 

        <button type="submit" className="send-btn" disabled={!newMessage.trim()}> 

          <Send size={20} /> 

        </button> 

      </form> 

    </div> 

  ); 

} 

Backend Socket Handler: 

Python 

# backend/app/api/chat/socket_handlers.py 

from flask_socketio import emit, join_room, leave_room 

from flask import request 

from app.extensions import socketio, db 

from app.models.chat import ChatMessage, Conversation 

from flask_jwt_extended import decode_token 

 

# Store active connections 



active_connections = {} 

 

@socketio.on('connect') 

def handle_connect(): 

    """Handle client connection""" 

    try: 

        token = request.args.get('token') 

        decoded = decode_token(token) 

        user_id = decoded['sub'] 

         

        # Store connection 

        active_connections[user_id] = request.sid 

         

        # Broadcast online status 

        emit('user_online', { 

            'userId': user_id, 

            'isOnline': True, 

            'timestamp': datetime.utcnow().isoformat() 

        }, broadcast=True) 

         

        print(f"User {user_id} connected") 

    except Exception as e: 

        print(f"Connection error: {str(e)}") 

 

@socketio.on('disconnect') 

def handle_disconnect(): 

    """Handle client disconnection""" 

    # Find and remove user from active connections 

    user_id = None 

    for uid, sid in active_connections.items(): 

        if sid == request.sid: 



            user_id = uid 

            break 

     

    if user_id: 

        del active_connections[user_id] 

        emit('user_online', { 

            'userId': user_id, 

            'isOnline': False, 

            'timestamp': datetime.utcnow().isoformat() 

        }, broadcast=True) 

 

@socketio.on('join_room') 

def handle_join_room(data): 

    """Join a conversation room""" 

    conversation_id = data.get('conversationId') 

    join_room(conversation_id) 

    print(f"User joined room: {conversation_id}") 

 

@socketio.on('send_message') 

def handle_send_message(data): 

    """Handle real-time message sending""" 

    try: 

        recipient_id = data.get('recipientId') 

        content = data.get('content') 

        message_id = data.get('messageId') 

         

        # Emit to recipient if online 

        if recipient_id in active_connections: 

            emit('new_message', { 

                'messageId': message_id, 

                'senderId': get_current_user_id(), 



                'content': content, 

                'timestamp': datetime.utcnow().isoformat(), 

                'status': 'delivered' 

            }, room=active_connections[recipient_id]) 

             

            # Update message status 

            update_message_status(message_id, recipient_id, 'delivered') 

    except Exception as e: 

        print(f"Send message error: {str(e)}") 

 

@socketio.on('typing') 

def handle_typing(data): 

    """Handle typing indicator""" 

    recipient_id = data.get('recipientId') 

    is_typing = data.get('isTyping') 

     

    if recipient_id in active_connections: 

        emit('user_typing', { 

            'userId': get_current_user_id(), 

            'isTyping': is_typing 

        }, room=active_connections[recipient_id]) 

 

@socketio.on('mark_read') 

def handle_mark_read(data): 

    """Mark messages as read""" 

    conversation_id = data.get('conversationId') 

    message_ids = data.get('messageIds', []) 

    user_id = get_current_user_id() 

     

    for msg_id in message_ids: 

        update_message_status(msg_id, user_id, 'read') 



     

    # Notify sender 

    emit('message_status_update', { 

        'messageIds': message_ids, 

        'status': 'read' 

    }, room=conversation_id) 

 

def update_message_status(message_id, user_id, status): 

    """Update message delivery/read status""" 

    # Database update logic 

    pass 

 

def get_current_user 

_id(): 
"""Get current user ID from socket session""" 
# Extract from JWT token in request context 
pass 

text 

 

--- 

 

### **6.3.2 File Sharing in Chat** 

 

**User Story:** 

> As a user, I want to share documents directly in chat conversations. 

 

**Functional Requirements:** 

 

| **Requirement ID** | **Description** | **Priority** | 

|--------------------|-----------------|--------------| 

| CHAT-FS-001 | User can click attachment icon to share files | P0 | 

| CHAT-FS-002 | User can select files from File Manager | P0 | 



| CHAT-FS-003 | User can upload new files directly in chat | P1 | 

| CHAT-FS-004 | Shared files appear as clickable cards in chat | P0 | 

| CHAT-FS-005 | File card shows: thumbnail, name, size, share date | P0 | 

| CHAT-FS-006 | Recipient can preview file inline | P1 | 

| CHAT-FS-007 | Recipient can download file | P0 | 

| CHAT-FS-008 | File sharing recorded on blockchain | P0 | 

| CHAT-FS-009 | Shared files automatically appear in recipient's "Shared With Me" folder | P0 | 

| CHAT-FS-010 | User can set file permissions when sharing | P0 | 

| CHAT-FS-011 | User can share multiple files at once | P1 | 

| CHAT-FS-012 | File share shows in document properties | P1 | 

 

**API Endpoint:** 

POST /api/chat/share-file 
Headers: Authorization: Bearer <token> 

Request Body: 
{ 
"recipientId": "USER-002", 
"documentId": "DOC-001", 
"permission": "read", 
"message": "Please review this document" // Optional 
} 

Response: 
{ 
"success": true, 
"data": { 
"messageId": "MSG-125", 
"conversationId": "CONV-001", 
"shareId": "SHARE-002", 
"transactionHash": "0xabc...", 
"document": { 
"documentId": "DOC-001", 
"fileName": "Report.pdf", 
"fileSize": 2048000, 
"fileType": "application/pdf", 
"ipfsHash": "QmXYZ..." 
} 
} 
} 



text 

 

**Database Schema:** 

 

```sql 

-- Update chat_messages table to support file attachments 

ALTER TABLE chat_messages  

ADD COLUMN attachment_type VARCHAR(20), -- 'document', 'approval_request' 

ADD COLUMN attachment_id VARCHAR(50), -- References document_id or approval request 

ADD COLUMN attachment_data JSONB; -- Additional metadata 

React Component - File Share in Chat: 

React 

// components/chat/FileShareMessage.jsx 

import { File, Download, Eye, CheckCircle } from 'lucide-react'; 

import { downloadFile, previewFile } from '../../services/fileService'; 

 

export default function FileShareMessage({ message, isOwnMessage }) { 

  const { attachment_data } = message; 

  const document = attachment_data?.document; 

 

  const handleDownload = async () => { 

    try { 

      await downloadFile(document.documentId); 

    } catch (error) { 

      console.error('Download failed:', error); 

    } 

  }; 

 

  const handlePreview = async () => { 

    const url = `https://gateway.pinata.cloud/ipfs/${document.ipfsHash}`; 

    window.open(url, '_blank'); 



  }; 

 

  const formatFileSize = (bytes) => { 

    const k = 1024; 

    const sizes = ['Bytes', 'KB', 'MB', 'GB']; 

    const i = Math.floor(Math.log(bytes) / Math.log(k)); 

    return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i]; 

  }; 

 

  return ( 

    <div className={`message-bubble file-share ${isOwnMessage ? 'own' : 'other'}`}> 

      <div className="file-card"> 

        <div className="file-icon"> 

          <File size={32} /> 

        </div> 

        <div className="file-info"> 

          <div className="file-name">{document.fileName}</div> 

          <div className="file-meta"> 

            {formatFileSize(document.fileSize)} • {document.fileType} 

          </div> 

          {attachment_data.permission && ( 

            <div className="permission-badge"> 

              {attachment_data.permission === 'read' ? 'View Only' : 'Can Edit'} 

            </div> 

          )} 

        </div> 

        <div className="file-actions"> 

          <button onClick={handlePreview} className="action-btn" title="Preview"> 

            <Eye size={18} /> 

          </button> 

          <button onClick={handleDownload} className="action-btn" title="Download"> 



            <Download size={18} /> 

          </button> 

        </div> 

      </div> 

      {message.content && ( 

        <div className="message-text">{message.content}</div> 

      )} 

      <div className="message-footer"> 

        <span className="timestamp"> 

          {new Date(message.timestamp).toLocaleTimeString()} 

        </span> 

        {isOwnMessage && message.status === 'read' && ( 

          <CheckCircle size={14} className="read-indicator" /> 

        )} 

      </div> 

    </div> 

  ); 

} 

 
6.3.3 Group Chats 

User Story: 

As a user, I want to participate in group conversations for department/section communication. 

Functional Requirements: 

Requirement ID Description Priority 

CHAT-GP-001 System auto-creates department groups when department is created P0 

CHAT-GP-002 System auto-creates section groups when section is created P0 

CHAT-GP-003 System auto-creates institution-wide group when institution is created P0 

CHAT-GP-004 Users automatically join groups based on their department/section P0 

CHAT-GP-005 Admin/HOD can create custom groups P1 

CHAT-GP-006 Group creator can add/remove members P1 



Requirement ID Description Priority 

CHAT-GP-007 Group messages visible to all members P0 

CHAT-GP-008 Group shows member count and list P1 

CHAT-GP-009 Group admin can change group name and icon P1 

CHAT-GP-010 Users can mute group notifications P1 

CHAT-GP-011 Users can leave groups (except system groups) P1 

CHAT-GP-012 Group message mentions (@username) send notifications P2 

System-Generated Groups: 

Group Type Auto-Join Condition Admin 

Institution All verified users Institution Admin 

Department Users with matching department HOD 

Section Students with matching section Class Teacher 

API Endpoints: 

text 

GET /api/chat/groups 

Headers: Authorization: Bearer <token> 

 

Response: 

{ 

  "success": true, 

  "data": { 

    "groups": [ 

      { 

        "groupId": "GROUP-001", 

        "name": "Computer Science Department", 

        "groupType": "department", 

        "memberCount": 45, 

        "isAdmin": false, 

        "lastMessage": { 

          "content": "Meeting at 3 PM", 



          "timestamp": "2024-01-20T14:00:00Z" 

        }, 

        "unreadCount": 5 

      } 

    ] 

  } 

} 

text 

GET /api/chat/groups/:groupId/messages 

Headers: Authorization: Bearer <token> 

Query: ?page=1&limit=50 

 

Response: 

{ 

  "success": true, 

  "data": { 

    "group": { 

      "groupId": "GROUP-001", 

      "name": "Computer Science Department", 

      "members": [ 

        { 

          "userId": "USER-001", 

          "name": "Dr. Kumar", 

          "role": "HOD" 

        } 

      ] 

    }, 

    "messages": [ 

      { 

        "messageId": "MSG-200", 

        "senderId": "USER-001", 



        "senderName": "Dr. Kumar", 

        "content": "Important announcement", 

        "timestamp": "2024-01-20T14:00:00Z" 

      } 

    ] 

  } 

} 

text 

POST /api/chat/groups 

Headers: Authorization: Bearer <token> 

 

Request Body: 

{ 

  "name": "Project Team Alpha", 

  "groupType": "custom", 

  "memberIds": ["USER-002", "USER-003", "USER-004"] 

} 

 

Response: 

{ 

  "success": true, 

  "data": { 

    "groupId": "GROUP-010", 

    "name": "Project Team Alpha", 

    "memberCount": 4 

  } 

} 

text 

POST /api/chat/groups/:groupId/messages 

Headers: Authorization: Bearer <token> 

 



Request Body: 

{ 

  "content": "Hello everyone!", 

  "messageType": "text" 

} 

 

Response: 

{ 

  "success": true, 

  "data": { 

    "messageId": "MSG-201", 

    "timestamp": "2024-01-20T15:00:00Z" 

  } 

} 

Database Schema: 

SQL 

CREATE TABLE chat_groups ( 

    id SERIAL PRIMARY KEY, 

    group_id VARCHAR(50) UNIQUE NOT NULL, 

    name VARCHAR(255) NOT NULL, 

    group_type VARCHAR(20) NOT NULL, -- 'institution', 'department', 'section', 'custom' 

    institution_id INTEGER REFERENCES institutions(id), 

    department_id INTEGER REFERENCES departments(id), 

    section_id INTEGER REFERENCES sections(id), 

    created_by INTEGER REFERENCES users(id), 

    group_icon TEXT, 

    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP 

); 

 

CREATE TABLE group_members ( 

    id SERIAL PRIMARY KEY, 



    group_id INTEGER REFERENCES chat_groups(id), 

    user_id INTEGER REFERENCES users(id), 

    role VARCHAR(20) DEFAULT 'member', -- 'admin', 'member' 

    joined_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, 

    last_read_at TIMESTAMP, 

    is_muted BOOLEAN DEFAULT FALSE, 

    is_active BOOLEAN DEFAULT TRUE, 

    UNIQUE(group_id, user_id) 

); 

 

-- Group messages use same chat_messages table 

-- conversation_id links to group_id 

React Component - Group Chat: 

React 

// components/chat/GroupChat.jsx 

import { useState, useEffect } from 'react'; 

import { Users, Settings, Bell, BellOff } from 'lucide-react'; 

import { getGroupMessages, sendGroupMessage } from '../../services/chatService'; 

import { useSocket } from '../../hooks/useSocket'; 

import MessageBubble from './MessageBubble'; 

 

export default function GroupChat({ groupId, groupName }) { 

  const [messages, setMessages] = useState([]); 

  const [members, setMembers] = useState([]); 

  const [newMessage, setNewMessage] = useState(''); 

  const [isMuted, setIsMuted] = useState(false); 

  const [showMembers, setShowMembers] = useState(false); 

  const socket = useSocket(); 

 

  useEffect(() => { 

    loadGroupData(); 



  }, [groupId]); 

 

  useEffect(() => { 

    if (!socket || !groupId) return; 

 

    socket.emit('join_room', { conversationId: groupId }); 

 

    socket.on('new_message', (data) => { 

      setMessages(prev => [...prev, data]); 

    }); 

 

    return () => { 

      socket.off('new_message'); 

    }; 

  }, [socket, groupId]); 

 

  const loadGroupData = async () => { 

    try { 

      const response = await getGroupMessages(groupId); 

      setMessages(response.data.messages); 

      setMembers(response.data.group.members); 

    } catch (error) { 

      console.error('Failed to load group:', error); 

    } 

  }; 

 

  const handleSendMessage = async (e) => { 

    e.preventDefault(); 

     

    if (!newMessage.trim()) return; 

 



    try { 

      await sendGroupMessage(groupId, { 

        content: newMessage, 

        messageType: 'text' 

      }); 

 

      socket.emit('send_group_message', { 

        groupId, 

        content: newMessage 

      }); 

 

      setNewMessage(''); 

    } catch (error) { 

      console.error('Failed to send message:', error); 

    } 

  }; 

 

  const toggleMute = () => { 

    // API call to mute/unmute group 

    setIsMuted(!isMuted); 

  }; 

 

  return ( 

    <div className="group-chat"> 

      {/* Group Header */} 

      <div className="group-header"> 

        <div className="group-info"> 

          <Users size={24} /> 

          <div> 

            <h3>{groupName}</h3> 

            <span className="member-count">{members.length} members</span> 



          </div> 

        </div> 

        <div className="group-actions"> 

          <button onClick={toggleMute} title={isMuted ? 'Unmute' : 'Mute'}> 

            {isMuted ? <BellOff size={20} /> : <Bell size={20} />} 

          </button> 

          <button onClick={() => setShowMembers(!showMembers)}> 

            <Settings size={20} /> 

          </button> 

        </div> 

      </div> 

 

      {/* Members Sidebar */} 

      {showMembers && ( 

        <div className="members-sidebar"> 

          <h4>Group Members ({members.length})</h4> 

          <div className="members-list"> 

            {members.map(member => ( 

              <div key={member.userId} className="member-item"> 

                <div className="member-avatar"> 

                  {member.name.charAt(0)} 

                </div> 

                <div className="member-info"> 

                  <div className="member-name">{member.name}</div> 

                  <div className="member-role">{member.role}</div> 

                </div> 

              </div> 

            ))} 

          </div> 

        </div> 

      )} 



 

      {/* Messages */} 

      <div className="messages-container"> 

        {messages.map(message => ( 

          <div key={message.messageId} className="group-message"> 

            <div className="sender-name">{message.senderName}</div> 

            <MessageBubble message={message} isOwnMessage={false} /> 

          </div> 

        ))} 

      </div> 

 

      {/* Message Input */} 

      <form onSubmit={handleSendMessage} className="message-input-form"> 

        <input 

          type="text" 

          value={newMessage} 

          onChange={(e) => setNewMessage(e.target.value)} 

          placeholder={`Message ${groupName}...`} 

          className="message-input" 

        /> 

        <button type="submit" disabled={!newMessage.trim()}> 

          Send 

        </button> 

      </form> 

    </div> 

  ); 

} 

 
6.3.4 Circular Feed in Chat 

User Story: 

As a user, I want to view institutional circulars in a feed within the chat interface. 



Functional Requirements: 

Requirement ID Description Priority 

CHAT-CF-001 Circulars tab shows latest institutional announcements P0 

CHAT-CF-002 Circulars displayed in chronological order (newest first) P0 

CHAT-CF-003 Each circular shows: title, date, priority, preview P0 

CHAT-CF-004 User can click circular to view full content P0 

CHAT-CF-005 User can filter circulars by priority (all/high/medium/low) P1 

CHAT-CF-006  
 

User can search circulars by title or content | P1 | 
| CHAT-CF-007 | User can download circular attachments | P1 | 
| CHAT-CF-008 | Unread circulars highlighted with badge | P1 | 
| CHAT-CF-009 | User receives notification for new circulars | P0 | 
| CHAT-CF-010 | Admin/faculty circulars auto-posted to relevant groups | P0 | 
| CHAT-CF-011 | Circulars show targeted audience (all/students/faculty) | P1 | 
| CHAT-CF-012 | User can mark circulars as read/unread | P1 | 

API Endpoints: 

text 

GET /api/circulars/feed 

Headers: Authorization: Bearer <token> 

Query: ?page=1&limit=20&priority=all&read=false 

 

Response: 

{ 

  "success": true, 

  "data": { 

    "circulars": [ 

      { 

        "circularId": "CIR-001", 

        "title": "Mid-Semester Examination Schedule", 

        "circularNumber": "CIRC/2024/001", 

        "priority": "high", 

        "issueDate": "2024-01-20", 



        "effectiveDate": "2024-01-25", 

        "content": "This is to inform all students...", 

        "contentPreview": "This is to inform all students about the upcoming...", 

        "targetAudience": "students", 

        "attachments": [ 

          { 

            "fileName": "exam_schedule.pdf", 

            "fileSize": 204800, 

            "ipfsHash": "QmABC..." 

          } 

        ], 

        "issuedBy": { 

          "userId": "USER-001", 

          "name": "Dr. Principal", 

          "role": "admin" 

        }, 

        "isRead": false, 

        "createdAt": "2024-01-20T10:00:00Z" 

      } 

    ], 

    "unreadCount": 5, 

    "pagination": { 

      "currentPage": 1, 

      "totalPages": 3, 

      "totalCirculars": 45 

    } 

  } 

} 

text 

GET /api/circulars/:circularId 

Headers: Authorization: Bearer <token> 



 

Response: 

{ 

  "success": true, 

  "data": { 

    "circular": { 

      "circularId": "CIR-001", 

      "title": "Mid-Semester Examination Schedule", 

      "circularNumber": "CIRC/2024/001", 

      "priority": "high", 

      "issueDate": "2024-01-20", 

      "effectiveDate": "2024-01-25", 

      "content": "Full content here...", 

      "targetAudience": "students", 

      "attachments": [], 

      "issuedBy": { 

        "userId": "USER-001", 

        "name": "Dr. Principal", 

        "designation": "Principal" 

      }, 

      "institutionDetails": { 

        "name": "ABC University", 

        "logo": "https://..." 

      }, 

      "createdAt": "2024-01-20T10:00:00Z" 

    } 

  } 

} 

text 

POST /api/circulars/:circularId/mark-read 

Headers: Authorization: Bearer <token> 



 

Response: 

{ 

  "success": true, 

  "message": "Circular marked as read" 

} 

React Component - Circular Feed: 

React 

// components/chat/CircularFeed.jsx 

import { useState, useEffect } from 'react'; 

import { Bell, Filter, Search, Download, Eye } from 'lucide-react'; 

import { getCircularFeed, markCircularAsRead } from '../../services/circularService'; 

 

export default function CircularFeed() { 

  const [circulars, setCirculars] = useState([]); 

  const [unreadCount, setUnreadCount] = useState(0); 

  const [filterPriority, setFilterPriority] = useState('all'); 

  const [searchQuery, setSearchQuery] = useState(''); 

  const [loading, setLoading] = useState(true); 

 

  useEffect(() => { 

    loadCirculars(); 

  }, [filterPriority]); 

 

  const loadCirculars = async () => { 

    try { 

      const response = await getCircularFeed({ 

        priority: filterPriority, 

        search: searchQuery 

      }); 

      setCirculars(response.data.circulars); 



      setUnreadCount(response.data.unreadCount); 

    } catch (error) { 

      console.error('Failed to load circulars:', error); 

    } finally { 

      setLoading(false); 

    } 

  }; 

 

  const handleCircularClick = async (circular) => { 

    if (!circular.isRead) { 

      await markCircularAsRead(circular.circularId); 

      setUnreadCount(prev => prev - 1); 

    } 

    // Open circular detail modal 

  }; 

 

  const getPriorityColor = (priority) => { 

    switch (priority) { 

      case 'high': return 'bg-red-100 text-red-800'; 

      case 'medium': return 'bg-yellow-100 text-yellow-800'; 

      case 'low': return 'bg-green-100 text-green-800'; 

      default: return 'bg-gray-100 text-gray-800'; 

    } 

  }; 

 

  const getPriorityIcon = (priority) => { 

    return priority === 'high' ? ' ' : priority === 'medium' ? ' ' : ' '; 

  }; 

 

  return ( 

    <div className="circular-feed"> 



      {/* Header */} 

      <div className="feed-header"> 

        <div className="header-left"> 

          <Bell size={24} /> 

          <h2>Circulars</h2> 

          {unreadCount > 0 && ( 

            <span className="unread-badge">{unreadCount}</span> 

          )} 

        </div> 

      </div> 

 

      {/* Filters */} 

      <div className="feed-filters"> 

        <div className="search-box"> 

          <Search size={18} /> 

          <input 

            type="text" 

            placeholder="Search circulars..." 

            value={searchQuery} 

            onChange={(e) => setSearchQuery(e.target.value)} 

            onKeyPress={(e) => e.key === 'Enter' && loadCirculars()} 

          /> 

        </div> 

        <div className="priority-filter"> 

          <Filter size={18} /> 

          <select  

            value={filterPriority} 

            onChange={(e) => setFilterPriority(e.target.value)} 

          > 

            <option value="all">All Priority</option> 

            <option value="high">High</option> 



            <option value="medium">Medium</option> 

            <option value="low">Low</option> 

          </select> 

        </div> 

      </div> 

 

      {/* Circular List */} 

      <div className="circular-list"> 

        {loading ? ( 

          <div className="loading">Loading circulars...</div> 

        ) : circulars.length === 0 ? ( 

          <div className="empty-state"> 

            <Bell size={48} /> 

            <p>No circulars found</p> 

          </div> 

        ) : ( 

          circulars.map((circular) => ( 

            <div 

              key={circular.circularId} 

              className={`circular-card ${!circular.isRead ? 'unread' : ''}`} 

              onClick={() => handleCircularClick(circular)} 

            > 

              <div className="circular-header"> 

                <div className="circular-title-section"> 

                  {!circular.isRead && <div className="unread-dot" />} 

                  <h3 className="circular-title">{circular.title}</h3> 

                </div> 

                <div className="circular-meta"> 

                  <span className={`priority-badge ${getPriorityColor(circular.priority)}`}> 

                    {getPriorityIcon(circular.priority)} {circular.priority} 

                  </span> 



                </div> 

              </div> 

 

              <div className="circular-info"> 

                <div className="info-row"> 

                  <span className="label">Circular No:</span> 

                  <span className="value">{circular.circularNumber}</span> 

                </div> 

                <div className="info-row"> 

                  <span className="label">Date:</span> 

                  <span className="value"> 

                    {new Date(circular.issueDate).toLocaleDateString()} 

                  </span> 

                </div> 

                <div className="info-row"> 

                  <span className="label">For:</span> 

                  <span className="value audience-badge"> 

                    {circular.targetAudience} 

                  </span> 

                </div> 

              </div> 

 

              <div className="circular-preview"> 

                <p>{circular.contentPreview}</p> 

              </div> 

 

              {circular.attachments.length > 0 && ( 

                <div className="circular-attachments"> 

                  <span className="attachment-label"> 

                     {circular.attachments.length} attachment(s) 

                  </span> 



                </div> 

              )} 

 

              <div className="circular-footer"> 

                <div className="issuer-info"> 

                  <span className="issuer-name"> 

                    Issued by: {circular.issuedBy.name} 

                  </span> 

                </div> 

                <button className="view-btn"> 

                  <Eye size={16} /> 

                  View Full 

                </button> 

              </div> 

            </div> 

          )) 

        )} 

      </div> 

    </div> 

  ); 

} 

 
6.4 Document Generation Tool 

6.4.1 Template Management 

User Story: 

As a user, I want to use predefined templates to quickly generate institutional documents. 

Functional Requirements: 

Requirement ID Description Priority 

DOC-TM-001 System provides predefined templates for common documents P0 

DOC-TM-002 Templates include: certificates, bonafide, leave applications, circulars, etc. P0 



Requirement ID Description Priority 

DOC-TM-003 Templates auto-fill institution details (name, address, logo) P0 

DOC-TM-004 User can browse templates by category P0 

DOC-TM-005 User can preview template before using P1 

DOC-TM-006 Admin can create custom templates P1 

DOC-TM-007 Templates support dynamic fields (student name, date, etc.) P0 

DOC-TM-008 Templates include header/footer with institution branding P0 

DOC-TM-009 User can duplicate and customize templates P1 

DOC-TM-010 Templates saved in JSON format for flexibility P1 

Template Categories: 

Category Templates Available To 

Certificates Participation, Achievement, Course Completion Faculty, Admin 

Bonafide Student Bonafide, Employee Bonafide Faculty, Admin 

Leave Medical Leave, Casual Leave, Academic Leave Students, Faculty 

Circulars General Announcement, Exam Notice, Event Notification Admin, Faculty 

Reports Progress Report, Attendance Report, Fee Report Faculty, Admin 

Letters Recommendation Letter, Experience Letter, Transfer Letter Faculty, Admin 

API Endpoints: 

text 

GET /api/document-generation/templates 

Headers: Authorization: Bearer <token> 

Query: ?category=certificates&page=1&limit=20 

 

Response: 

{ 

  "success": true, 

  "data": { 

    "templates": [ 

      { 

        "templateId": "TMPL-001", 



        "name": "Student Bonafide Certificate", 

        "category": "certificates", 

        "description": "Standard bonafide certificate for students", 

        "thumbnail": "https://...", 

        "fields": [ 

          { 

            "fieldId": "student_name", 

            "label": "Student Name", 

            "type": "text", 

            "required": true 

          }, 

          { 

            "fieldId": "class", 

            "label": "Class/Year", 

            "type": "text", 

            "required": true 

          }, 

          { 

            "fieldId": "purpose", 

            "label": "Purpose", 

            "type": "textarea", 

            "required": false 

          } 

        ], 

        "layout": { 

          "header": { 

            "includeInstitutionLogo": true, 

            "includeInstitutionName": true, 

            "includeAddress": true 

          }, 

          "body": "template_html_content", 



          "footer": { 

            "includeSignature": true, 

            "signatureFields": ["Principal", "Class Teacher"] 

          } 

        }, 

        "createdBy": "system", 

        "isActive": true 

      } 

    ], 

    "categories": [ 

      { "name": "certificates", "count": 12 }, 

      { "name": "bonafide", "count": 5 }, 

      { "name": "leave", "count": 8 } 

    ] 

  } 

} 

text 

GET /api/document-generation/templates/:templateId 

Headers: Authorization: Bearer <token> 

 

Response: 

{ 

  "success": true, 

  "data": { 

    "template": { 

      "templateId": "TMPL-001", 

      "name": "Student Bonafide Certificate", 

      "fullContent": "<html>...</html>", 

      "fields": [], 

      "layout": {} 

    } 



  } 

} 

Database Schema: 

SQL 

CREATE TABLE document_templates ( 

    id SERIAL PRIMARY KEY, 

    template_id VARCHAR(50) UNIQUE NOT NULL, 

    name VARCHAR(255) NOT NULL, 

    category VARCHAR(50) NOT NULL, 

    description TEXT, 

    thumbnail TEXT, 

    fields JSONB NOT NULL, -- Dynamic form fields 

    layout JSONB NOT NULL, -- HTML layout with placeholders 

    created_by INTEGER REFERENCES users(id), 

    institution_id INTEGER REFERENCES institutions(id), 

    is_system_template BOOLEAN DEFAULT FALSE, 

    is_active BOOLEAN DEFAULT TRUE, 

    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, 

    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP 

); 

 

CREATE INDEX idx_templates_category ON document_templates(category, is_active); 

CREATE INDEX idx_templates_institution ON document_templates(institution_id); 

Template JSON Structure: 

JSON 

{ 

  "templateId": "TMPL-001", 

  "name": "Student Bonafide Certificate", 

  "category": "certificates", 

  "fields": [ 

    { 



      "fieldId": "student_name", 

      "label": "Student Name", 

      "type": "text", 

      "placeholder": "Enter student name", 

      "required": true, 

      "validation": "^[a-zA-Z ]+$" 

    }, 

    { 

      "fieldId": "student_id", 

      "label": "Student ID", 

      "type": "text", 

      "required": true 

    }, 

    { 

      "fieldId": "class", 

      "label": "Class/Year", 

      "type": "select", 

      "options": ["I Year", "II Year", "III Year", "IV Year"], 

      "required": true 

    }, 

    { 

      "fieldId": "date_of_issue", 

      "label": "Date of Issue", 

      "type": "date", 

      "default": "today", 

      "required": true 

    } 

  ], 

  "layout": { 

    "header": { 

      "includeInstitutionLogo": true, 



      "includeInstitutionName": true, 

      "includeAddress": true, 

      "customHTML": "<div class='header-custom'>...</div>" 

    }, 

    "body": ` 

      <div class='certificate-body'> 

        <h2>BONAFIDE CERTIFICATE</h2> 

        <p>This is to certify that <strong>{{student_name}}</strong>,  

        bearing Student ID <strong>{{ 

student_id}}</strong>, 

is a bonafide student of this institution studying in 

<strong>{{class}}</strong> during the academic year 

<strong>{{academic_year}}</strong>.</p> 

 

text 

 

    <p>This certificate is issued on <strong>{{date_of_issue}}</strong>  

    for the purpose of <strong>{{purpose}}</strong>.</p> 

     

    <div class='certificate-footer'> 

      <div class='signature-section'> 

        <p>Class Teacher</p> 

        <p>{{signature_class_teacher}}</p> 

      </div> 

      <div class='signature-section'> 

        <p>Principal</p> 

        <p>{{signature_principal}}</p> 

      </div> 

    </div> 

  </div> 

`, 



"footer": { 

  "includeDate": true, 

  "includeSerialNumber": true, 

  "customText": "This is a computer-generated document" 

} 

}, 

"styling": { 

"fontFamily": "Times New Roman", 

"fontSize": "12pt", 

"margins": { 

"top": "1in", 

"bottom": "1in", 

"left": "1in", 

"right": "1in" 

}, 

"colors": { 

"primary": "#000000", 

"secondary": "#333333", 

"accent": "#0066cc" 

} 

} 

} 

 

text 

 

 

--- 

 

### **6.4.2 Document Creation from Template** 

 

**User Story:** 



> As a user, I want to fill out a template form and generate a formatted document. 

 

**Functional Requirements:** 

 

| **Requirement ID** | **Description** | **Priority** | 

|--------------------|-----------------|--------------| 

| DOC-CR-001 | User selects template from template library | P0 | 

| DOC-CR-002 | System displays dynamic form based on template fields | P0 | 

| DOC-CR-003 | Form includes validation for required fields | P0 | 

| DOC-CR-004 | User can auto-fill fields from their profile (name, ID, etc.) | P1 | 

| DOC-CR-005 | Institution details (name, logo, address) auto-populated | P0 | 

| DOC-CR-006 | User can preview document before saving | P0 | 

| DOC-CR-007 | User can save as draft for later completion | P0 | 

| DOC-CR-008 | User can export document as PDF | P0 | 

| DOC-CR-009 | Generated document includes QR code with verification data | P0 | 

| DOC-CR-010 | User can send document for approval after generation | P0 | 

| DOC-CR-011 | Document stored in "Drafts" folder until finalized | P0 | 

| DOC-CR-012 | User can edit draft documents | P0 | 

 

**API Endpoints:** 

POST /api/document-generation/create 

Headers: Authorization: Bearer <token> 

 

Request Body: 

{ 

"templateId": "TMPL-001", 

"fieldData": { 

"student_name": "John Doe", 

"student_id": "STU2024001", 

"class": "III Year", 

"purpose": "Bank loan application", 



"date_of_issue": "2024-01-20" 

}, 

"saveAsDraft": true, 

"draftName": "My Bonafide Certificate Draft" 

} 

 

Response: 

{ 

"success": true, 

"data": { 

"documentId": "DOC-GEN-001", 

"draftId": "DRAFT-001", 

"fileName": "Bonafide_Certificate_JohnDoe.pdf", 

"previewUrl": "https://...", 

"status": "draft", 

"createdAt": "2024-01-20T10:30:00Z" 

} 

} 

 

GET /api/document-generation/drafts 

Headers: Authorization: Bearer <token> 

 

Response: 

{ 

"success": true, 

"data": { 

"drafts": [ 

{ 

"draftId": "DRAFT-001", 

"draftName": "My Bonafide Certificate Draft", 

"templateId": "TMPL-001", 



"templateName": "Student Bonafide Certificate", 

"fieldData": {}, 

"lastModified": "2024-01-20T10:30:00Z", 

"createdAt": "2024-01-19T15:00:00Z" 

} 

] 

} 

} 

 

PUT /api/document-generation/drafts/:draftId 

Headers: Authorization: Bearer <token> 

 

Request Body: 

{ 

"fieldData": { 

"student_name": "John Doe Updated", 

"purpose": "Updated purpose" 

} 

} 

 

Response: 

{ 

"success": true, 

"message": "Draft updated successfully" 

} 

 

POST /api/document-generation/drafts/:draftId/finalize 

Headers: Authorization: Bearer <token> 

 

Request Body: 

{ 



"approvalType": "digital_sign", // or "standard" 

"approvers": [ 

{ 

"userId": "USER-003", 

"role": "Class Teacher", 

"sequence": 1 

}, 

{ 

"userId": "USER-001", 

"role": "Principal", 

"sequence": 2 

} 

], 

"approvalProcess": "sequential" // or "parallel" 

} 

 

Response: 

{ 

"success": true, 

"data": { 

"approvalRequestId": "APPR-001", 

"documentId": "DOC-002", 

"status": "pending_approval", 

"transactionHash": "0xabc..." 

} 

} 

 

text 

 

 

**React Component - Document Generator:** 



 

```jsx 

// components/document-generation/DocumentGenerator.jsx 

import { useState, useEffect } from 'react'; 

import { FileText, Save, Eye, Send } from 'lucide-react'; 

import {  

  getTemplate,  

  createDocument,  

  saveDraft, 

  finalizeDraft  

} from '../../services/documentService'; 

import DocumentPreview from './DocumentPreview'; 

import ApprovalWorkflowModal from './ApprovalWorkflowModal'; 

 

export default function DocumentGenerator({ templateId }) { 

  const [template, setTemplate] = useState(null); 

  const [formData, setFormData] = useState({}); 

  const [errors, setErrors] = useState({}); 

  const [showPreview, setShowPreview] = useState(false); 

  const [showApprovalModal, setShowApprovalModal] = useState(false); 

  const [loading, setLoading] = useState(true); 

  const [draftId, setDraftId] = useState(null); 

 

  useEffect(() => { 

    loadTemplate(); 

  }, [templateId]); 

 

  const loadTemplate = async () => { 

    try { 

      const response = await getTemplate(templateId); 

      setTemplate(response.data.template); 



       

      // Initialize form with default values 

      const initialData = {}; 

      response.data.template.fields.forEach(field => { 

        if (field.default) { 

          initialData[field.fieldId] = field.default === 'today'  

            ? new Date().toISOString().split('T')[0] 

            : field.default; 

        } 

      }); 

      setFormData(initialData); 

    } catch (error) { 

      console.error('Failed to load template:', error); 

    } finally { 

      setLoading(false); 

    } 

  }; 

 

  const handleFieldChange = (fieldId, value) => { 

    setFormData(prev => ({ 

      ...prev, 

      [fieldId]: value 

    })); 

     

    // Clear error for this field 

    if (errors[fieldId]) { 

      setErrors(prev => { 

        const newErrors = { ...prev }; 

        delete newErrors[fieldId]; 

        return newErrors; 

      }); 



    } 

  }; 

 

  const validateForm = () => { 

    const newErrors = {}; 

     

    template.fields.forEach(field => { 

      if (field.required && !formData[field.fieldId]) { 

        newErrors[field.fieldId] = `${field.label} is required`; 

      } 

       

      if (field.validation && formData[field.fieldId]) { 

        const regex = new RegExp(field.validation); 

        if (!regex.test(formData[field.fieldId])) { 

          newErrors[field.fieldId] = `Invalid ${field.label} format`; 

        } 

      } 

    }); 

     

    setErrors(newErrors); 

    return Object.keys(newErrors).length === 0; 

  }; 

 

  const handleSaveDraft = async () => { 

    try { 

      const response = await saveDraft({ 

        templateId, 

        fieldData: formData, 

        draftName: `${template.name} Draft` 

      }); 

       



      setDraftId(response.data.draftId); 

      toast.success('Draft saved successfully'); 

    } catch (error) { 

      toast.error('Failed to save draft'); 

    } 

  }; 

 

  const handlePreview = () => { 

    if (!validateForm()) { 

      toast.error('Please fill all required fields'); 

      return; 

    } 

    setShowPreview(true); 

  }; 

 

  const handleRequestApproval = () => { 

    if (!validateForm()) { 

      toast.error('Please fill all required fields'); 

      return; 

    } 

    setShowApprovalModal(true); 

  }; 

 

  const handleApprovalSubmit = async (approvalData) => { 

    try { 

      const response = await finalizeDraft(draftId || 'new', { 

        fieldData: formData, 

        templateId, 

        ...approvalData 

      }); 

       



      toast.success('Document sent for approval'); 

      // Navigate to approval requests page 

    } catch (error) { 

      toast.error('Failed to send for approval'); 

    } 

  }; 

 

  const renderField = (field) => { 

    switch (field.type) { 

      case 'text': 

        return ( 

          <input 

            type="text" 

            id={field.fieldId} 

            value={formData[field.fieldId] || ''} 

            onChange={(e) => handleFieldChange(field.fieldId, e.target.value)} 

            placeholder={field.placeholder} 

            className={`form-input ${errors[field.fieldId] ? 'error' : ''}`} 

          /> 

        ); 

       

      case 'textarea': 

        return ( 

          <textarea 

            id={field.fieldId} 

            value={formData[field.fieldId] || ''} 

            onChange={(e) => handleFieldChange(field.fieldId, e.target.value)} 

            placeholder={field.placeholder} 

            rows={4} 

            className={`form-textarea ${errors[field.fieldId] ? 'error' : ''}`} 

          /> 



        ); 

       

      case 'select': 

        return ( 

          <select 

            id={field.fieldId} 

            value={formData[field.fieldId] || ''} 

            onChange={(e) => handleFieldChange(field.fieldId, e.target.value)} 

            className={`form-select ${errors[field.fieldId] ? 'error' : ''}`} 

          > 

            <option value="">Select {field.label}</option> 

            {field.options.map(option => ( 

              <option key={option} value={option}>{option}</option> 

            ))} 

          </select> 

        ); 

       

      case 'date': 

        return ( 

          <input 

            type="date" 

            id={field.fieldId} 

            value={formData[field.fieldId] || ''} 

            onChange={(e) => handleFieldChange(field.fieldId, e.target.value)} 

            className={`form-input ${errors[field.fieldId] ? 'error' : ''}`} 

          /> 

        ); 

       

      default: 

        return null; 

    } 



  }; 

 

  if (loading) { 

    return <div className="loading">Loading template...</div>; 

  } 

 

  return ( 

    <div className="document-generator"> 

      <div className="generator-header"> 

        <div className="header-left"> 

          <FileText size={24} /> 

          <h2>{template.name}</h2> 

        </div> 

        <div className="header-actions"> 

          <button onClick={handleSaveDraft} className="btn-secondary"> 

            <Save size={18} /> 

            Save Draft 

          </button> 

          <button onClick={handlePreview} className="btn-secondary"> 

            <Eye size={18} /> 

            Preview 

          </button> 

          <button onClick={handleRequestApproval} className="btn-primary"> 

            <Send size={18} /> 

            Request Approval 

          </button> 

        </div> 

      </div> 

 

      <div className="generator-body"> 

        <form className="document-form"> 



          {template.fields.map(field => ( 

            <div key={field.fieldId} className="form-group"> 

              <label htmlFor={field.fieldId}> 

                {field.label} 

                {field.required && <span className="required">*</span>} 

              </label> 

              {renderField(field)} 

              {errors[field.fieldId] && ( 

                <span className="error-message">{errors[field.fieldId]}</span> 

              )} 

            </div> 

          ))} 

        </form> 

 

        <div className="template-preview-section"> 

          <h3>Document Preview</h3> 

          <div className="preview-placeholder"> 

            <p>Fill the form to see live preview</p> 

          </div> 

        </div> 

      </div> 

 

      {showPreview && ( 

        <DocumentPreview 

          template={template} 

          formData={formData} 

          onClose={() => setShowPreview(false)} 

        /> 

      )} 

 

      {showApprovalModal && ( 



        <ApprovalWorkflowModal 

          onClose={() => setShowApprovalModal(false)} 

          onSubmit={handleApprovalSubmit} 

        /> 

      )} 

    </div> 

  ); 

} 

Backend Service - PDF Generation: 

 

Python 

 

# backend/app/services/document_generation_service.py 

from reportlab.lib.pagesizes import letter, A4 

from reportlab.lib import colors 

from reportlab.lib.units import inch 

from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Image, Table 

from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle 

from reportlab.lib.enums import TA_CENTER, TA_RIGHT 

import qrcode 

import io 

import json 

from datetime import datetime 

 

class DocumentGenerationService: 

    def __init__(self): 

        self.styles = getSampleStyleSheet() 

        self.setup_custom_styles() 

     

    def setup_custom_styles(self): 

        """Setup custom paragraph styles""" 



        self.styles.add(ParagraphStyle( 

            name='CustomTitle', 

            parent=self.styles['Heading1'], 

            fontSize=18, 

            textColor=colors.HexColor('#0066cc'), 

            spaceAfter=30, 

            alignment=TA_CENTER 

        )) 

         

        self.styles.add(ParagraphStyle( 

            name='CustomBody', 

            parent=self.styles['BodyText'], 

            fontSize=12, 

            leading=18, 

            spaceAfter=12 

        )) 

     

    def generate_document(self, template, field_data, institution_data): 

        """Generate PDF document from template and field data""" 

        buffer = io.BytesIO() 

        doc = SimpleDocTemplate( 

            buffer, 

            pagesize=A4, 

            rightMargin=72, 

            leftMargin=72, 

            topMargin=72, 

            bottomMargin=72 

        ) 

         

        # Build document content 

        story = [] 



         

        # Header 

        if template['layout']['header']['includeInstitutionLogo']: 

            story.extend(self._build_header(institution_data)) 

         

        # Body 

        body_html = self._replace_placeholders( 

            template['layout']['body'], 

            field_data, 

            institution_data 

        ) 

        story.extend(self._parse_html_to_elements(body_html)) 

         

        # QR Code 

        qr_data = self._generate_verification_data(field_data, template) 
qr_image = self._create_qr_code(qr_data) 
story.append(Spacer(1, 20)) 
story.append(qr_image) 

text 

    # Footer 

    story.extend(self._build_footer(template)) 

     

    # Build PDF 

    doc.build(story) 

    buffer.seek(0) 

     

    return buffer 

 

def _build_header(self, institution_data): 

    """Build document header with institution details""" 

    elements = [] 

     



    # Institution logo 

    if institution_data.get('logo'): 

        logo = Image(institution_data['logo'], width=1*inch, height=1*inch) 

        logo.hAlign = 'CENTER' 

        elements.append(logo) 

        elements.append(Spacer(1, 12)) 

     

    # Institution name 

    institution_name = Paragraph( 

        f"<b>{institution_data['name']}</b>", 

        self.styles['CustomTitle'] 

    ) 

    elements.append(institution_name) 

     

    # Address 

    address = Paragraph( 

        institution_data['address'], 

        ParagraphStyle( 

            name='Address', 

            parent=self.styles['Normal'], 

            fontSize=10, 

            alignment=TA_CENTER 

        ) 

    ) 

    elements.append(address) 

    elements.append(Spacer(1, 20)) 

     

    # Horizontal line 

    elements.append(self._create_horizontal_line()) 

    elements.append(Spacer(1, 20)) 

     



    return elements 

 

def _replace_placeholders(self, template_html, field_data, institution_data): 

    """Replace template placeholders with actual data""" 

    content = template_html 

     

    # Replace field data 

    for field_id, value in field_data.items(): 

        placeholder = f"{{{{{field_id}}}}}" 

        content = content.replace(placeholder, str(value)) 

     

    # Replace institution data 

    for key, value in institution_data.items(): 

        placeholder = f"{{{{institution_{key}}}}}" 

        content = content.replace(placeholder, str(value)) 

     

    # Replace current date 

    content = content.replace( 

        "{{current_date}}",  

        datetime.now().strftime("%d %B %Y") 

    ) 

     

    return content 

 

def _parse_html_to_elements(self, html_content): 

    """Convert HTML to ReportLab elements""" 

    elements = [] 

     

    # Split by paragraph tags 

    paragraphs = html_content.split('</p>') 

     



    for para in paragraphs: 

        if para.strip(): 

            # Clean up HTML 

            clean_para = para.replace('<p>', '').strip() 

             

            # Determine style based on content 

            if '<h2>' in clean_para: 

                style = self.styles['CustomTitle'] 

                clean_para = clean_para.replace('<h2>', '').replace('</h2>', '') 

            else: 

                style = self.styles['CustomBody'] 

             

            # Create paragraph 

            p = Paragraph(clean_para, style) 

            elements.append(p) 

            elements.append(Spacer(1, 12)) 

     

    return elements 

 

def _create_qr_code(self, data): 

    """Generate QR code with verification data""" 

    qr = qrcode.QRCode( 

        version=1, 

        error_correction=qrcode.constants.ERROR_CORRECT_L, 

        box_size=10, 

        border=4, 

    ) 

     

    qr.add_data(json.dumps(data)) 

    qr.make(fit=True) 

     



    # Create QR image 

    qr_img = qr.make_image(fill_color="black", back_color="white") 

     

    # Convert to ReportLab Image 

    img_buffer = io.BytesIO() 

    qr_img.save(img_buffer, format='PNG') 

    img_buffer.seek(0) 

     

    img = Image(img_buffer, width=1.5*inch, height=1.5*inch) 

    img.hAlign = 'RIGHT' 

     

    return img 

 

def _generate_verification_data(self, field_data, template): 

    """Generate verification data for QR code""" 

    return { 

        'documentType': template['name'], 

        'issueDate': datetime.now().isoformat(), 

        'verificationUrl': f"https://docuchain.app/verify/{generate_unique_id()}", 

        'documentHash': self._calculate_document_hash(field_data), 

        'templateId': template['templateId'] 

    } 

 

def _calculate_document_hash(self, field_data): 

    """Calculate SHA256 hash of document data""" 

    import hashlib 

    data_string = json.dumps(field_data, sort_keys=True) 

    return hashlib.sha256(data_string.encode()).hexdigest() 

 

def _build_footer(self, template): 

    """Build document footer""" 



    elements = [] 

     

    elements.append(Spacer(1, 30)) 

    elements.append(self._create_horizontal_line()) 

     

    footer_text = Paragraph( 

        "This is a digitally generated document verified on blockchain", 

        ParagraphStyle( 

            name='Footer', 

            parent=self.styles['Normal'], 

            fontSize=8, 

            textColor=colors.grey, 

            alignment=TA_CENTER 

        ) 

    ) 

    elements.append(footer_text) 

     

    return elements 

 

def _create_horizontal_line(self): 

    """Create horizontal line separator""" 

    from reportlab.platypus import Table 

    line = Table([['']], colWidths=[6.5*inch]) 

    line.setStyle([ 

        ('LINEABOVE', (0,0), (-1,0), 1, colors.black), 

    ]) 

    return line 

def generate_unique_id(): 
"""Generate unique verification ID""" 
import uuid 
return str(uuid.uuid4())[:8].upper() 

text 



 

--- 

 

## 6.5 Document Approval System 

 

### **6.5.1 Approval Request Creation** 

 

**User Story:** 

> As a user, I want to request digital signatures/approvals from multiple approvers with defined 
workflow. 

 

**Functional Requirements:** 

 

| **Requirement ID** | **Description** | **Priority** | 

|--------------------|-----------------|--------------| 

| APPR-RC-001 | User selects document from File Manager for approval | P0 | 

| APPR-RC-002 | Only blockchain-uploaded documents can be sent for approval | P0 | 

| APPR-RC-003 | User can select multiple approvers | P0 | 

| APPR-RC-004 | User assigns role/designation to each approver (HOD, Principal, etc.) | P0 | 

| APPR-RC-005 | User chooses approval type: Standard or Digital Sign | P0 | 

| APPR-RC-006 | For multiple approvers, user selects workflow: Sequential or Parallel | P0 | 

| APPR-RC-007 | For sequential workflow, user defines approval order | P0 | 

| APPR-RC-008 | User can add approval request message/purpose | P1 | 

| APPR-RC-009 | User can set deadline for approval | P2 | 

| APPR-RC-010 | System validates approver wallet addresses | P0 | 

| APPR-RC-011 | Approval request recorded on blockchain | P0 | 

| APPR-RC-012 | Approvers receive email notification | P0 | 

| APPR-RC-013 | Approval request appears in approvers' dashboard | P0 | 

| APPR-RC-014 | Requester can track approval status in real-time | P0 | 

 

**Approval Types:** 



 

| **Type** | **Description** | **Blockchain Action** | 

|----------|-----------------|----------------------| 

| **Standard Approval** | Simple approval without signature | Updates document status | 

| **Digital Sign** | Approval with cryptographic signature | Signs document hash with wallet | 

 

**Workflow Types:** 

 

| **Type** | **Description** | **Use Case** | 

|----------|-----------------|--------------| 

| **Sequential** | Approvers review in specific order | Hierarchical approval (HOD → Principal) | 

| **Parallel** | All approvers can review simultaneously | Committee approval | 

 

**API Endpoints:** 

POST /api/approvals/requests 
Headers: Authorization: Bearer <token> 

Request Body: 
{ 
"documentId": "DOC-002", 
"approvalType": "digital_sign", 
"workflowType": "sequential", 
"approvers": [ 
{ 
"userId": "USER-003", 
"walletAddress": "0xABC...", 
"role": "HOD", 
"sequence": 1 
}, 
{ 
"userId": "USER-001", 
"walletAddress": "0xDEF...", 
"role": "Principal", 
"sequence": 2 
} 
], 
"message": "Please review and approve this bonafide certificate", 
"deadline": "2024-01-25T23:59:59Z" 
} 



Response: 
{ 
"success": true, 
"data": { 
"approvalRequestId": "APPR-001", 
"transactionHash": "0x123abc...", 
"blockNumber": 12345680, 
"status": "pending", 
"nextApprover": { 
"userId": "USER-003", 
"name": "Dr. HOD", 
"role": "HOD" 
}, 
"createdAt": "2024-01-20T10:30:00Z" 
} 
} 

GET /api/approvals/my-requests 
Headers: Authorization: Bearer <token> 
Query: ?status=pending&page=1&limit=20 

Response: 
{ 
"success": true, 
"data": { 
"requests": [ 
{ 
"approvalRequestId": "APPR-001", 
"document": { 
"documentId": "DOC-002", 
"fileName": "Bonafide_Certificate.pdf", 
"ipfsHash": "QmXYZ..." 
}, 
"approvalType": "digital_sign", 
"workflowType": "sequential", 
"status": "pending", 
"currentStep": 1, 
"totalSteps": 2, 
"approvers": [ 
{ 
"userId": "USER-003", 
"name": "Dr. HOD", 
"role": "HOD", 
"status": "pending", 
"sequence": 1 
}, 



{ 
"userId": "USER-001", 
"name": "Dr. Principal", 
"role": "Principal", 
"status": "pending", 
"sequence": 2 
} 
], 
"createdAt": "2024-01-20T10:30:00Z", 
"deadline": "2024-01-25T23:59:59Z" 
} 
], 
"summary": { 
"pending": 5, 
"approved": 12, 
"rejected": 2 
} 
} 
} 

text 

 

**Database Schema:** 

 

```sql 

CREATE TABLE approval_requests ( 

    id SERIAL PRIMARY KEY, 

    approval_request_id VARCHAR(50) UNIQUE NOT NULL, 

    document_id INTEGER REFERENCES documents(id), 

    requester_id INTEGER REFERENCES users(id), 

    approval_type VARCHAR(20) NOT NULL, -- 'standard', 'digital_sign' 

    workflow_type VARCHAR(20) NOT NULL, -- 'sequential', 'parallel' 

    status VARCHAR(20) DEFAULT 'pending', -- 'pending', 'approved', 'rejected', 'cancelled' 

    message TEXT, 

    deadline TIMESTAMP, 

    transaction_hash VARCHAR(66), 

    block_number BIGINT, 

    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, 



    completed_at TIMESTAMP 

); 

 

CREATE TABLE approval_steps ( 

    id SERIAL PRIMARY KEY, 

    approval_request_id INTEGER REFERENCES approval_requests(id), 

    approver_id INTEGER REFERENCES users(id), 

    approver_wallet_address VARCHAR(42) NOT NULL, 

    approver_role VARCHAR(100), -- 'HOD', 'Principal', etc. 

    sequence INTEGER, -- For sequential workflow 

    status VARCHAR(20) DEFAULT 'pending', -- 'pending', 'approved', 'rejected' 

    action_taken_at TIMESTAMP, 

    comments TEXT, 

    signature_hash VARCHAR(132), -- Digital signature 

    transaction_hash VARCHAR(66), 

    UNIQUE(approval_request_id, approver_id) 

); 

 

CREATE INDEX idx_approval_requests_status ON approval_requests(status, created_at DESC); 

CREATE INDEX idx_approval_steps_approver ON approval_steps(approver_id, status); 

Smart Contract - Approval System: 

solidity 

// contracts/ApprovalWorkflow.sol 

// SPDX-License-Identifier: MIT 

pragma solidity ^0.8.20; 

 

contract ApprovalWorkflow { 

    struct ApprovalRequest { 

        bytes32 requestId; 

        bytes32 documentId; 

        address requester; 



        string approvalType; 

        string workflowType; 

        uint256 totalApprovers; 

        uint256 approvedCount; 

        uint256 rejectedCount; 

        string status; 

        uint256 createdAt; 

    } 

     

    struct ApprovalStep { 

        address approver; 

        string role; 

        uint256 sequence; 

        string status; 

        bytes signature; 

        uint256 timestamp; 

    } 

     

    mapping(bytes32 => ApprovalRequest) public approvalRequests; 

    mapping(bytes32 => ApprovalStep[]) public approvalSteps; 

     

    event ApprovalRequestCreated( 

        bytes32 indexed requestId, 

        bytes32 indexed documentId, 

        address indexed requester, 

        uint256 timestamp 

    ); 

     

    event ApprovalActionTaken( 

        bytes32 indexed requestId, 

        address indexed approver, 



        string action, 

        uint256 timestamp 

    ); 

     

    event ApprovalCompleted( 

        bytes32 indexed requestId, 

        string finalStatus, 

        uint256 timestamp 

    ); 

     

    function createApprovalRequest( 

        bytes32 _documentId, 

        string memory _approvalType, 

        string memory _workflowType, 

        address[] memory _approvers, 

        string[] memory _roles, 

        uint256[] memory _sequences 

    ) public returns (bytes32) { 

        require(_approvers.length > 0, "At least one approver required"); 

        require(_approvers.length == _roles.length, "Mismatched approvers and roles"); 

         

        bytes32 requestId = keccak256( 

            abi.encodePacked( 

                _documentId, 

                msg.sender, 

                block.timestamp 

            ) 

        ); 

         

        approvalRequests[requestId] = ApprovalRequest({ 

            requestId: requestId, 



            documentId: _documentId, 

            requester: msg.sender, 

            approvalType: _approvalType, 

            workflowType: _workflowType, 

            totalApprovers: _approvers.length, 

            approvedCount: 0, 

            rejectedCount: 0, 

            status: "pending", 

            createdAt: block.timestamp 

        }); 

         

        // Create approval steps 

        for (uint i = 0; i < _approvers.length; i++) { 

            approvalSteps[requestId].push(ApprovalStep({ 

                approver: _approvers[i], 

                role: _roles[i], 

                sequence: _sequences[i], 

                status: "pending", 

                signature: "", 

                timestamp: 0 

            })); 

        } 

         

        emit ApprovalRequestCreated(requestId, _documentId, msg.sender, block.timestamp); 

         

        return requestId; 

    } 

     

    function approveDocument( 

        bytes32 _requestId, 

        bytes memory _signature 



    ) public { 

        ApprovalRequest storage request = approvalRequests[_requestId]; 

        require(bytes(request.status).length > 0, "Request not found"); 

        require(keccak256(bytes(request.status)) == keccak256(bytes("pending")), "Request 

not pending"); 

text 

    // Find approver step 

    ApprovalStep[] storage steps = approvalSteps[_requestId]; 

    bool found = false; 

    uint256 approverIndex; 

     

    for (uint i = 0; i < steps.length; i++) { 

        if (steps[i].approver == msg.sender) { 

            found = true; 

            approverIndex = i; 

            break; 

        } 

    } 

     

    require(found, "Not authorized to approve"); 

    require( 

        keccak256(bytes(steps[approverIndex].status)) == keccak256(bytes("pending")), 

        "Already processed" 

    ); 

     

    // For sequential workflow, check if previous approvals are done 

    if (keccak256(bytes(request.workflowType)) == keccak256(bytes("sequential"))) { 

        for (uint i = 0; i < approverIndex; i++) { 

            require( 

                keccak256(bytes(steps[i].status)) == keccak256(bytes("approved")), 

                "Previous approvals pending" 



            ); 

        } 

    } 

     

    // Update step 

    steps[approverIndex].status = "approved"; 

    steps[approverIndex].signature = _signature; 

    steps[approverIndex].timestamp = block.timestamp; 

     

    request.approvedCount++; 

     

    emit ApprovalActionTaken(_requestId, msg.sender, "approved", block.timestamp); 

     

    // Check if all approvals completed 

    if (request.approvedCount == request.totalApprovers) { 

        request.status = "approved"; 

        emit ApprovalCompleted(_requestId, "approved", block.timestamp); 

    } 

} 

 

function rejectDocument( 

    bytes32 _requestId, 

    string memory _reason 

) public { 

    ApprovalRequest storage request = approvalRequests[_requestId]; 

    require(bytes(request.status).length > 0, "Request not found"); 

    require(keccak256(bytes(request.status)) == keccak256(bytes("pending")), "Request not pending"); 

     

    // Find approver step 

    ApprovalStep[] storage steps = approvalSteps[_requestId]; 

    bool found = false; 



    uint256 approverIndex; 

     

    for (uint i = 0; i < steps.length; i++) { 

        if (steps[i].approver == msg.sender) { 

            found = true; 

            approverIndex = i; 

            break; 

        } 

    } 

     

    require(found, "Not authorized to reject"); 

    require( 

        keccak256(bytes(steps[approverIndex].status)) == keccak256(bytes("pending")), 

        "Already processed" 

    ); 

     

    // Update step 

    steps[approverIndex].status = "rejected"; 

    steps[approverIndex].timestamp = block.timestamp; 

     

    request.rejectedCount++; 

    request.status = "rejected"; // One rejection fails entire request 

     

    emit ApprovalActionTaken(_requestId, msg.sender, "rejected", block.timestamp); 

    emit ApprovalCompleted(_requestId, "rejected", block.timestamp); 

} 

 

function getApprovalRequest(bytes32 _requestId) public view returns ( 

    bytes32 documentId, 

    address requester, 

    string memory approvalType, 



    string memory status, 

    uint256 approvedCount, 

    uint256 totalApprovers 

) { 

    ApprovalRequest memory request = approvalRequests[_requestId]; 

    return ( 

        request.documentId, 

        request.requester, 

        request.approvalType, 

        request.status, 

        request.approvedCount, 

        request.totalApprovers 

    ); 

} 

 

function getApprovalSteps(bytes32 _requestId) public view returns (ApprovalStep[] memory) { 

    return approvalSteps[_requestId]; 

} 

} 

text 

 

--- 

 

### **6.5.2 Approval Processing** 

 

**User Story:** 

> As an approver, I want to review documents and approve/reject them with digital signatures. 

 

**Functional Requirements:** 

 

| **Requirement ID** | **Description** | **Priority** | 



|--------------------|-----------------|--------------| 

| APPR-PR-001 | Approver sees pending approval requests in "Requests Received" | P0 | 

| APPR-PR-002 | Approver can filter requests by status (pending/approved/rejected) | P1 | 

| APPR-PR-003 | Clicking request opens detailed approval view | P0 | 

| APPR-PR-004 | Approval view shows: document info, requester details, blockchain status | P0 | 

| APPR-PR-005 | Approver can preview document inline | P0 | 

| APPR-PR-006 | Approver can download document | P0 | 

| APPR-PR-007 | For sequential workflow, approver sees which approvals are pending | P0 | 

| APPR-PR-008 | For digital sign, approver clicks "Sign & Approve" button | P0 | 

| APPR-PR-009 | MetaMask prompts for transaction signature | P0 | 

| APPR-PR-010 | System generates new document version with signature | P0 | 

| APPR-PR-011 | New version includes QR code with approval data | P0 | 

| APPR-PR-012 | Approver can reject with reason/comments | P0 | 

| APPR-PR-013 | Rejection immediately fails the entire request | P0 | 

| APPR-PR-014 | Requester receives notification on approval/rejection | P0 | 

| APPR-PR-015 | Next approver (if sequential) receives notification | P0 | 

| APPR-PR-016 | Final approved document stored in blockchain | P0 | 

 

**API Endpoints:** 

GET /api/approvals/received 
Headers: Authorization: Bearer <token> 
Query: ?status=pending&page=1&limit=20 

Response: 
{ 
"success": true, 
"data": { 
"requests": [ 
{ 
"approvalRequestId": "APPR-001", 
"document": { 
"documentId": "DOC-002", 
"fileName": "Bonafide_Certificate.pdf", 
"fileSize": 2048000, 
"ipfsHash": "QmXYZ...", 
"currentVersion": 1 
}, 



"requester": { 
"userId": "USER-005", 
"name": "Student Name", 
"email": "student@abc.edu", 
"department": "Computer Science" 
}, 
"approvalType": "digital_sign", 
"workflowType": "sequential", 
"myRole": "HOD", 
"mySequence": 1, 
"myStatus": "pending", 
"overallStatus": "pending", 
"currentStep": 1, 
"totalSteps": 2, 
"message": "Please approve my bonafide certificate", 
"deadline": "2024-01-25T23:59:59Z", 
"createdAt": "2024-01-20T10:30:00Z", 
"otherApprovers": [ 
{ 
"name": "Dr. Principal", 
"role": "Principal", 
"sequence": 2, 
"status": "pending" 
} 
] 
} 
], 
"summary": { 
"pending": 8, 
"approved": 25, 
"rejected": 3 
} 
} 
} 

GET /api/approvals/requests/:requestId/details 
Headers: Authorization: Bearer <token> 

Response: 
{ 
"success": true, 
"data": { 
"approvalRequest": { 
"approvalRequestId": "APPR-001", 
"document": { 
"documentId": "DOC-002", 



"fileName": "Bonafide_Certificate.pdf", 
"ipfsHash": "QmXYZ...", 
"previewUrl": "https://gateway.pinata.cloud/ipfs/QmXYZ...", 
"metadata": { 
"uploadedAt": "2024-01-20T09:00:00Z", 
"transactionHash": "0xabc...", 
"blockNumber": 12345680 
} 
}, 
"requester": { 
"userId": "USER-005", 
"name": "Student Name", 
"email": "student@abc.edu", 
"phone": "+1234567890" 
}, 
"blockchainStatus": { 
"documentExists": true, 
"owner": "0xABC...", 
"verificationHash": "0x123...", 
"approvalRequestHash": "0x456..." 
}, 
"workflow": { 
"type": "sequential", 
"currentStep": 1, 
"totalSteps": 2, 
"steps": [ 
{ 
"approver": { 
"userId": "USER-003", 
"name": "Dr. HOD", 
"walletAddress": "0xHOD..." 
}, 
"role": "HOD", 
"sequence": 1, 
"status": "pending", 
"isCurrentUser": true 
}, 
{ 
"approver": { 
"userId": "USER-001", 
"name": "Dr. Principal", 
"walletAddress": "0xPRIN..." 
}, 
"role": "Principal", 
"sequence": 2, 



"status": "pending", 
"isCurrentUser": false 
} 
] 
} 
} 
} 
} 

POST /api/approvals/requests/:requestId/approve 
Headers: Authorization: Bearer <token> 

Request Body: 
{ 
"signature": "0x...", // From MetaMask 
"comments": "Approved after verification" 
} 

Response: 
{ 
"success": true, 
"message": "Document approved successfully", 
"data": { 
"transactionHash": "0xdef...", 
"blockNumber": 12345681, 
"newDocumentVersion": { 
"versionNumber": 2, 
"ipfsHash": "QmNEW...", 
"signatureAdded": true 
}, 
"nextApprover": { 
"userId": "USER-001", 
"name": "Dr. Principal" 
} 
} 
} 

POST /api/approvals/requests/:requestId/reject 
Headers: Authorization: Bearer <token> 

Request Body: 
{ 
"reason": "Documents incomplete, missing student ID proof" 
} 

Response: 
{ 
"success": true, 



"message": "Document rejected", 
"data": { 
"transactionHash": "0xghi...", 
"blockNumber": 12345681, 
"notifiedRequester": true 
} 
} 

text 

 

**React Component - Approval View:** 

 

```jsx 

// components/approval/ApprovalView.jsx 

import { useState, useEffect } from 'react'; 

import {  

  FileText, User, Clock, CheckCircle, XCircle,  

  Download, Eye, AlertCircle  

} from 'lucide-react'; 

import {  

  getApprovalDetails,  

  approveDocument,  

  rejectDocument  

} from '../../services/approvalService'; 

import { useWallet } from '../../hooks/useWallet'; 

import DocumentPreview from '../file-manager/DocumentPreview'; 

import { toast } from 'react-toastify'; 

 

export default function ApprovalView({ requestId, onClose }) { 

  const [approvalData, setApprovalData] = useState(null); 

  const [loading, setLoading] = useState(true); 

  const [showPreview, setShowPreview] = useState(false); 

  const [showRejectModal, setShowRejectModal] = useState(false); 

  const [rejectReason, setRejectReason] = useState(''); 



  const [processing, setProcessing] = useState(false); 

  const { signer, walletAddress } = useWallet(); 

 

  useEffect(() => { 

    loadApprovalDetails(); 

  }, [requestId]); 

 

  const loadApprovalDetails = async () => { 

    try { 

      const response = await getApprovalDetails(requestId); 

      setApprovalData(response.data.approvalRequest); 

    } catch (error) { 

      toast.error('Failed to load approval details'); 

    } finally { 

      setLoading(false); 

    } 

  }; 

 

  const handleApprove = async () => { 

    if (!signer) { 

      toast.error('Please connect your wallet'); 

      return; 

    } 

 

    const confirmed = window.confirm( 

      'Are you sure you want to approve this document? This action will be recorded on blockchain.' 

    ); 

 

    if (!confirmed) return; 

 

    setProcessing(true); 



 

    try { 

      // Sign the document hash with MetaMask 

      const documentHash = approvalData.blockchainStatus.verificationHash; 

      const signature = await signer.signMessage(documentHash); 

 

      // Submit approval 

      const response = await approveDocument(requestId, { 

        signature, 

        comments: '' 

      }); 

 

      toast.success('Document approved successfully!'); 

       

      // Show transaction details 

      toast.info( 

        `Transaction Hash: ${response.data.transactionHash.substring(0, 10)}...`, 

        { autoClose: 5000 } 

      ); 

 

      // Close modal or refresh list 

      onClose(); 

    } catch (error) { 

      console.error('Approval error:', error); 

      toast.error('Failed to approve document'); 

    } finally { 

      setProcessing(false); 

    } 

  }; 

 

  const handleReject = async () => { 



    if (!rejectReason.trim()) { 

      toast.error('Please provide a reason for rejection'); 

      return; 

    } 

 

    setProcessing(true); 

 

    try { 

      await rejectDocument(requestId, { 

        reason: rejectReason 

      }); 

 

      toast.success('Document rejected'); 

      onClose(); 

    } catch (error) { 

      toast.error('Failed to reject document'); 

    } finally { 

      setProcessing(false); 

    } 

  }; 

 

  const getStatusBadge = (status) => { 

    const styles = { 

      pending: 'bg-yellow-100 text-yellow-800', 

      approved: 'bg-green-100 text-green-800', 

      rejected: 'bg-red-100 text-red-800' 

    }; 

 

    return ( 

      <span className={`status-badge ${styles[status]}`}> 

        {status.toUpperCase()} 



      </span> 

    ); 

  }; 

 

  if (loading) { 

    return <div className="loading">Loading approval details...</div>; 

  } 

 

  const { document: doc, requester, workflow, blockchainStatus } = approvalData; 

 

  return ( 

    <div className="approval-view-modal"> 

      <div className="modal-header"> 

        <h2>Document Approval Request</h2> 

        <button onClick={onClose} className="close-btn">×</button> 

      </div> 

 

      <div className="approval-content"> 

        {/* Document Information */} 

        <section className="info-section"> 

          <h3><FileText size={20} /> Document Information</h3> 

          <div className="info-grid"> 

            <div className="info-item"> 

              <label>File Name:</label> 

              <span>{doc.fileName}</span> 

            </div> 

            <div className="info-item"> 

              <label>File Size:</label> 

              <span>{(doc.fileSize / 1024).toFixed(2)} KB</span> 

            </div> 

            <div className="info-item"> 



              <label>IPFS Hash:</label> 

              <span className="monospace">{doc.ipfsHash.substring(0, 20)}...</span> 

            </div> 

            <div className="info-item"> 

              <label>Uploaded:</label> 

              <span>{new Date(doc.metadata.uploadedAt).toLocaleString()}</span> 

            </div> 

          </div> 

 

          <div className="document-actions"> 

            <button onClick={() => setShowPreview(true)} className="btn-secondary"> 

              <Eye size={18} /> 

              Preview Document 

             

</button> <a href={doc.previewUrl} download={doc.fileName} className="btn-secondary" > 
<Download size={18} /> Download </a> </div> </section> 

text 

    {/* Requester Information */} 

    <section className="info-section"> 

      <h3><User size={20} /> Requester Information</h3> 

      <div className="info-grid"> 

        <div className="info-item"> 

          <label>Name:</label> 

          <span>{requester.name}</span> 

        </div> 

        <div className="info-item"> 

          <label>Email:</label> 

          <span>{requester.email}</span> 

        </div> 

        <div className="info-item"> 

          <label>Phone:</label> 



          <span>{requester.phone}</span> 

        </div> 

        <div className="info-item"> 

          <label>Department:</label> 

          <span>{requester.department}</span> 

        </div> 

      </div> 

    </section> 

 

    {/* Blockchain Status */} 

    <section className="info-section"> 

      <h3><CheckCircle size={20} /> Blockchain Status</h3> 

      <div className="blockchain-info"> 

        <div className="status-item"> 

          <span className="status-label">Document Verified:</span> 

          <span className={blockchainStatus.documentExists ? 'text-green-600' : 'text-red-600'}> 

            {blockchainStatus.documentExists ? '✓ Yes' : '✗ No'} 

          </span> 

        </div> 

        <div className="status-item"> 

          <span className="status-label">Owner Address:</span> 

          <span className="monospace">{blockchainStatus.owner}</span> 

        </div> 

        <div className="status-item"> 

          <span className="status-label">Document Hash:</span> 

          <span className="monospace">{blockchainStatus.verificationHash.substring(0, 20)}...</span> 

        </div> 

      </div> 

    </section> 

 

    {/* Approval Workflow */} 



    <section className="info-section"> 

      <h3><Clock size={20} /> Approval Workflow</h3> 

      <div className="workflow-info"> 

        <div className="workflow-header"> 

          <span>Type: <strong>{workflow.type}</strong></span> 

          <span>Progress: <strong>{workflow.currentStep}/{workflow.totalSteps}</strong></span> 

        </div> 

 

        <div className="workflow-steps"> 

          {workflow.steps.map((step, index) => ( 

            <div  

              key={index}  

              className={`workflow-step ${step.isCurrentUser ? 'current-user' : ''} ${step.status}`} 

            > 

              <div className="step-number">{step.sequence}</div> 

              <div className="step-details"> 

                <div className="step-header"> 

                  <span className="step-role">{step.role}</span> 

                  {getStatusBadge(step.status)} 

                </div> 

                <div className="step-approver"> 

                  {step.approver.name} 

                  {step.isCurrentUser && <span className="you-badge">YOU</span>} 

                </div> 

                {step.status === 'approved' && step.approvedAt && ( 

                  <div className="step-timestamp"> 

                    Approved: {new Date(step.approvedAt).toLocaleString()} 

                  </div> 

                )} 

                {step.status === 'rejected' && step.rejectedAt && ( 

                  <div className="step-timestamp"> 



                    Rejected: {new Date(step.rejectedAt).toLocaleString()} 

                    {step.comments && <p className="rejection-reason">Reason: {step.comments}</p>} 

                  </div> 

                )} 

              </div> 

              {step.status === 'approved' && ( 

                <CheckCircle size={24} className="status-icon approved" /> 

              )} 

              {step.status === 'rejected' && ( 

                <XCircle size={24} className="status-icon rejected" /> 

              )} 

              {step.status === 'pending' && ( 

                <Clock size={24} className="status-icon pending" /> 

              )} 

            </div> 

          ))} 

        </div> 

      </div> 

    </section> 

 

    {/* Request Message */} 

    {approvalData.message && ( 

      <section className="info-section"> 

        <h3><AlertCircle size={20} /> Request Message</h3> 

        <div className="message-box"> 

          <p>{approvalData.message}</p> 

        </div> 

      </section> 

    )} 

 

    {/* Action Buttons */} 



    {workflow.steps.find(s => s.isCurrentUser)?.status === 'pending' && ( 

      <div className="approval-actions"> 

        <button 

          onClick={() => setShowRejectModal(true)} 

          className="btn-danger" 

          disabled={processing} 

        > 

          <XCircle size={18} /> 

          Reject 

        </button> 

        <button 

          onClick={handleApprove} 

          className="btn-primary" 

          disabled={processing} 

        > 

          {processing ? ( 

            'Processing...' 

          ) : ( 

            <> 

              <CheckCircle size={18} /> 

              {approvalData.approvalType === 'digital_sign' ? 'Sign & Approve' : 'Approve'} 

            </> 

          )} 

        </button> 

      </div> 

    )} 

  </div> 

 

  {/* Document Preview Modal */} 

  {showPreview && ( 

    <DocumentPreview 



      ipfsHash={doc.ipfsHash} 

      fileName={doc.fileName} 

      onClose={() => setShowPreview(false)} 

    /> 

  )} 

 

  {/* Reject Modal */} 

  {showRejectModal && ( 

    <div className="reject-modal"> 

      <div className="reject-modal-content"> 

        <h3>Reject Document</h3> 

        <p>Please provide a reason for rejection:</p> 

        <textarea 

          value={rejectReason} 

          onChange={(e) => setRejectReason(e.target.value)} 

          placeholder="Enter reason..." 

          rows={4} 

          className="reject-textarea" 

        /> 

        <div className="reject-actions"> 

          <button 

            onClick={() => setShowRejectModal(false)} 

            className="btn-secondary" 

          > 

            Cancel 

          </button> 

          <button 

            onClick={handleReject} 

            className="btn-danger" 

            disabled={processing || !rejectReason.trim()} 

          > 



            {processing ? 'Processing...' : 'Confirm Rejection'} 

          </button> 

        </div> 

      </div> 

    </div> 

  )} 

</div> 

); 
} 

text 

 

--- 

 

### **6.5.3 Document Version Generation with Signatures** 

 

**User Story:** 

> As the system, I want to automatically generate a new document version with approval signatures 
and QR codes. 

 

**Functional Requirements:** 

 

| **Requirement ID** | **Description** | **Priority** | 

|--------------------|-----------------|--------------| 

| APPR-VG-001 | System generates new PDF version after each approval | P0 | 

| APPR-VG-002 | New version includes original content plus signature section | P0 | 

| APPR-VG-003 | Signature section shows: approver name, role, signature hash, timestamp | P0 | 

| APPR-VG-004 | For sequential workflow, signatures added incrementally | P0 | 

| APPR-VG-005 | Final version includes all required signatures | P0 | 

| APPR-VG-006 | New version uploaded to IPFS automatically | P0 | 

| APPR-VG-007 | New IPFS hash recorded on blockchain | P0 | 

| APPR-VG-008 | QR code updated with latest approval data | P0 | 



| APPR-VG-009 | QR code contains: document ID, all approvers, timestamps, blockchain verification 
URL | P0 | 

| APPR-VG-010 | Original document version preserved | P0 | 

| APPR-VG-011 | User can view all versions in version history | P0 | 

 

**Backend Service - Document Versioning:** 

 

```python 

# backend/app/services/approval_versioning_service.py 

from reportlab.lib.pagesizes import A4 

from reportlab.pdfgen import canvas 

from reportlab.lib.units import inch 

from PyPDF2 import PdfReader, PdfWriter 

import qrcode 

import json 

import io 

from datetime import datetime 

 

class ApprovalVersioningService: 

    def __init__(self, ipfs_service, blockchain_service): 

        self.ipfs_service = ipfs_service 

        self.blockchain_service = blockchain_service 

     

    def create_approved_version( 

        self,  

        original_ipfs_hash,  

        approval_data, 

        document_id 

    ): 

        """ 

        Create new document version with approval signatures 



         

        Args: 

            original_ipfs_hash: IPFS hash of original document 

            approval_data: Dict containing approval information 

            document_id: Document ID 

         

        Returns: 

            Dict with new IPFS hash and version info 

        """ 

        # Download original PDF from IPFS 

        original_pdf = self.ipfs_service.download_file(original_ipfs_hash) 

         

        # Create signature page 

        signature_pdf = self._create_signature_page(approval_data) 

         

        # Merge original + signature page 

        merged_pdf = self._merge_pdfs(original_pdf, signature_pdf) 

         

        # Add QR code to footer 

        final_pdf = self._add_qr_code(merged_pdf, approval_data, document_id) 

         

        # Upload to IPFS 

        new_ipfs_hash = self.ipfs_service.upload_buffer( 

            final_pdf, 

            f"{document_id}_v{approval_data['version']}.pdf" 

        ) 

         

        # Update blockchain 

        tx_hash = self.blockchain_service.update_document_version( 

            document_id, 

            new_ipfs_hash, 



            approval_data['version'] 

        ) 

         

        return { 

            'ipfsHash': new_ipfs_hash, 

            'version': approval_data['version'], 

            'transactionHash': tx_hash, 

            'timestamp': datetime.utcnow().isoformat() 

        } 

     

    def _create_signature_page(self, approval_data): 

        """Create PDF page with approval signatures""" 

        buffer = io.BytesIO() 

        c = canvas.Canvas(buffer, pagesize=A4) 

        width, height = A4 

         

        # Title 

        c.setFont("Helvetica-Bold", 14) 

        c.drawString(1*inch, height - 1*inch, "APPROVAL SIGNATURES") 

         

        # Draw horizontal line 

        c.line(1*inch, height - 1.2*inch, width - 1*inch, height - 1.2*inch) 

         

        y_position = height - 1.5*inch 

         

        # Add each approval 

        for i, approval in enumerate(approval_data['approvals']): 

            # Approver info 

            c.setFont("Helvetica-Bold", 12) 

            c.drawString(1*inch, y_position, f"{i+1}. {approval['role']}") 

             



            c.setFont("Helvetica", 10) 

            y_position -= 0.3*inch 

            c.drawString(1.2*inch, y_position, f"Name: {approval['name']}") 

             

            y_position -= 0.2*inch 

            c.drawString(1.2*inch, y_position, f"Date: {approval['timestamp']}") 

             

            y_position -= 0.2*inch 

            c.drawString(1.2*inch, y_position, f"Signature: {approval['signatureHash'][:32]}...") 

             

            # Digital signature indicator 

            c.setFillColorRGB(0, 0.5, 0) 

            c.setFont("Helvetica-Bold", 9) 

            y_position -= 0.25*inch 

            c.drawString(1.2*inch, y_position, "✓ DIGITALLY SIGNED ON BLOCKCHAIN") 

             

            # Reset color 

            c.setFillColorRGB(0, 0, 0) 

             

            y_position -= 0.5*inch 

             

            if y_position < 2*inch: 

                c.showPage() 

                y_position = height - 1*inch 

         

        # Footer 

        c.setFont("Helvetica-Oblique", 8) 

        c.drawString( 

            1*inch,  

            0.5*inch,  

            "This document has been digitally signed and verified on Ethereum blockchain." 



        ) 

         

        c.save() 

        buffer.seek(0) 

        return buffer 

     

    def _merge_pdfs(self, original_buffer, signature_buffer): 

        """Merge original PDF with signature page""" 

        pdf_writer = PdfWriter() 

         

        # Add original pages 

        original_reader = PdfReader(original_buffer) 

        for page in original_reader.pages: 

            pdf_writer.add_page(page) 

         

        # Add signature page 

        signature_reader = PdfReader(signature_buffer) 

        for page in signature_reader.pages: 

            pdf_writer.add_page(page) 

         

        # Write to buffer 

        output_buffer = io.BytesIO() 

        pdf_writer.write(output_buffer) 

        output_buffer.seek(0) 

         

        return output_buffer 

     

    def _add_qr_code(self, pdf_buffer, approval_data, document_id): 

        """Add QR code to document footer""" 

        # Generate QR code data 

        qr_data = { 



            'documentId': document_id, 

            'version': approval_data['version'], 

            'approvals': [ 

                { 

                    'role': a['role'], 

                    'name': a['name'], 

                    'timestamp': a['timestamp'] 

                } 

                for a in approval_data['approvals'] 

            ], 

            'verifyUrl': f"https://docuchain.app/verify/{document_id}", 

            'blockchainHash': approval_data.get('blockchainHash', '') 

        } 

         

        # Create QR code 

        qr = qrcode.QRCode(version=1, box_size=10, border=2) 

        qr.add_data(json.dumps(qr_data)) 

        qr.make(fit=True) 

        qr_img = qr.make_image(fill_color="black", back_color="white") 

         

        # Save QR to buffer 

        qr_buffer = io.BytesIO() 

        qr_img.save(qr_buffer, format='PNG') 

        qr_buffer.seek(0) 

         

        # Add QR to PDF 

        pdf_reader = PdfReader(pdf_buffer) 

        pdf_writer = PdfWriter() 

         

        # Create QR overlay 

        qr_overlay = self._create_qr_overlay(qr_buffer) 



        qr_page = PdfReader(qr_overlay).pages[0] 

         

        # Add QR to last page 

        for i, page in enumerate(pdf_reader.pages): 

            if i == len(pdf_reader.pages) - 1: 

                page.merge_page(qr_page) 

            pdf_writer.add_page(page) 

         

        output_buffer = io.BytesIO() 

        pdf_writer.write(output_buffer) 

        output_buffer.seek(0) 

         

        return output_buffer 

     

    def _create_qr_overlay(self, qr_image_buffer): 

        """Create PDF overlay with QR code""" 

        buffer = io.BytesIO() 

        c = canvas.Canvas(buffer, pagesize=A4) 

        width, height = A4 

         

        # Draw QR code in bottom right 

        c.drawImage( 

            qr_image_buffer, 

x=width - 2inch, 
y=0.5inch, 
width=1.5inch, 
height=1.5inch, 
preserveAspectRatio=True, 
mask='auto' 
) 

text 

    # Add verification text 

    c.setFont("Helvetica", 7) 



    c.drawString( 

        width - 2*inch, 

        0.3*inch, 

        "Scan to verify" 

    ) 

     

    c.save() 

    buffer.seek(0) 

    return buffer 

text 

 

--- 

 

## 6.6 Admin Features 

 

### **6.6.1 User Management** 

 

**User Story:** 

> As an admin, I want to manage all user accounts in my institution. 

 

**Functional Requirements:** 

 

| **Requirement ID** | **Description** | **Priority** | 

|--------------------|-----------------|--------------| 

| ADMIN-UM-001 | Admin can view list of all users (students, faculty, staff) | P0 | 

| ADMIN-UM-002 | Admin can search users by name, unique ID, email | P0 | 

| ADMIN-UM-003 | Admin can filter users by role, department, section, status | P0 | 

| ADMIN-UM-004 | Admin can view detailed user profile | P0 | 

| ADMIN-UM-005 | Admin can edit user details | P0 | 

| ADMIN-UM-006 | Admin can activate/deactivate user accounts | P0 | 

| ADMIN-UM-007 | Admin can ban/unban users | P0 | 



| ADMIN-UM-008 | Admin can delete user accounts | P1 | 

| ADMIN-UM-009 | Admin can reset user passwords | P1 | 

| ADMIN-UM-010 | Admin can export user list (CSV/Excel) | P1 | 

| ADMIN-UM-011 | Admin can view user activity logs | P1 | 

| ADMIN-UM-012 | Admin can see user statistics (total users, active users, etc.) | P1 | 

| ADMIN-UM-013 | Admin can assign roles/permissions | P2 | 

 

**API Endpoints:** 

GET /api/admin/users 
Headers: Authorization: Bearer <token> 
Query: ?search=john&role=student&department=CS&status=active&page=1&limit=50 

Response: 
{ 
"success": true, 
"data": { 
"users": [ 
{ 
"userId": "USER-005", 
"uniqueId": "STU2024001", 
"firstName": "John", 
"lastName": "Doe", 
"email": "john@student.abc.edu", 
"phone": "+1234567890", 
"role": "student", 
"department": "Computer Science", 
"section": "A", 
"isActive": true, 
"isVerified": true, 
"walletAddress": "0xABC...", 
"joinedDate": "2024-01-10T00:00:00Z", 
"lastLogin": "2024-01-20T08:30:00Z" 
} 
], 
"pagination": { 
"currentPage": 1, 
"totalPages": 10, 
"totalUsers": 500, 
"usersPerPage": 50 
}, 
"statistics": { 
"totalUsers": 500, 



"activeUsers": 485, 
"inactiveUsers": 15, 
"students": 450, 
"faculty": 45, 
"admins": 5, 
"newThisWeek": 12 
} 
} 
} 

GET /api/admin/users/:userId 
Headers: Authorization: Bearer <token> 

Response: 
{ 
"success": true, 
"data": { 
"user": { 
"userId": "USER-005", 
"uniqueId": "STU2024001", 
"firstName": "John", 
"lastName": "Doe", 
"email": "john@student.abc.edu", 
"phone": "+1234567890", 
"role": "student", 
"department": { 
"departmentId": "DEPT-001", 
"name": "Computer Science" 
}, 
"section": { 
"sectionId": "SEC-001", 
"name": "Section A" 
}, 
"walletAddress": "0xABC...", 
"profileImage": "https://...", 
"isActive": true, 
"isVerified": true, 
"isBanned": false, 
"joinedDate": "2024-01-10T00:00:00Z", 
"lastLogin": "2024-01-20T08:30:00Z", 
"documentsCount": 15, 
"approvalsGiven": 8, 
"approvalsReceived": 12 
}, 
"activitySummary": { 
"totalLogins": 45, 



"documentsUploaded": 15, 
"documentsShared": 8, 
"messagesCount": 234 
} 
} 
} 

PUT /api/admin/users/:userId 
Headers: Authorization: Bearer <token> 

Request Body: 
{ 
"firstName": "John Updated", 
"lastName": "Doe", 
"phone": "+1234567890", 
"department": "DEPT-002", 
"section": "SEC-003" 
} 

Response: 
{ 
"success": true, 
"message": "User updated successfully" 
} 

POST /api/admin/users/:userId/toggle-status 
Headers: Authorization: Bearer <token> 

Request Body: 
{ 
"action": "deactivate" // or "activate", "ban", "unban" 
} 

Response: 
{ 
"success": true, 
"message": "User account deactivated", 
"data": { 
"userId": "USER-005", 
"isActive": false 
} 
} 

DELETE /api/admin/users/:userId 
Headers: Authorization: Bearer <token> 

Response: 
{ 
"success": true, 



"message": "User account deleted successfully" 
} 

GET /api/admin/users/export 
Headers: Authorization: Bearer <token> 
Query: ?format=csv&role=student&department=CS 

Response: CSV/Excel file download 

text 

 

**React Component - User Management:** 

 

```jsx 

// components/admin/UserManagement.jsx 

import { useState, useEffect } from 'react'; 

import {  

  Users, Search, Filter, Download, Edit,  

  Trash2, Ban, CheckCircle, XCircle  

} from 'lucide-react'; 

import {  

  getUsers,  

  updateUser,  

  toggleUserStatus, 

  deleteUser, 

  exportUsers  

} from '../../services/adminService'; 

import { toast } from 'react-toastify'; 

 

export default function UserManagement() { 

  const [users, setUsers] = useState([]); 

  const [statistics, setStatistics] = useState(null); 

  const [filters, setFilters] = useState({ 

    search: '', 

    role: 'all', 



    department: 'all', 

    status: 'all' 

  }); 

  const [currentPage, setCurrentPage] = useState(1); 

  const [loading, setLoading] = useState(true); 

  const [selectedUser, setSelectedUser] = useState(null); 

 

  useEffect(() => { 

    loadUsers(); 

  }, [filters, currentPage]); 

 

  const loadUsers = async () => { 

    try { 

      const response = await getUsers({ 

        ...filters, 

        page: currentPage, 

        limit: 50 

      }); 

      setUsers(response.data.users); 

      setStatistics(response.data.statistics); 

    } catch (error) { 

      toast.error('Failed to load users'); 

    } finally { 

      setLoading(false); 

    } 

  }; 

 

  const handleSearch = (e) => { 

    setFilters(prev => ({ ...prev, search: e.target.value })); 

    setCurrentPage(1); 

  }; 



 

  const handleFilterChange = (key, value) => { 

    setFilters(prev => ({ ...prev, [key]: value })); 

    setCurrentPage(1); 

  }; 

 

  const handleToggleStatus = async (userId, action) => { 

    const confirmMessage = { 

      deactivate: 'Are you sure you want to deactivate this user?', 

      activate: 'Are you sure you want to activate this user?', 

      ban: 'Are you sure you want to ban this user?', 

      unban: 'Are you sure you want to unban this user?' 

    }; 

 

    if (!confirm(confirmMessage[action])) return; 

 

    try { 

      await toggleUserStatus(userId, action); 

      toast.success(`User ${action}d successfully`); 

      loadUsers(); 

    } catch (error) { 

      toast.error(`Failed to ${action} user`); 

    } 

  }; 

 

  const handleDeleteUser = async (userId, userName) => { 

    if (!confirm(`Are you sure you want to delete user "${userName}"? This action cannot be undone.`)) 
{ 

      return; 

    } 

 



    try { 

      await deleteUser(userId); 

      toast.success('User deleted successfully'); 

      loadUsers(); 

    } catch (error) { 

      toast.error('Failed to delete user'); 

    } 

  }; 

 

  const handleExport = async () => { 

    try { 

      await exportUsers(filters); 

      toast.success('Users exported successfully'); 

    } catch (error) { 

      toast.error('Failed to export users'); 

    } 

  }; 

 

  return ( 

    <div className="user-management"> 

      {/* Header */} 

      <div className="management-header"> 

        <div className="header-left"> 

          <Users size={28} /> 

          <h2>User Management</h2> 

        </div> 

        <button onClick={handleExport} className="btn-secondary"> 

          <Download size={18} /> 

          Export Users 

        </button> 

      </div> 



 

      {/* Statistics Cards */} 

      {statistics && ( 

        <div className="statistics-grid"> 

          <div className="stat-card"> 

            <div className="stat-value">{statistics.totalUsers}</div> 

            <div className="stat-label">Total Users</div> 

          </div> 

          <div className="stat-card"> 

            <div className="stat-value text-green-600">{statistics.activeUsers}</div> 

            <div className="stat-label">Active Users</div> 

          </div> 

          <div className="stat-card"> 

            <div className="stat-value">{statistics.students}</div> 

            <div className="stat-label">Students</div> 

          </div> 

          <div className="stat-card"> 

            <div className="stat-value">{statistics.faculty}</div> 

            <div className="stat-label">Faculty</div> 

          </div> 

          <div className="stat-card"> 

            <div className="stat-value text-blue-600">{statistics.newThisWeek}</div> 

            <div className="stat-label">New This Week</div> 

          </div> 

        </div> 

      )} 

 

      {/* Filters */} 

      <div className="filters-section"> 

        <div className="search-box"> 

          <Search size={18} /> 



          <input 

            type="text" 

            placeholder="Search by name, email, or ID..." 

            value={filters.search} 

            onChange={handleSearch} 

          /> 

        </div> 

 

        <div className="filter-controls"> 

          <select 

            value={filters.role} 

            onChange={(e) => handleFilterChange('role', e.target.value)} 

          > 

            <option value="all">All Roles</option> 

            <option value="student">Students</option> 

            <option value="faculty">Faculty</option> 

            <option value="admin">Admins</option> 

          </select> 

 

          <select 

            value={filters.department} 

            onChange={(e) => handleFilterChange('department', e.target.value)} 

          > 

            <option value="all">All Departments</option> 

            <option value="CS">Computer Science</option> 

            <option value="EE">Electrical Engineering</option> 

            <option value="ME">Mechanical Engineering</option> 

          </select> 

 

          <select 

            value={filters.status} 



            onChange={(e) => handleFilterChange('status', e.target.value)} 

          > 

            <option value="all">All Status</option> 

            <option value="active">Active</option> 

            <option value="inactive">Inactive</option> 

            <option value="banned">Banned</option> 

          </select> 

        </div> 

      </div> 

 

      {/* Users Table */} 

      <div className="users-table-container"> 

        <table className="users-table"> 

          <thead> 

            <tr> 

              <th>User ID</th> 

              <th>Name</th> 

              <th>Email</th> 

              <th>Role</th> 

              <th>Department</th> 

              <th>Status</th> 

              <th>Last Login</th> 

              <th>Actions</th> 

            </tr> 

          </thead> 

          <tbody> 

            {loading ? ( 

              <tr> 

                <td colSpan="8" className="text-center">Loading...</td> 

              </tr> 

            ) : users.length === 0 ? ( 



              <tr> 

                <td colSpan="8" className="text-center">No users found</td> 

              </tr> 

            ) : ( 

              users.map(user => ( 

                <tr key={user.userId}> 

                  <td className="font-mono">{user.uniqueId}</td> 

                  <td> 

                    <div className="user-name-cell"> 

                      <div className="user-avatar"> 

                        {user.firstName.charAt(0)} 

                      </div> 

                      <span>{user.firstName} {user.lastName}</span> 

                    </div> 

                  </td> 

                  <td>{user.email}</td> 

                  <td> 

                    <span className={`role-badge ${user.role}`}> 

                      {user.role} 

                    </span> 

                  </td> 

                  <td>{user.department}</td> 

                  <td> 

                    {user.isActive ? ( 

                      <span className="status-badge active"> 

                        <CheckCircle size={14} /> Active 

                      </span> 

                    ) : ( 

                      <span className="status-badge inactive"> 

                        <XCircle size={14} /> Inactive 

                      </span> 



                    )} 

                    {user.isBanned && ( 

                      <span className="status-badge banned"> 

                        <Ban size={14} /> Banned 

                      </span> 

                    )} 

                  </td> 

                  <td> 

                    {user.lastLogin  

                      ? new Date(user.lastLogin).toLocaleDateString() 

                      : 'Never' 

                    } 

                  </td> 

                  <td> 

                    <div className="action-buttons"> 

                      <button 

                        onClick={() => setSelectedUser(user)} 

                        className="action-btn" 

                        title="View/Edit" 

                      > 

                        <Edit size={16} /> 

                      </button> 

                      <button 

                        onClick={() => handleToggleStatus( 

                          user.userId, 

                          user.isActive ? 'deactivate' : 'activate' 

                        )} 

                        className="action-btn" 

                        title={user.isActive ? 'Deactivate' : 'Activate'} 

                      > 

                        {user.isActive ? <XCircle size={16} /> : <CheckCircle size={16} />} 



                      </button> 

                      <button 

                        onClick={() => handleToggleStatus( 

                          user.userId, 

                          user.isBanned ? 'unban' : 'ban' 

                        )} 

                        className="action-btn" 

                        title={user.isBanned ? 'Unban' : 'Ban'} 

                      > 

                        <Ban size={16} /> 

                      </button> 

                      <button 

                        onClick={() => handleDeleteUser(user.userId, `${user.firstName} ${user.lastName}`)} 

                        className="action-btn danger" 

                        title="Delete" 

                      > 

<Trash2 size={16} /> </button> </div> </td> </tr> )) )} </tbody> </table> </div> 

text 

 

  {/* Pagination */} 

  <div className="pagination"> 

    <button 

      onClick={() => setCurrentPage(prev => Math.max(1, prev - 1))} 

      disabled={currentPage === 1} 

      className="pagination-btn" 

    > 

      Previous 

    </button> 

    <span className="pagination-info"> 

      Page {currentPage} of {Math.ceil(statistics?.totalUsers / 50) || 1} 

    </span> 



    <button 

      onClick={() => setCurrentPage(prev => prev + 1)} 

      disabled={currentPage >= Math.ceil(statistics?.totalUsers / 50)} 

      className="pagination-btn" 

    > 

      Next 

    </button> 

  </div> 

 

  {/* User Edit Modal */} 

  {selectedUser && ( 

    <UserEditModal 

      user={selectedUser} 

      onClose={() => setSelectedUser(null)} 

      onSave={() => { 

        loadUsers(); 

        setSelectedUser(null); 

      }} 

    /> 

  )} 

</div> 

); 

} 

 

text 

 

 

--- 

 

### **6.6.2 Account Request Management** 

 



**User Story:** 

> As an admin, I want to review and approve/reject user registration requests. 

 

**Functional Requirements:** 

 

| **Requirement ID** | **Description** | **Priority** | 

|--------------------|-----------------|--------------| 

| ADMIN-AR-001 | Admin sees list of pending registration requests | P0 | 

| ADMIN-AR-002 | Admin can filter requests by role, department, status | P0 | 

| ADMIN-AR-003 | Admin can search requests by name or email | P0 | 

| ADMIN-AR-004 | Admin can view full profile details of requester | P0 | 

| ADMIN-AR-005 | Admin can approve individual requests | P0 | 

| ADMIN-AR-006 | Admin can reject requests with reason | P0 | 

| ADMIN-AR-007 | Admin can bulk approve multiple requests | P1 | 

| ADMIN-AR-008 | Admin can bulk reject multiple requests | P1 | 

| ADMIN-AR-009 | Approved users receive email notification | P0 | 

| ADMIN-AR-010 | Rejected users receive email with reason | P0 | 

| ADMIN-AR-011 | Admin can view request submission date | P0 | 

| ADMIN-AR-012 | Admin can see approval/rejection history | P1 | 

 

**API Endpoints:** 

GET /api/admin/account-requests 

Headers: Authorization: Bearer <token> 

Query: ?status=pending&role=student&page=1&limit=20 

 

Response: 

{ 

"success": true, 

"data": { 

"requests": [ 

{ 



"requestId": "REQ-2024-001", 

"firstName": "Jane", 

"lastName": "Smith", 

"email": "jane@student.abc.edu", 

"phone": "+1234567890", 

"role": "student", 

"department": "Computer Science", 

"section": "B", 

"walletAddress": "0xDEF...", 

"studentDetails": { 

"studentId": "STU2024050", 

"year": "2024", 

"rollNumber": "CS050" 

}, 

"status": "pending", 

"submittedAt": "2024-01-20T09:00:00Z" 

} 

], 

"summary": { 

"pending": 15, 

"approved": 120, 

"rejected": 8 

}, 

"pagination": { 

"currentPage": 1, 

"totalPages": 2, 

"totalRequests": 15 

} 

} 

} 

 



GET /api/admin/account-requests/:requestId 

Headers: Authorization: Bearer <token> 

 

Response: 

{ 

"success": true, 

"data": { 

"request": { 

"requestId": "REQ-2024-001", 

"firstName": "Jane", 

"lastName": "Smith", 

"email": "jane@student.abc.edu", 

"phone": "+1234567890", 

"role": "student", 

"department": "Computer Science", 

"section": "B", 

"walletAddress": "0xDEF...", 

"profileImage": "https://...", 

"additionalData": { 

"studentId": "STU2024050", 

"year": "2024", 

"rollNumber": "CS050", 

"enrollmentDate": "2024-01-10" 

}, 

"status": "pending", 

"submittedAt": "2024-01-20T09:00:00Z", 

"institutionDetails": { 

"name": "ABC University", 

"uniqueId": "ABC-UNI-2024" 

} 

} 



} 

} 

 

POST /api/admin/account-requests/:requestId/approve 

Headers: Authorization: Bearer <token> 

 

Response: 

{ 

"success": true, 

"message": "Account approved successfully", 

"data": { 

"userId": "USER-050", 

"email": "jane@student.abc.edu", 

"emailSent": true 

} 

} 

 

POST /api/admin/account-requests/:requestId/reject 

Headers: Authorization: Bearer <token> 

 

Request Body: 

{ 

"reason": "Incomplete documentation provided" 

} 

 

Response: 

{ 

"success": true, 

"message": "Account request rejected", 

"data": { 

"requestId": "REQ-2024-001", 



"emailSent": true 

} 

} 

 

POST /api/admin/account-requests/bulk-action 

Headers: Authorization: Bearer <token> 

 

Request Body: 

{ 

"action": "approve", // or "reject" 

"requestIds": ["REQ-2024-001", "REQ-2024-002", "REQ-2024-003"], 

"reason": "Bulk rejection reason" // Only for reject 

} 

 

Response: 

{ 

"success": true, 

"message": "Bulk action completed", 

"data": { 

"processed": 3, 

"succeeded": 3, 

"failed": 0 

} 

} 

 

text 

 

 

**React Component - Account Requests:** 

 

```jsx 



// components/admin/AccountRequests.jsx 

import { useState, useEffect } from 'react'; 

import {  

  UserPlus, Check, X, Eye, Filter,  

  CheckSquare, XSquare  

} from 'lucide-react'; 

import {  

  getAccountRequests,  

  approveRequest,  

  rejectRequest, 

  bulkAction  

} from '../../services/adminService'; 

import { toast } from 'react-toastify'; 

 

export default function AccountRequests() { 

  const [requests, setRequests] = useState([]); 

  const [summary, setSummary] = useState(null); 

  const [filters, setFilters] = useState({ 

    status: 'pending', 

    role: 'all', 

    department: 'all' 

  }); 

  const [selectedRequests, setSelectedRequests] = useState(new Set()); 

  const [viewingRequest, setViewingRequest] = useState(null); 

  const [rejectModalOpen, setRejectModalOpen] = useState(false); 

  const [rejectReason, setRejectReason] = useState(''); 

  const [loading, setLoading] = useState(true); 

 

  useEffect(() => { 

    loadRequests(); 

  }, [filters]); 



 

  const loadRequests = async () => { 

    try { 

      const response = await getAccountRequests(filters); 

      setRequests(response.data.requests); 

      setSummary(response.data.summary); 

    } catch (error) { 

      toast.error('Failed to load requests'); 

    } finally { 

      setLoading(false); 

    } 

  }; 

 

  const handleApprove = async (requestId) => { 

    try { 

      await approveRequest(requestId); 

      toast.success('Account approved successfully'); 

      loadRequests(); 

    } catch (error) { 

      toast.error('Failed to approve account'); 

    } 

  }; 

 

  const handleReject = async (requestId, reason) => { 

    try { 

      await rejectRequest(requestId, { reason }); 

      toast.success('Account request rejected'); 

      loadRequests(); 

    } catch (error) { 

      toast.error('Failed to reject request'); 

    } 



  }; 

 

  const handleBulkApprove = async () => { 

    if (selectedRequests.size === 0) { 

      toast.error('No requests selected'); 

      return; 

    } 

 

    if (!confirm(`Approve ${selectedRequests.size} account request(s)?`)) { 

      return; 

    } 

 

    try { 

      const response = await bulkAction({ 

        action: 'approve', 

        requestIds: Array.from(selectedRequests) 

      }); 

      toast.success(`${response.data.succeeded} accounts approved`); 

      setSelectedRequests(new Set()); 

      loadRequests(); 

    } catch (error) { 

      toast.error('Bulk approval failed'); 

    } 

  }; 

 

  const handleBulkReject = async () => { 

    if (selectedRequests.size === 0) { 

      toast.error('No requests selected'); 

      return; 

    } 

 



    setRejectModalOpen(true); 

  }; 

 

  const confirmBulkReject = async () => { 

    if (!rejectReason.trim()) { 

      toast.error('Please provide a reason for rejection'); 

      return; 

    } 

 

    try { 

      const response = await bulkAction({ 

        action: 'reject', 

        requestIds: Array.from(selectedRequests), 

        reason: rejectReason 

      }); 

      toast.success(`${response.data.succeeded} requests rejected`); 

      setSelectedRequests(new Set()); 

      setRejectModalOpen(false); 

      setRejectReason(''); 

      loadRequests(); 

    } catch (error) { 

      toast.error('Bulk rejection failed'); 

    } 

  }; 

 

  const toggleSelectRequest = (requestId) => { 

    const newSelected = new Set(selectedRequests); 

    if (newSelected.has(requestId)) { 

      newSelected.delete(requestId); 

    } else { 

      newSelected.add(requestId); 



    } 

    setSelectedRequests(newSelected); 

  }; 

 

  const toggleSelectAll = () => { 

    if (selectedRequests.size === requests.length) { 

      setSelectedRequests(new Set()); 

    } else { 

      setSelectedRequests(new Set(requests.map(r => r.requestId))); 

    } 

  }; 

 

  return ( 

    <div className="account-requests"> 

      {/* Header */} 

      <div className="requests-header"> 

        <div className="header-left"> 

          <UserPlus size={28} /> 

          <h2>Account Requests</h2> 

        </div> 

        {selectedRequests.size > 0 && ( 

          <div className="bulk-actions"> 

            <span className="selected-count"> 

              {selectedRequests.size} selected 

            </span> 

            <button onClick={handleBulkApprove} className="btn-success"> 

              <CheckSquare size={18} /> 

              Approve Selected 

            </button> 

            <button onClick={handleBulkReject} className="btn-danger"> 

              <XSquare size={18} /> 



              Reject Selected 

            </button> 

          </div> 

        )} 

      </div> 

 

      {/* Summary Cards */} 

      {summary && ( 

        <div className="summary-cards"> 

          <div className="summary-card"> 

            <div className="card-value text-yellow-600">{summary.pending}</div> 

            <div className="card-label">Pending</div> 

          </div> 

          <div className="summary-card"> 

            <div className="card-value text-green-600">{summary.approved}</div> 

            <div className="card-label">Approved</div> 

          </div> 

          <div className="summary-card"> 

            <div className="card-value text-red-600">{summary.rejected}</div> 

            <div className="card-label">Rejected</div> 

          </div> 

        </div> 

      )} 

 

      {/* Filters */} 

      <div className="filters-section"> 

        <select 

          value={filters.status} 

          onChange={(e) => setFilters(prev => ({ ...prev, status: e.target.value }))} 

        > 

          <option value="pending">Pending</option> 



          <option value="approved">Approved</option> 

          <option value="rejected">Rejected</option> 

          <option value="all">All Status</option> 

        </select> 

 

        <select 

          value={filters.role} 

          onChange={(e) => setFilters(prev => ({ ...prev, role: e.target.value }))} 

        > 

          <option value="all">All Roles</option> 

          <option value="student">Students</option> 

          <option value="faculty">Faculty</option> 

          <option value="admin">Admins</option> 

        </select> 

 

        <select 

          value={filters.department} 

          onChange={(e) => setFilters(prev => ({ ...prev, department: e.target.value }))} 

        > 

          <option value="all">All Departments</option> 

          <option value="CS">Computer Science</option> 

          <option value="EE">Electrical Engineering</option> 

        </select> 

      </div> 

 

      {/* Requests Table */} 

      <div className="requests-table-container"> 

        <table className="requests-table"> 

          <thead> 

            <tr> 

              <th> 



                <input 

                  type="checkbox" 

                  checked={selectedRequests.size === requests.length && requests.length > 0} 

                  onChange={toggleSelectAll} 

                /> 

              </th> 

              <th>Requestor Info</th> 

              <th>Account Type</th> 

              <th>Contact Details</th> 

              <th>Requested Date</th> 

              <th>Status</th> 

              <th>Actions</th> 

            </tr> 

          </thead> 

          <tbody> 

            {loading ? ( 

              <tr> 

                <td colSpan="7" className="text-center">Loading...</td> 

              </tr> 

            ) : requests.length === 0 ? ( 

              <tr> 

                <td colSpan="7" className="text-center">No requests found</td> 

              </tr> 

            ) : ( 

              requests.map(request => ( 

                <tr key={request.requestId}> 

                  <td> 

                    <input 

                      type="checkbox" 

                      checked={selectedRequests.has(request.requestId)} 

                      onChange={() => toggleSelectRequest(request.requestId)} 



                    /> 

                  </td> 

                  <td> 

                    <div className="requestor-info"> 

                      <div className="requestor-name"> 

                        {request.firstName} {request.lastName} 

                      </div> 

                      <div className="requestor-dept"> 

                        {request.department} 

                        {request.section && ` - Section ${request.section}`} 

                      </div> 

                    </div> 

                  </td> 

                  <td> 

                    <span className={`role-badge ${request.role}`}> 

                      {request.role} 

                    </span> 

                  </td> 

                  <td> 

                    <div className="contact-info"> 

                      <div>{request.email}</div> 

                      <div className="text-gray-600">{request.phone}</div> 

                    </div> 

                  </td> 

                  <td>{new Date(request.submittedAt).toLocaleDateString()}</td> 

                  <td> 

                    <span className={`status-badge ${request.status}`}> 

                      {request.status} 

                    </span> 

                  </td> 

                  <td> 



                    <div className="action-buttons"> 

                      <button 

                        onClick={() => setViewingRequest(request)} 

                        className="action-btn" 

                        title="View Details" 

                      > 

                        <Eye size={16} /> 

                      </button {request.status === 'pending' && ( 

                    <> 

                      <button 

                        onClick={() => handleApprove(request.requestId)} 

                        className="action-btn success" 

                        title="Approve" 

                      > 

                        <Check size={16} /> 

                      </button> 

                      <button 

                        onClick={() => { 

                          setViewingRequest(request); 

                          setRejectModalOpen(true); 

                        }} 

                        className="action-btn danger" 

                        title="Reject" 

                      > 

                        <X size={16} /> 

                      </button> 

                    </> 

                  )} 

                </div> 

              </td> 

            </tr> 



          )) 

        )} 

      </tbody> 

    </table> 

  </div> 

 

  {/* Request Detail Modal */} 

  {viewingRequest && ( 

    <RequestDetailModal 

      request={viewingRequest} 

      onClose={() => setViewingRequest(null)} 

      onApprove={handleApprove} 

      onReject={(reason) => { 

        handleReject(viewingRequest.requestId, reason); 

        setViewingRequest(null); 

      }} 

    /> 

  )} 

 

  {/* Bulk Reject Modal */} 

  {rejectModalOpen && ( 

    <div className="modal-overlay"> 

      <div className="modal-content"> 

        <h3>Reject Selected Requests</h3> 

        <p>Provide a reason for rejecting {selectedRequests.size} request(s):</p> 

        <textarea 

          value={rejectReason} 

          onChange={(e) => setRejectReason(e.target.value)} 

          placeholder="Enter rejection reason..." 

          rows={4} 

          className="reject-textarea" 



        /> 

        <div className="modal-actions"> 

          <button 

            onClick={() => { 

              setRejectModalOpen(false); 

              setRejectReason(''); 

            }} 

            className="btn-secondary" 

          > 

            Cancel 

          </button> 

          <button 

            onClick={confirmBulkReject} 

            className="btn-danger" 

            disabled={!rejectReason.trim()} 

          > 

            Confirm Rejection 

          </button> 

        </div> 

      </div> 

    </div> 

  )} 

</div> 

); 
} 

text 

 

--- 

 

### **6.6.3 Institution Management** 

 



**User Story:** 

> As an admin, I want to manage my institution's profile, departments, and sections. 

 

**Functional Requirements:** 

 

| **Requirement ID** | **Description** | **Priority** | 

|--------------------|-----------------|--------------| 

| ADMIN-IM-001 | Admin can view institution profile details | P0 | 

| ADMIN-IM-002 | Admin can edit institution details (name, address, contact, website) | P0 | 

| ADMIN-IM-003 | Admin can upload/change institution logo | P1 | 

| ADMIN-IM-004 | Admin can create new departments | P0 | 

| ADMIN-IM-005 | Admin can assign HOD (Head of Department) to departments | P0 | 

| ADMIN-IM-006 | Admin can create sections within departments | P0 | 

| ADMIN-IM-007 | Admin can assign class teacher to sections | P0 | 

| ADMIN-IM-008 | Admin can edit department/section names | P0 | 

| ADMIN-IM-009 | Admin can deactivate departments/sections | P1 | 

| ADMIN-IM-010 | When department is created, auto-create department group in chat | P0 | 

| ADMIN-IM-011 | When section is created, auto-create section group in chat | P0 | 

| ADMIN-IM-012 | Users auto-join department/section groups based on their profile | P0 | 

 

**API Endpoints:** 

GET /api/admin/institution 
Headers: Authorization: Bearer <token> 

Response: 
{ 
"success": true, 
"data": { 
"institution": { 
"institutionId": "INST-2024-001", 
"uniqueId": "ABC-UNI-2024", 
"name": "ABC University", 
"type": "university", 
"address": "123 Main Street, City, State 12345", 
"website": "https://abc.edu", 
"email": "info@abc.edu", 



"contact": "+1234567890", 
"logo": "https://...", 
"establishedYear": 1990, 
"createdAt": "2024-01-01T00:00:00Z", 
"statistics": { 
"totalDepartments": 8, 
"totalSections": 24, 
"totalUsers": 500 
} 
} 
} 
} 

PUT /api/admin/institution 
Headers: Authorization: Bearer <token> 

Request Body: 
{ 
"name": "ABC University Updated", 
"address": "New Address", 
"website": "https://newsite.edu", 
"email": "newemail@abc.edu", 
"contact": "+9876543210" 
} 

Response: 
{ 
"success": true, 
"message": "Institution details updated successfully" 
} 

GET /api/admin/departments 
Headers: Authorization: Bearer <token> 

Response: 
{ 
"success": true, 
"data": { 
"departments": [ 
{ 
"departmentId": "DEPT-001", 
"name": "Computer Science", 
"code": "CS", 
"hod": { 
"userId": "USER-003", 
"name": "Dr. HOD Name", 
"email": "hod@abc.edu" 
}, 



"sectionsCount": 4, 
"studentsCount": 120, 
"facultyCount": 15, 
"createdAt": "2024-01-05T00:00:00Z", 
"isActive": true 
} 
] 
} 
} 

POST /api/admin/departments 
Headers: Authorization: Bearer <token> 

Request Body: 
{ 
"name": "Artificial Intelligence", 
"code": "AI", 
"hodUserId": "USER-010" 
} 

Response: 
{ 
"success": true, 
"message": "Department created successfully", 
"data": { 
"departmentId": "DEPT-009", 
"groupId": "GROUP-DEPT-009", // Auto-created chat group 
"name": "Artificial Intelligence" 
} 
} 

GET /api/admin/departments/:departmentId/sections 
Headers: Authorization: Bearer <token> 

Response: 
{ 
"success": true, 
"data": { 
"sections": [ 
{ 
"sectionId": "SEC-001", 
"name": "Section A", 
"departmentId": "DEPT-001", 
"classTeacher": { 
"userId": "USER-015", 
"name": "Prof. Teacher Name" 
}, 
"studentsCount": 30, 



"createdAt": "2024-01-06T00:00:00Z", 
"isActive": true 
} 
] 
} 
} 

POST /api/admin/departments/:departmentId/sections 
Headers: Authorization: Bearer <token> 

Request Body: 
{ 
"name": "Section D", 
"classTeacherUserId": "USER-020" 
} 

Response: 
{ 
"success": true, 
"message": "Section created successfully", 
"data": { 
"sectionId": "SEC-025", 
"groupId": "GROUP-SEC-025", // Auto-created chat group 
"name": "Section D" 
} 
} 

text 

 

**Database Schema:** 

 

```sql 

CREATE TABLE departments ( 

    id SERIAL PRIMARY KEY, 

    department_id VARCHAR(50) UNIQUE NOT NULL, 

    institution_id INTEGER REFERENCES institutions(id), 

    name VARCHAR(255) NOT NULL, 

    code VARCHAR(10), 

    hod_id INTEGER REFERENCES users(id), 

    chat_group_id INTEGER REFERENCES chat_groups(id), 

    is_active BOOLEAN DEFAULT TRUE, 



    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, 

    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, 

    UNIQUE(institution_id, code) 

); 

 

CREATE TABLE sections ( 

    id SERIAL PRIMARY KEY, 

    section_id VARCHAR(50) UNIQUE NOT NULL, 

    department_id INTEGER REFERENCES departments(id), 

    name VARCHAR(255) NOT NULL, 

    class_teacher_id INTEGER REFERENCES users(id), 

    chat_group_id INTEGER REFERENCES chat_groups(id), 

    is_active BOOLEAN DEFAULT TRUE, 

    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, 

    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, 

    UNIQUE(department_id, name) 

); 

React Component - Institution Management: 

React 

// components/admin/InstitutionManagement.jsx 

import { useState, useEffect } from 'react'; 

import { Building, Users, Edit, Plus, Trash2 } from 'lucide-react'; 

import {  

  getInstitution,  

  updateInstitution, 

  getDepartments, 

  createDepartment, 

  getSections, 

  createSection  

} from '../../services/adminService'; 

import { toast } from 'react-toastify'; 



 

export default function InstitutionManagement() { 

  const [activeTab, setActiveTab] = useState('institution'); // 'institution' or 'departments' 

  const [institution, setInstitution] = useState(null); 

  const [departments, setDepartments] = useState([]); 

  const [editMode, setEditMode] = useState(false); 

  const [editedData, setEditedData] = useState({}); 

  const [showCreateDeptModal, setShowCreateDeptModal] = useState(false); 

  const [showCreateSecModal, setShowCreateSecModal] = useState(false); 

  const [selectedDepartment, setSelectedDepartment] = useState(null); 

  const [sections, setSections] = useState([]); 

 

  useEffect(() => { 

    loadInstitution(); 

    loadDepartments(); 

  }, []); 

 

  const loadInstitution = async () => { 

    try { 

      const response = await getInstitution(); 

      setInstitution(response.data.institution); 

      setEditedData(response.data.institution); 

    } catch (error) { 

      toast.error('Failed to load institution details'); 

    } 

  }; 

 

  const loadDepartments = async () => { 

    try { 

      const response = await getDepartments(); 

      setDepartments(response.data.departments); 



    } catch (error) { 

      toast.error('Failed to load departments'); 

    } 

  }; 

 

  const loadSections = async (departmentId) => { 

    try { 

      const response = await getSections(departmentId); 

      setSections(response.data.sections); 

    } catch (error) { 

      toast.error('Failed to load sections'); 

    } 

  }; 

 

  const handleUpdateInstitution = async () => { 

    try { 

      await updateInstitution(editedData); 

      toast.success('Institution details updated successfully'); 

      setEditMode(false); 

      loadInstitution(); 

    } catch (error) { 

      toast.error('Failed to update institution'); 

    } 

  }; 

 

  const handleCreateDepartment = async (deptData) => { 

    try { 

      await createDepartment(deptData); 

      toast.success('Department created successfully'); 

      setShowCreateDeptModal(false); 

      loadDepartments(); 



    } catch (error) { 

      toast.error('Failed to create department'); 

    } 

  }; 

 

  const handleCreateSection = async (sectionData) => { 

    try { 

      await createSection(selectedDepartment.departmentId, sectionData); 

      toast.success('Section created successfully'); 

      setShowCreateSecModal(false); 

      loadSections(selectedDepartment.departmentId); 

    } catch (error) { 

      toast.error('Failed to create section'); 

    } 

  }; 

 

  return ( 

    <div className="institution-management"> 

      {/* Header */} 

      <div className="management-header"> 

        <Building size={28} /> 

        <h2>Institution Management</h2> 

      </div> 

 

      {/* Tabs */} 

      <div className="tabs"> 

        <button 

          className={`tab ${activeTab === 'institution' ? 'active' : ''}`} 

          onClick={() => setActiveTab('institution')} 

        > 

          Institution Profile 



        </button> 

        <button 

          className={`tab ${activeTab === 'departments' ? 'active' : ''}`} 

          onClick={() => setActiveTab('departments')} 

        > 

          Departments & Sections 

        </button> 

      </div> 

 

      {/* Institution Profile Tab */} 

      {activeTab === 'institution' && institution && ( 

        <div className="institution-profile"> 

          <div className="profile-header"> 

            <h3>Institution Details</h3> 

            {!editMode ? ( 

              <button onClick={() => setEditMode(true)} className="btn-secondary"> 

                <Edit size={18} /> 

                Edit Details 

              </button> 

            ) : ( 

              <div className="edit-actions"> 

                <button onClick={() => setEditMode(false)} className="btn-secondary"> 

                  Cancel 

                </button> 

                <button onClick={handleUpdateInstitution} className="btn-primary"> 

                  Save Changes 

                </button> 

              </div> 

            )} 

          </div> 

 



          <div className="profile-content"> 

            {/* Institution Logo */} 

            <div className="logo-section"> 

              <div className="logo-preview"> 

                {institution.logo ? ( 

                  <img src={institution.logo} alt="Institution Logo" /> 

                ) : ( 

                  <div className="logo-placeholder"> 

                    <Building size={48} /> 

                  </div> 

                )} 

              </div> 

              {editMode && ( 

                <button className="btn-secondary">Change Logo</button> 

              )} 

            </div> 

 

            {/* Institution Details Form */} 

            <div className="details-grid"> 

              <div className="detail-item"> 

                <label>Institution Name</label> 

                {editMode ? ( 

                  <input 

                    type="text" 

                    value={editedData.name} 

                    onChange={(e) => setEditedData(prev => ({ ...prev, name: e.target.value }))} 

                  /> 

                ) : ( 

                  <p>{institution.name}</p> 

                )} 

              </div> 



 

              <div className="detail-item"> 

                <label>Unique ID</label> 

                <p className="readonly">{institution.uniqueId}</p> 

              </div> 

 

              <div className="detail-item"> 

                <label>Type</label> 

                <p className="readonly capitalize">{institution.type}</p> 

              </div> 

 

              <div className="detail-item full-width"> 

                <label>Address</label> 

                {editMode ? ( 

                  <textarea 

                    value={editedData.address} 

                    onChange={(e) => setEditedData(prev => ({ ...prev, address: e.target.value }))} 

                    rows={2} 

                  /> 

                ) : ( 

                  <p>{institution.address}</p> 

                )} 

              </div> 

 

              <div className="detail-item"> 

                <label>Website</label> 

                {editMode ? ( 

                  <input 

                    type="url" 

                    value={editedData.website} 

                    onChange={(e) => setEditedData(prev => ({ ...prev, website: e.target.value }))} 



                  /> 

                ) : ( 

                  <a href={institution.website} target="_blank" rel="noopener noreferrer"> 

                    {institution.website} 

                  </a> 

                )} 

              </div> 

 

              <div className="detail-item"> 

                <label>Email</label> 

                {editMode ? ( 

                  <input 

                    type="email" 

                    value={editedData.email} 

                    onChange={(e) => setEditedData(prev => ({ ...prev, email: e.target.value }))} 

                  /> 

                ) : ( 

                  <p>{institution.email}</p> 

                )} 

              </div> 

 

              <div className="detail-item"> 

                <label>Contact Number</label> 

                {editMode ? 

( 
<input 
type="tel" 
value={editedData.contact} 
onChange={(e) => setEditedData(prev => ({ ...prev, contact: e.target.value }))} 
/> 
) : ( 
<p>{institution.contact}</p> 
)} 
</div> 



text 

          <div className="detail-item"> 

            <label>Established Year</label> 

            <p className="readonly">{institution.establishedYear}</p> 

          </div> 

        </div> 

 

        {/* Statistics */} 

        <div className="statistics-section"> 

          <h4>Statistics</h4> 

          <div className="stats-grid"> 

            <div className="stat-card"> 

              <div className="stat-value">{institution.statistics.totalDepartments}</div> 

              <div className="stat-label">Departments</div> 

            </div> 

            <div className="stat-card"> 

              <div className="stat-value">{institution.statistics.totalSections}</div> 

              <div className="stat-label">Sections</div> 

            </div> 

            <div className="stat-card"> 

              <div className="stat-value">{institution.statistics.totalUsers}</div> 

              <div className="stat-label">Total Users</div> 

            </div> 

          </div> 

        </div> 

      </div> 

    </div> 

  )} 

 

  {/* Departments Tab */} 

  {activeTab === 'departments' && ( 



    <div className="departments-section"> 

      <div className="section-header"> 

        <h3>Departments</h3> 

        <button onClick={() => setShowCreateDeptModal(true)} className="btn-primary"> 

          <Plus size={18} /> 

          Create Department 

        </button> 

      </div> 

 

      <div className="departments-grid"> 

        {departments.map(dept => ( 

          <div key={dept.departmentId} className="department-card"> 

            <div className="card-header"> 

              <h4>{dept.name}</h4> 

              <span className="dept-code">{dept.code}</span> 

            </div> 

 

            <div className="card-body"> 

              <div className="dept-info"> 

                <label>HOD:</label> 

                <span>{dept.hod ? dept.hod.name : 'Not assigned'}</span> 

              </div> 

              <div className="dept-stats"> 

                <div className="stat"> 

                  <span className="stat-value">{dept.sectionsCount}</span> 

                  <span className="stat-label">Sections</span> 

                </div> 

                <div className="stat"> 

                  <span className="stat-value">{dept.studentsCount}</span> 

                  <span className="stat-label">Students</span> 

                </div> 



                <div className="stat"> 

                  <span className="stat-value">{dept.facultyCount}</span> 

                  <span className="stat-label">Faculty</span> 

                </div> 

              </div> 

            </div> 

 

            <div className="card-actions"> 

              <button 

                onClick={() => { 

                  setSelectedDepartment(dept); 

                  loadSections(dept.departmentId); 

                }} 

                className="btn-secondary" 

              > 

                View Sections 

              </button> 

              <button className="btn-icon"> 

                <Edit size={16} /> 

              </button> 

            </div> 

          </div> 

        ))} 

      </div> 

 

      {/* Sections Panel */} 

      {selectedDepartment && ( 

        <div className="sections-panel"> 

          <div className="panel-header"> 

            <h3>Sections - {selectedDepartment.name}</h3> 

            <button onClick={() => setShowCreateSecModal(true)} className="btn-primary"> 



              <Plus size={18} /> 

              Create Section 

            </button> 

          </div> 

 

          <div className="sections-table"> 

            <table> 

              <thead> 

                <tr> 

                  <th>Section Name</th> 

                  <th>Class Teacher</th> 

                  <th>Students</th> 

                  <th>Status</th> 

                  <th>Actions</th> 

                </tr> 

              </thead> 

              <tbody> 

                {sections.map(section => ( 

                  <tr key={section.sectionId}> 

                    <td>{section.name}</td> 

                    <td> 

                      {section.classTeacher  

                        ? section.classTeacher.name  

                        : 'Not assigned' 

                      } 

                    </td> 

                    <td>{section.studentsCount}</td> 

                    <td> 

                      <span className={`status-badge ${section.isActive ? 'active' : 'inactive'}`}> 

                        {section.isActive ? 'Active' : 'Inactive'} 

                      </span> 



                    </td> 

                    <td> 

                      <button className="btn-icon"> 

                        <Edit size={16} /> 

                      </button> 

                    </td> 

                  </tr> 

                ))} 

              </tbody> 

            </table> 

          </div> 

        </div> 

      )} 

    </div> 

  )} 

 

  {/* Create Department Modal */} 

  {showCreateDeptModal && ( 

    <CreateDepartmentModal 

      onClose={() => setShowCreateDeptModal(false)} 

      onSubmit={handleCreateDepartment} 

    /> 

  )} 

 

  {/* Create Section Modal */} 

  {showCreateSecModal && selectedDepartment && ( 

    <CreateSectionModal 

      department={selectedDepartment} 

      onClose={() => setShowCreateSecModal(false)} 

      onSubmit={handleCreateSection} 

    /> 



  )} 

</div> 

); 
} 

// Create Department Modal Component 
function CreateDepartmentModal({ onClose, onSubmit }) { 
const [formData, setFormData] = useState({ 
name: '', 
code: '', 
hodUserId: '' 
}); 
const [faculty, setFaculty] = useState([]); 

useEffect(() => { 
// Load faculty list for HOD selection 
loadFaculty(); 
}, []); 

const loadFaculty = async () => { 
// API call to get faculty users 
}; 

const handleSubmit = (e) => { 
e.preventDefault(); 
onSubmit(formData); 
}; 

return ( 
<div className="modal-overlay"> 
<div className="modal-content"> 
<h3>Create New Department</h3> 
<form onSubmit={handleSubmit}> 
<div className="form-group"> 
<label>Department Name *</label> 
<input 
type="text" 
value={formData.name} 
onChange={(e) => setFormData(prev => ({ ...prev, name: e.target.value }))} 
placeholder="e.g., Computer Science" 
required 
/> 
</div> 

text 

      <div className="form-group"> 



        <label>Department Code *</label> 

        <input 

          type="text" 

          value={formData.code} 

          onChange={(e) => setFormData(prev => ({ ...prev, code: e.target.value.toUpperCase() }))} 

          placeholder="e.g., CS" 

          maxLength={10} 

          required 

        /> 

      </div> 

 

      <div className="form-group"> 

        <label>Head of Department (HOD)</label> 

        <select 

          value={formData.hodUserId} 

          onChange={(e) => setFormData(prev => ({ ...prev, hodUserId: e.target.value }))} 

        > 

          <option value="">Select HOD</option> 

          {faculty.map(f => ( 

            <option key={f.userId} value={f.userId}> 

              {f.name} - {f.designation} 

            </option> 

          ))} 

        </select> 

      </div> 

 

      <div className="modal-actions"> 

        <button type="button" onClick={onClose} className="btn-secondary"> 

          Cancel 

        </button> 

        <button type="submit" className="btn-primary"> 



          Create Department 

        </button> 

      </div> 

    </form> 

  </div> 

</div> 

); 
} 

// Create Section Modal Component 
function CreateSectionModal({ department, onClose, onSubmit }) { 
const [formData, setFormData] = useState({ 
name: '', 
classTeacherUserId: '' 
}); 
const [faculty, setFaculty] = useState([]); 

const handleSubmit = (e) => { 
e.preventDefault(); 
onSubmit(formData); 
}; 

return ( 
<div className="modal-overlay"> 
<div className="modal-content"> 
<h3>Create Section - {department.name}</h3> 
<form onSubmit={handleSubmit}> 
<div className="form-group"> 
<label>Section Name *</label> 
<input 
type="text" 
value={formData.name} 
onChange={(e) => setFormData(prev => ({ ...prev, name: e.target.value }))} 
placeholder="e.g., Section A" 
required 
/> 
</div> 

text 

      <div className="form-group"> 

        <label>Class Teacher</label> 

        <select 



          value={formData.classTeacherUserId} 

          onChange={(e) => setFormData(prev => ({ ...prev, classTeacherUserId: e.target.value }))} 

        > 

          <option value="">Select Class Teacher</option> 

          {faculty.map(f => ( 

            <option key={f.userId} value={f.userId}> 

              {f.name} 

            </option> 

          ))} 

        </select> 

      </div> 

 

      <div className="modal-actions"> 

        <button type="button" onClick={onClose} className="btn-secondary"> 

          Cancel 

        </button> 

        <button type="submit" className="btn-primary"> 

          Create Section 

        </button> 

      </div> 

    </form> 

  </div> 

</div> 

); 
} 

text 

 

--- 

 

## 6.7 Circular Management 

 



**User Story:** 

> As an admin/faculty, I want to create and publish institutional circulars to targeted audiences. 

 

**Functional Requirements:** 

 

| **Requirement ID** | **Description** | **Priority** | 

|--------------------|-----------------|--------------| 

| CIRC-001 | Admin/Faculty can create new circular | P0 | 

| CIRC-002 | Circular form includes: title, circular number, issue date, effective date | P0 | 

| CIRC-003 | User can set priority: High/Medium/Low | P0 | 

| CIRC-004 | User can write circular content using rich text editor | P0 | 

| CIRC-005 | User can select target audience: All/Students/Faculty/Specific Departments | P0 | 

| CIRC-006 | User can attach files to circular | P1 | 

| CIRC-007 | User can use predefined circular templates | P1 | 

| CIRC-008 | User can save circular as draft | P0 | 

| CIRC-009 | User can preview circular before publishing | P0 | 

| CIRC-010 | Published circular appears in all targeted users' circular feed | P0 | 

| CIRC-011 | System auto-fills institution header details in circular | P0 | 

| CIRC-012 | Admin can edit/delete published circulars | P1 | 

| CIRC-013 | Admin can view circular analytics (views, downloads) | P2 | 

 

**API Endpoints:** 

POST /api/circulars 
Headers: Authorization: Bearer <token> 

Request Body: 
{ 
"title": "Mid-Semester Examination Schedule", 
"circularNumber": "CIRC/2024/001", 
"issueDate": "2024-01-20", 
"effectiveDate": "2024-01-25", 
"priority": "high", 
"content": "<p>This is to inform all students...</p>", 
"targetAudience": "students", 
"departments": ["DEPT-001", "DEPT-002"], // Optional: specific departments 



"attachments": ["DOC-123"], // Document IDs 
"status": "published" // or "draft" 
} 

Response: 
{ 
"success": true, 
"message": "Circular published successfully", 
"data": { 
"circularId": "CIR-001", 
"publishedAt": "2024-01-20T10:00:00Z", 
"targetedUsers": 450 
} 
} 

GET /api/circulars/manage 
Headers: Authorization: Bearer <token> 
Query: ?status=published&priority=high&page=1 

Response: 
{ 
"success": true, 
"data": { 
"circulars": [ 
{ 
"circularId": "CIR-001", 
"title": "Mid-Semester Examination Schedule", 
"circularNumber": "CIRC/2024/001", 
"priority": "high", 
"targetAudience": "students", 
"status": "published", 
"viewsCount": 345, 
"downloadsCount": 89, 
"createdAt": "2024-01-20T10:00:00Z" 
} 
] 
} 
} 

PUT /api/circulars/:circularId 
Headers: Authorization: Bearer <token> 

Request Body: 
{ 
"title": "Updated Title", 
"content": "Updated content..." 
} 



Response: 
{ 
"success": true, 
"message": "Circular updated successfully" 
} 

DELETE /api/circulars/:circularId 
Headers: Authorization: Bearer <token> 

Response: 
{ 
"success": true, 
"message": "Circular deleted successfully" 
} 

text 

 

**Database Schema:** 

 

```sql 

CREATE TABLE circulars ( 

    id SERIAL PRIMARY KEY, 

    circular_id VARCHAR(50) UNIQUE NOT NULL, 

    institution_id INTEGER REFERENCES institutions(id), 

    title VARCHAR(255) NOT NULL, 

    circular_number VARCHAR(50) UNIQUE NOT NULL, 

    issue_date DATE NOT NULL, 

    effective_date DATE, 

    priority VARCHAR(20) DEFAULT 'medium', -- 'high', 'medium', 'low' 

    content TEXT NOT NULL, 

    target_audience VARCHAR(50) NOT NULL, -- 'all', 'students', 'faculty', 'specific' 

    target_departments JSONB, -- Array of department IDs 

    attachments JSONB, -- Array of document IDs 

    status VARCHAR(20) DEFAULT 'draft', -- 'draft', 'published' 

    views_count INTEGER DEFAULT 0, 

    downloads_count INTEGER DEFAULT 0, 

    created_by INTEGER REFERENCES users(id), 



    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, 

    published_at TIMESTAMP, 

    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP 

); 

 

CREATE TABLE circular_views ( 

    id SERIAL PRIMARY KEY, 

    circular_id INTEGER REFERENCES circulars(id), 

    user_id INTEGER REFERENCES users(id), 

    viewed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, 

    UNIQUE(circular_id, user_id) 

); 

Due to the extensive length of this PRD, I'll now provide a summary of remaining sections that need to 
be documented: 

 
REMAINING SECTIONS TO BE DOCUMENTED: 

7. User Interface Design 

• Wireframes for all user roles 

• Design system and component library 

• Responsive design specifications 

• Accessibility guidelines (WCAG 2.1 AA) 

8. Non-Functional Requirements 

• Performance benchmarks 

• Scalability requirements 

• Security standards 

• Browser compatibility matrix 

9. Integration Specifications 

• Third-party services (EmailJS, Pinata, Infura) 

• Webhook configurations 

• API rate limiting 

10. Deployment Strategy 



• Environment configurations (Dev/Staging/Production) 

• CI/CD pipeline 

• Monitoring and logging 

• Backup and disaster recovery 

11. Testing Strategy 

• Unit testing requirements 

• Integration testing 

• End-to-end testing scenarios 

• Security testing protocols 

12. Success Metrics & KPIs 

• User adoption metrics 

• System performance metrics 

• Business impact metrics 

8. Non-Functional Requirements 

8.1 Performance Requirements 

8.1.1 Response Time 

Operation Target Maximum 

Page Load (Initial) < 2 seconds < 3 seconds 

API Response < 500ms < 1 second 

File Upload to IPFS < 30 seconds < 60 seconds 

Blockchain Transaction < 15 seconds < 30 seconds 

Search Query < 300ms < 500ms 

Real-time Message Delivery < 100ms < 200ms 

Document Preview Load < 2 seconds < 4 seconds 

8.1.2 Throughput 

Metric Requirement 

Concurrent Users 500+ simultaneous users 

API Requests 1000 requests/minute 

File Uploads 50 simultaneous uploads 



Metric Requirement 

WebSocket Connections 500 active connections 

Database Queries 500 queries/second 

8.1.3 Resource Optimization 

Frontend Optimization: 

JavaScript 

// Code splitting 

const FileManager = lazy(() => import('./pages/FileManager')); 

const Chat = lazy(() => import('./pages/Chat')); 

const DocumentGenerator = lazy(() => import('./pages/DocumentGenerator')); 

 

// Image optimization 

<img  

  src={thumbnail}  

  loading="lazy" 

  srcSet={`${thumbnail} 1x, ${thumbnail2x} 2x`} 

/> 

 

// Bundle size limits 

// Main bundle: < 250KB gzipped 

// Vendor bundle: < 150KB gzipped 

// Total initial load: < 400KB gzipped 

Backend Optimization: 

Python 

# Database query optimization 

@cache.memoize(timeout=300) 

def get_user_documents(user_id): 

    return Document.query.filter_by( 

        owner_id=user_id, 

        is_deleted=False 

    ).options( 



        joinedload(Document.folder), 

        defer(Document.ipfs_hash)  # Load only when needed 

    ).all() 

 

# Connection pooling 

db_config = { 

    'pool_size': 20, 

    'max_overflow': 40, 

    'pool_timeout': 30, 

    'pool_recycle': 3600 

} 

8.1.4 Caching Strategy 

Redis Cache Layers: 

Data Type Cache Duration Invalidation 

User Profile 15 minutes On update 

Institution Details 1 hour On update 

Department List 30 minutes On create/update 

Document Metadata 10 minutes On update 

Circular Feed 5 minutes On new publish 

Approval Requests No cache Real-time 

Implementation: 

Python 

# Cache decorator 

@cache_result(key='user:{user_id}', expire=900) 

def get_user_profile(user_id): 

    return User.query.get(user_id) 

 

# Cache invalidation 

def update_user_profile(user_id, data): 

    user = User.query.get(user_id) 



    user.update(data) 

    db.session.commit() 

    cache.delete(f'user:{user_id}')  # Invalidate cache 

 
8.2 Scalability Requirements 

8.2.1 Horizontal Scaling 

Application Tier: 

YAML 

# Docker Compose - Load Balanced Setup 

services: 

  nginx: 

    image: nginx:alpine 

    ports: 

      - "80:80" 

      - "443:443" 

    volumes: 

      - ./nginx.conf:/etc/nginx/nginx.conf 

    depends_on: 

      - backend-1 

      - backend-2 

      - backend-3 

 

  backend-1: 

    build: ./backend 

    environment: 

      - INSTANCE_ID=1 

     

  backend-2: 

    build: ./backend 

    environment: 

      - INSTANCE_ID=2 



     

  backend-3: 

    build: ./backend 

    environment: 

      - INSTANCE_ID=3 

Nginx Load Balancer Config: 

nginx 

upstream backend_servers { 

    least_conn;  # Use least connections algorithm 

    server backend-1:5000 weight=3; 

    server backend-2:5000 weight=3; 

    server backend-3:5000 weight=3; 

    keepalive 32; 

} 

 

server { 

    listen 80; 

     

    location /api/ { 

        proxy_pass http://backend_servers; 

        proxy_http_version 1.1; 

        proxy_set_header Upgrade $http_upgrade; 

        proxy_set_header Connection "upgrade"; 

        proxy_set_header Host $host; 

        proxy_cache_bypass $http_upgrade; 

    } 

} 

8.2.2 Database Scaling 

Read Replicas: 

Python 

# Master-Slave Configuration 



SQLALCHEMY_BINDS = { 

    'master': 'postgresql://user:pass@master-db:5432/docuchain', 

    'slave1': 'postgresql://user:pass@slave1-db:5432/docuchain', 

    'slave2': 'postgresql://user:pass@slave2-db:5432/docuchain' 

} 

 

# Read from slaves, write to master 

class Document(db.Model): 

    __bind_key__ = 'master' 

     

    @classmethod 

    def read_query(cls): 

        return cls.query.options( 

            db.with_bind('slave1')  # Read from replica 

        ) 

Partitioning Strategy: 

SQL 

-- Partition documents table by creation date 

CREATE TABLE documents_2024_q1 PARTITION OF documents 

    FOR VALUES FROM ('2024-01-01') TO ('2024-04-01'); 

 

CREATE TABLE documents_2024_q2 PARTITION OF documents 

    FOR VALUES FROM ('2024-04-01') TO ('2024-07-01'); 

 

-- Index on partition key 

CREATE INDEX idx_documents_created ON documents (created_at); 

8.2.3 IPFS/Storage Scaling 

CDN Integration: 

JavaScript 

// Use Cloudflare/AWS CloudFront for IPFS gateway 

const IPFS_GATEWAYS = [ 



  'https://gateway.pinata.cloud', 

  'https://cloudflare-ipfs.com', 

  'https://ipfs.io' 

]; 

 

const getIPFSUrl = (hash) => { 

  const gateway = IPFS_GATEWAYS[Math.floor(Math.random() * IPFS_GATEWAYS.length)]; 

  return `${gateway}/ipfs/${hash}`; 

}; 

Storage Quotas: 

User Type Storage Limit Monthly Upload Limit 

Student 1 GB 500 MB 

Faculty 5 GB 2 GB 

Admin 10 GB 5 GB 

 
8.3 Security Requirements 

8.3.1 Authentication Security 

JWT Token Management: 

Python 

# Token configuration 

JWT_SECRET_KEY = os.getenv('JWT_SECRET_KEY') 

JWT_ACCESS_TOKEN_EXPIRES = timedelta(hours=24) 

JWT_REFRESH_TOKEN_EXPIRES = timedelta(days=30) 

JWT_ALGORITHM = 'HS256' 

 

# Token generation with claims 

def create_access_token(user): 

    claims = { 

        'sub': user.user_id, 

        'email': user.email, 



        'role': user.role, 

        'institution_id': user.institution_id, 

        'iat': datetime.utcnow(), 

        'exp': datetime.utcnow() + JWT_ACCESS_TOKEN_EXPIRES 

    } 

    return jwt.encode(claims, JWT_SECRET_KEY, algorithm=JWT_ALGORITHM) 

Password Security: 

Python 

# Bcrypt with salt rounds 

import bcrypt 

 

def hash_password(password): 

    salt = bcrypt.gensalt(rounds=12)  # 12 rounds = 2^12 iterations 

    hashed = bcrypt.hashpw(password.encode('utf-8'), salt) 

    return hashed.decode('utf-8') 

 

def verify_password(password, hashed): 

    return bcrypt.checkpw(password.encode('utf-8'), hashed.encode('utf-8')) 

Password Policy: 

• Minimum 8 characters 

• At least 1 uppercase letter 

• At least 1 lowercase letter 

• At least 1 number 

• At least 1 special character 

• Cannot contain username or email 

• Cannot reuse last 5 passwords 

8.3.2 API Security 

Rate Limiting: 

Python 

from flask_limiter import Limiter 

 



limiter = Limiter( 

    app, 

    key_func=lambda: request.headers.get('Authorization', 'anonymous'), 

    storage_uri="redis://localhost:6379" 

) 

 

# Apply rate limits 

@app.route('/api/login', methods=['POST']) 

@limiter.limit("5 per minute") 

def login(): 

    pass 

 

@app.route('/api/files/upload', methods=['POST']) 

@limiter.limit("10 per minute") 

def upload_file(): 

    pass 

Input Validation: 

Python 

from marshmallow import Schema, fields, validate, ValidationError 

 

class UserRegistrationSchema(Schema): 

    email = fields.Email(required=True) 

    password = fields.Str( 

        required=True, 

        validate=validate.Length(min=8, max=128) 

    ) 

    first_name = fields.Str( 

        required=True, 

        validate=validate.Regexp(r'^[a-zA-Z\s]+$') 

    ) 

    phone = fields.Str( 



        validate=validate.Regexp(r'^\+?[1-9]\d{1,14}$') 

    ) 

 

# Usage 

schema = UserRegistrationSchema() 

try: 

    validated_data = schema.load(request.json) 

except ValidationError as err: 

    return jsonify({'errors': err.messages}), 400 

CORS Configuration: 

Python 

from flask_cors import CORS 

 

CORS(app, resources={ 

    r"/api/*": { 

        "origins": ["https://docuchain.app", "http://localhost:3000"], 

        "methods": ["GET", "POST", "PUT", "DELETE"], 

        "allow_headers": ["Content-Type", "Authorization"], 

        "expose_headers": ["X-Total-Count"], 

        "max_age": 3600, 

        "supports_credentials": True 

    } 

}) 

8.3.3 Blockchain Security 

Wallet Private Key Management: 

JavaScript 

// NEVER store private keys in code or database 

// Use MetaMask for user wallets 

// Use environment variables for system wallets 

 

// Server-side signing (for system operations only) 



const { Wallet } = require('ethers'); 

const wallet = new Wallet(process.env.SYSTEM_PRIVATE_KEY); 

 

// Always verify signatures 

const isValid = await contract.verifySignature( 

  messageHash, 

  signature, 

  signerAddress 

); 

Smart Contract Security: 

solidity 

// SPDX-License-Identifier: MIT 

pragma solidity ^0.8.20; 

 

import "@openzeppelin/contracts/access/Ownable.sol"; 

import "@openzeppelin/contracts/security/Pausable.sol"; 

import "@openzeppelin/contracts/security/ReentrancyGuard.sol"; 

 

contract DocumentManager is Ownable, Pausable, ReentrancyGuard { 

    // Prevent reentrancy attacks 

    function uploadDocument(...)  

        public  

        whenNotPaused  

        nonReentrant  

        returns (bytes32)  

    { 

        // Function logic 

    } 

     

    // Emergency pause 

    function pause() public onlyOwner { 



        _pause(); 

    } 

     

    // Input validation 

    require(bytes(_ipfsHash).length > 0, "IPFS hash required"); 

    require(_fileSize > 0, "Invalid file size"); 

} 

8.3.4 Data Encryption 

At Rest: 

Python 

# Database encryption (PostgreSQL) 

# Enable encryption at database level 

ALTER DATABASE docuchain SET encryption = 'AES-256'; 

 

# Encrypt sensitive fields 

from cryptography.fernet import Fernet 

 

class EncryptedField: 

    def __init__(self, key): 

        self.cipher = Fernet(key) 

     

    def encrypt(self, data): 

        return self.cipher.encrypt(data.encode()).decode() 

     

    def decrypt(self, encrypted_data): 

        return self.cipher.decrypt(encrypted_data.encode()).decode() 

 

# Usage 

encryption_key = os.getenv('ENCRYPTION_KEY') 

cipher = EncryptedField(encryption_key) 

 



# Encrypt before storing 

user.phone_number = cipher.encrypt(phone_number) 

In Transit: 

nginx 

# Force HTTPS 

server { 

    listen 80; 

    server_name docuchain.app; 

    return 301 https://$server_name$request_uri; 

} 

 

server { 

    listen 443 ssl http2; 

    server_name docuchain.app; 

     

    ssl_certificate /etc/letsencrypt/live/docuchain.app/fullchain.pem; 

    ssl_certificate_key /etc/letsencrypt/live/docuchain.app/privkey.pem; 

     

    ssl_protocols TLSv1.2 TLSv1.3; 

    ssl_ciphers HIGH:!aNULL:!MD5; 

    ssl_prefer_server_ciphers on; 

     

    # HSTS 

    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always; 

} 

8.3.5 Security Headers 

Python 

from flask import Flask 

from flask_talisman import Talisman 

 

app = Flask(__name__) 



 

# Apply security headers 

Talisman(app,  

    force_https=True, 

    strict_transport_security=True, 

    content_security_policy={ 

        'default-src': "'self'", 

        'script-src': ["'self'", "'unsafe-inline'", "cdn.jsdelivr.net"], 

        'style-src': ["'self'", "'unsafe-inline'"], 

        'img-src': ["'self'", "data:", "https:"], 

        'connect-src': ["'self'", "wss:", "https://sepolia.infura.io"], 

        'frame-ancestors': "'none'" 

    } 

) 

 

# Additional headers 

@app.after_request 

def set_security_headers(response): 

    response.headers['X-Content-Type-Options'] = 'nosniff' 

    response.headers['X-Frame-Options'] = 'DENY' 

    response.headers['X-XSS-Protection'] = '1; mode=block' 

    response.headers['Referrer-Policy'] = 'strict-origin-when-cross-origin' 

    return response 

 
8.4 Reliability & Availability 

8.4.1 Uptime Requirements 

Metric Target 

System Availability 99.9% (< 8.76 hours downtime/year) 

Planned Maintenance Window Sundays 2-4 AM UTC 

Recovery Time Objective (RTO) < 4 hours 



Metric Target 

Recovery Point Objective (RPO) < 1 hour 

8.4.2 Backup Strategy 

Database Backups: 

Bash 

# Automated PostgreSQL backups 

#!/bin/bash 

# backup.sh 

 

BACKUP_DIR="/backups/postgresql" 

DATE=$(date +%Y%m%d_%H%M%S) 

DB_NAME="docuchain" 

 

# Full backup 

pg_dump -Fc $DB_NAME > $BACKUP_DIR/full_backup_$DATE.dump 

 

# Upload to S3 

aws s3 cp $BACKUP_DIR/full_backup_$DATE.dump \ 

    s3://docuchain-backups/database/ 

 

# Retain last 30  

days 
find $BACKUP_DIR -type f -name "*.dump" -mtime +30 -delete 

Backup schedule (crontab) 

Full backup: Daily at 2 AM 

0 2 * * * /scripts/backup.sh 

Incremental backup: Every 6 hours 

0 */6 * * * /scripts/incremental_backup.sh 

text 

 

**Redis Backups:** 



```bash 

# Redis persistence configuration 

# redis.conf 

 

# RDB snapshots 

save 900 1      # Save if 1 key changed in 15 minutes 

save 300 10     # Save if 10 keys changed in 5 minutes 

save 60 10000   # Save if 10000 keys changed in 1 minute 

 

# AOF (Append Only File) for better durability 

appendonly yes 

appendfsync everysec 

 

# Backup script 

#!/bin/bash 

REDIS_BACKUP="/backups/redis" 

DATE=$(date +%Y%m%d_%H%M%S) 

 

redis-cli BGSAVE 

sleep 10 

cp /var/lib/redis/dump.rdb $REDIS_BACKUP/redis_backup_$DATE.rdb 

aws s3 cp $REDIS_BACKUP/redis_backup_$DATE.rdb s3://docuchain-backups/redis/ 

IPFS Data Backup: 

JavaScript 

// Backup IPFS pins to multiple providers 

const backupProviders = [ 

  { name: 'Pinata', endpoint: 'https://api.pinata.cloud' }, 

  { name: 'Infura', endpoint: 'https://ipfs.infura.io:5001' }, 

  { name: 'Web3Storage', endpoint: 'https://api.web3.storage' } 

]; 

 



async function backupToMultipleProviders(ipfsHash, file) { 

  const results = await Promise.allSettled( 

    backupProviders.map(provider =>  

      uploadToProvider(provider, ipfsHash, file) 

    ) 

  ); 

   

  // Log backup status 

  console.log('Backup results:', results); 

} 

8.4.3 Disaster Recovery Plan 

Recovery Procedures: 

1. Database Recovery: 

Bash 

# Restore from latest backup 

pg_restore -d docuchain /backups/full_backup_20240120.dump 

 

# Point-in-time recovery 

pg_restore -d docuchain -T <timestamp> /backups/full_backup.dump 

2. Application Recovery: 

Bash 

# Deploy from last known good state 

git checkout <last-stable-commit> 

docker-compose down 

docker-compose up -d 

 

# Verify services 

curl https://api.docuchain.app/health 

3. Blockchain Data Recovery: 

JavaScript 

// Resync from blockchain 



const resyncFromBlock = async (startBlock) => { 

  const contract = new ethers.Contract(CONTRACT_ADDRESS, ABI, provider); 

   

  // Listen to past events 

  const filter = contract.filters.DocumentUploaded(); 

  const events = await contract.queryFilter(filter, startBlock, 'latest'); 

   

  // Rebuild database from events 

  for (const event of events) { 

    await rebuildDocumentRecord(event); 

  } 

}; 

8.4.4 Health Monitoring 

Health Check Endpoints: 

Python 

# backend/app/api/health.py 

from flask import Blueprint, jsonify 

import psycopg2 

import redis 

 

health_bp = Blueprint('health', __name__) 

 

@health_bp.route('/health') 

def health_check(): 

    health_status = { 

        'status': 'healthy', 

        'timestamp': datetime.utcnow().isoformat(), 

        'services': {} 

    } 

     

    # Check database 



    try: 

        db.session.execute('SELECT 1') 

        health_status['services']['database'] = 'healthy' 

    except Exception as e: 

        health_status['status'] = 'unhealthy' 

        health_status['services']['database'] = f'unhealthy: {str(e)}' 

     

    # Check Redis 

    try: 

        redis_client.ping() 

        health_status['services']['redis'] = 'healthy' 

    except Exception as e: 

        health_status['status'] = 'unhealthy' 

        health_status['services']['redis'] = f'unhealthy: {str(e)}' 

     

    # Check blockchain connection 

    try: 

        w3.eth.block_number 

        health_status['services']['blockchain'] = 'healthy' 

    except Exception as e: 

        health_status['status'] = 'unhealthy' 

        health_status['services']['blockchain'] = f'unhealthy: {str(e)}' 

     

    # Check IPFS 

    try: 

        response = requests.get('https://api.pinata.cloud/data/testAuthentication', 

                               headers={'pinata_api_key': PINATA_API_KEY}) 

        if response.status_code == 200: 

            health_status['services']['ipfs'] = 'healthy' 

        else: 

            health_status['services']['ipfs'] = 'degraded' 



    except Exception as e: 

        health_status['services']['ipfs'] = f'unhealthy: {str(e)}' 

     

    status_code = 200 if health_status['status'] == 'healthy' else 503 

    return jsonify(health_status), status_code 

 

@health_bp.route('/health/ready') 

def readiness_check(): 

    """Kubernetes readiness probe""" 

    # Check if app is ready to receive traffic 

    return jsonify({'ready': True}), 200 

 

@health_bp.route('/health/live') 

def liveness_check(): 

    """Kubernetes liveness probe""" 

    # Check if app is alive 

    return jsonify({'alive': True}), 200 

 
8.5 Monitoring & Logging 

8.5.1 Application Monitoring 

Prometheus Metrics: 

Python 

# backend/app/monitoring.py 

from prometheus_flask_exporter import PrometheusMetrics 

 

metrics = PrometheusMetrics(app) 

 

# Custom metrics 

document_uploads = metrics.counter( 

    'document_uploads_total', 

    'Total number of document uploads', 



    labels={'status': lambda: request.view_args.get('status', 'unknown')} 

) 

 

approval_processing_time = metrics.histogram( 

    'approval_processing_seconds', 

    'Time spent processing approvals' 

) 

 

# Usage in routes 

@app.route('/api/files/upload', methods=['POST']) 

@document_uploads.count_exceptions() 

def upload_file(): 

    with approval_processing_time.time(): 

        # Upload logic 

        pass 

Grafana Dashboard Configuration: 

YAML 

# grafana/dashboards/docuchain.json 

{ 

  "dashboard": { 

    "title": "DocuChain Monitoring", 

    "panels": [ 

      { 

        "title": "API Response Time", 

        "targets": [ 

          { 

            "expr": "rate(http_request_duration_seconds_sum[5m]) / 
rate(http_request_duration_seconds_count[5m])" 

          } 

        ] 

      }, 



      { 

        "title": "Document Upload Rate", 

        "targets": [ 

          { 

            "expr": "rate(document_uploads_total[5m])" 

          } 

        ] 

      }, 

      { 

        "title": "Active Users", 

        "targets": [ 

          { 

            "expr": "count(rate(user_login_total[5m]) > 0)" 

          } 

        ] 

      }, 

      { 

        "title": "Blockchain Transaction Success Rate", 

        "targets": [ 

          { 

            "expr": "sum(rate(blockchain_transactions_total{status='success'}[5m])) / 
sum(rate(blockchain_transactions_total[5m]))" 

          } 

        ] 

      } 

    ] 

  } 

} 

8.5.2 Centralized Logging 

ELK Stack Configuration: 

Logstash Pipeline: 



Ruby 

# logstash/pipeline/docuchain.conf 

input { 

  file { 

    path => "/var/log/docuchain/app.log" 

    type => "application" 

    codec => json 

  } 

   

  file { 

    path => "/var/log/nginx/access.log" 

    type => "nginx" 

  } 

} 

 

filter { 

  if [type] == "application" { 

    json { 

      source => "message" 

    } 

     

    date { 

      match => ["timestamp", "ISO8601"] 

    } 

     

    grok { 

      match => { "message" => "%{LOGLEVEL:log_level}" } 

    } 

  } 

} 

 



output { 

  elasticsearch { 

    hosts => ["elasticsearch:9200"] 

    index => "docuchain-%{+YYYY.MM.dd}" 

  } 

} 

Application Logging: 

Python 

# backend/app/logging_config.py 

import logging 

import json 

from pythonjsonlogger import jsonlogger 

 

class CustomJsonFormatter(jsonlogger.JsonFormatter): 

    def add_fields(self, log_record, record, message_dict): 

        super(CustomJsonFormatter, self).add_fields(log_record, record, message_dict) 

        log_record['timestamp'] = datetime.utcnow().isoformat() 

        log_record['level'] = record.levelname 

        log_record['service'] = 'docuchain-backend' 

        log_record['environment'] = os.getenv('ENVIRONMENT', 'development') 

 

# Configure logging 

handler = logging.FileHandler('/var/log/docuchain/app.log') 

formatter = CustomJsonFormatter( 

    '%(timestamp)s %(level)s %(name)s %(message)s' 

) 

handler.setFormatter(formatter) 

 

logger = logging.getLogger('docuchain') 

logger.addHandler(handler) 

logger.setLevel(logging.INFO) 



 

# Usage 

logger.info('Document uploaded', extra={ 

    'user_id': user.user_id, 

    'document_id': document.document_id, 

    'ipfs_hash': ipfs_hash, 

    'file_size': file_size 

}) 

 

logger.error('Blockchain transaction failed', extra={ 

    'user_id': user.user_id, 

    'transaction_hash': tx_hash, 

    'error': str(e) 

}, exc_info=True) 

8.5.3 Error Tracking 

Sentry Integration: 

Python 

# backend/app/__init__.py 

import sentry_sdk 

from sentry_sdk.integrations.flask import FlaskIntegration 

 

sentry_sdk.init( 

    dsn=os.getenv('SENTRY_DSN'), 

    integrations=[FlaskIntegration()], 

    environment=os.getenv('ENVIRONMENT', 'development'), 

    traces_sample_rate=0.1,  # 10% of transactions 

    profiles_sample_rate=0.1, 

    before_send=filter_sensitive_data 

) 

 

def filter_sensitive_data(event, hint): 



    """Remove sensitive data from error reports""" 

    if 'request' in event: 

        if 'headers' in event['request']: 

            # Remove authorization headers 

            event['request']['headers'].pop('Authorization', None) 

        if 'data' in event['request']: 

            # Remove password fields 

            if isinstance(event['request']['data'], dict): 

                event['request']['data'].pop('password', None) 

    return event 

 

# Capture exceptions 

try: 

    risky_operation() 

except Exception as e: 

    sentry_sdk.capture_exception(e) 

    logger.error('Operation failed', exc_info=True) 

Frontend Error Tracking: 

JavaScript 

// frontend/src/services/errorTracking.js 

import * as Sentry from "@sentry/react"; 

import { BrowserTracing } from "@sentry/tracing"; 

 

Sentry.init({ 

  dsn: import.meta.env.VITE_SENTRY_DSN, 

  environment: import.meta.env.VITE_ENVIRONMENT, 

  integrations: [new BrowserTracing()], 

  tracesSampleRate: 0.1, 

   

  beforeSend(event, hint) { 

    // Filter sensitive data 



    if (event.request) { 

      delete event.request.cookies; 

      if (event.request.headers) { 

        delete event.request.headers.Authorization; 

      } 

    } 

    return event; 

  } 

}); 

 

// Error boundary 

class ErrorBoundary extends React.Component { 

  componentDidCatch(error, errorInfo) { 

    Sentry.captureException(error, { contexts: { react: errorInfo } }); 

  } 

   

  render() { 

    return this.props.children; 

  } 

} 

8.5.4 Alerting 

Alert Rules (Prometheus AlertManager): 

YAML 

# alertmanager/rules.yml 

groups: 

  - name: docuchain_alerts 

    interval: 30s 

    rules: 

      # High error rate 

      - alert: HighErrorRate 

        expr: rate(http_requests_total{status=~"5.."}[5m]) > 0.05 



        for: 5m 

        labels: 

          severity: critical 

        annotations: 

          summary: "High error rate detected" 

          description: "Error rate is {{ $value }} requests/sec" 

       

      # Database connection issues 

      - alert: DatabaseDown 

        expr: up{job="postgres"} == 0 

        for: 1m 

        labels: 

          severity: critical 

        annotations: 

          summary: "Database is down" 

       

      # High response time 

      - alert: HighResponseTime 

        expr: http_request_duration_seconds{quantile="0.95"} > 2 

        for: 10m 

        labels: 

          severity: warning 

        annotations: 

          summary: "95th percentile response time > 2s" 

       

      # Low disk space 

      - alert: LowDiskSpace 

        expr: node_filesystem_avail_bytes / node_filesystem_size_bytes < 0.1 

        for: 5m 

        labels: 

          severity: warning 



        annotations: 

          summary: "Disk space below 10%" 

       

      # Blockchain sync issues 

      - alert: BlockchainSyncLag 

        expr: (eth_block_number - eth_synced_block_number) > 100 

        for: 15m 

        labels: 

          severity: warning 

        annotations: 

          summary: "Blockchain sync lagging by {{ $value }} blocks" 

Notification Channels: 

YAML 

# alertmanager/config.yml 

global: 

  resolve_timeout: 5m 

 

route: 

  receiver: 'default' 

  group_by: ['alertname', 'cluster'] 

  group_wait: 10s 

  group_interval: 10s 

  repeat_interval: 12h 

  routes: 

    - match: 

        severity: critical 

      receiver: 'pagerduty' 

    - match: 

        severity: warning 

      receiver: 'slack' 

 



receivers: 

  - name: 'default' 

    email_configs: 

      - to: 'devops@docuchain.app' 

        from: 'alerts@docuchain.app' 

        smarthost: 'smtp.gmail.com:587' 

   

  - name: 'slack' 

    slack_configs: 

      - api_url: 'https://hooks.slack.com/services/YOUR/SLACK/WEBHOOK' 

        channel: '#docuchain-alerts' 

        title: 'DocuChain Alert' 

        text: '{{ range .Alerts }}{{ .Annotations.summary }}\n{{ end }}' 

   

  - name: 'pagerduty' 

    pagerduty_configs: 

      - service_key: 'YOUR_PAGERDUTY_KEY' 

 
8.6 Browser & Platform Compatibility 

8.6.1 Supported Browsers 

Browser Minimum Version Notes 

Chrome 90+ Recommended 

Firefox 88+ Full support 

Safari 14+ Limited MetaMask support 

Edge 90+ Full support 

Opera 76+ Full support 

Brave 1.25+ Built-in Web3 support 

Unsupported: 

• Internet Explorer (all versions) 

• Opera Mini 



• Mobile browsers without Web3 support 

• 8.6.2 Browser Feature Requirements 
• Essential Features: 
• JavaScript 
• // Feature detection 
• const checkBrowserSupport = () => { 
•   const requirements = { 
•     localStorage: typeof Storage !== 'undefined', 
•     sessionStorage: typeof sessionStorage !== 'undefined', 
•     webSocket: 'WebSocket' in window, 
•     webCrypto: window.crypto && window.crypto.subtle, 
•     fileAPI: 'File' in window && 'FileReader' in window, 
•     ethereum: typeof window.ethereum !== 'undefined', 
•     promises: typeof Promise !== 'undefined', 
•     fetch: typeof fetch !== 'undefined' 
•   }; 
•  
•   const unsupported = Object.keys(requirements).filter( 
•     feature => !requirements[feature] 
•   ); 
•  
•   if (unsupported.length > 0) { 
•     showUnsupportedBrowserWarning(unsupported); 
•     return false; 
•   } 
•  
•   return true; 
• }; 
• Polyfills: 
• JavaScript 
• // frontend/src/polyfills.js 
• // For older browsers 
• import 'core-js/stable'; 
• import 'regenerator-runtime/runtime'; 
• import 'whatwg-fetch'; 
•  
• // Web3 polyfills 
• if (!window.Buffer) { 
•   window.Buffer = require('buffer/').Buffer; 
• } 
•  
• if (!window.process) { 
•   window.process = { env: {} }; 
• } 
• 8.6.3 Mobile Support 
• Responsive Breakpoints: 
• CSS 
• /* Mobile-first approach */ 
• @media (min-width: 640px) {  /* sm */ 
•   /* Tablet styles */ 
• } 
•  
• @media (min-width: 768px) {  /* md */ 
•   /* Desktop styles */ 
• } 
•  



• @media (min-width: 1024px) { /* lg */ 
•   /* Large desktop */ 
• } 
•  
• @media (min-width: 1280px) { /* xl */ 
•   /* Extra large desktop */ 
• } 
• Mobile-Specific Features: 
• JavaScript 
• // Detect mobile device 
• const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent); 
•  
• // Mobile optimizations 
• if (isMobile) { 
•   // Disable hover effects 
•   document.body.classList.add('mobile-device'); 
•    
•   // Use mobile-friendly file picker 
•   document.querySelector('input[type="file"]').setAttribute('accept', '*/*'); 
•    
•   // Enable touch gestures 
•   enableTouchGestures(); 
• } 
•  
• // Mobile Web3 support (WalletConnect) 
• import WalletConnectProvider from "@walletconnect/web3-provider"; 
•  
• const provider = new WalletConnectProvider({ 
•   infuraId: "YOUR_INFURA_ID", 
•   qrcode: true, 
•   qrcodeModalOptions: { 
•     mobileLinks: [ 
•       "metamask", 
•       "trust", 
•       "rainbow", 
•       "argent" 
•     ] 
•   } 
• }); 
• 8.6.4 Progressive Web App (PWA) 
• Manifest Configuration: 
• JSON 
• // frontend/public/manifest.json 
• { 
•   "name": "DocuChain", 
•   "short_name": "DocuChain", 
•   "description": "Blockchain-based Document Management System", 
•   "start_url": "/", 
•   "display": "standalone", 
•   "background_color": "#ffffff", 
•   "theme_color": "#10B981", 
•   "orientation": "portrait", 
•   "icons": [ 
•     { 
•       "src": "/icons/icon-72x72.png", 
•       "sizes": "72x72", 



•       "type": "image/png" 
•     }, 
•     { 
•       "src": "/icons/icon-192x192.png", 
•       "sizes": "192x192", 
•       "type": "image/png" 
•     }, 
•     { 
•       "src": "/icons/icon-512x512.png", 
•       "sizes": "512x512", 
•       "type": "image/png" 
•     } 
•   ] 
• } 
• Service Worker: 
• JavaScript 
• // frontend/public/service-worker.js 
• const CACHE_NAME = 'docuchain-v1'; 
• const urlsToCache = [ 
•   '/', 
•   '/index.html', 
•   '/static/css/main.css', 
•   '/static/js/main.js', 
•   '/icons/icon-192x192.png' 
• ]; 
•  
• // Install service worker 
• self.addEventListener('install', event => { 
•   event.waitUntil( 
•     caches.open(CACHE_NAME) 
•       .then(cache => cache.addAll(urlsToCache)) 
•   ); 
• }); 
•  
• // Cache-first strategy for static assets 
• self.addEventListener('fetch', event => { 
•   if (event.request.url.includes('/api/')) { 
•     // Network-first for API calls 
•     event.respondWith( 
•       fetch(event.request) 
•         .catch(() => caches.match(event.request)) 
•     ); 
•   } else { 
•     // Cache-first for static assets 
•     event.respondWith( 
•       caches.match(event.request) 
•         .then(response => response || fetch(event.request)) 
•     ); 
•   } 
• }); 
•  

• 8.7 Internationalization (i18n) 
• 8.7.1 Supported Languages (Phase 1) 



Language Code Status 

English en-US Complete 

Hindi hi-IN Complete 

Spanish es-ES Planned 

French fr-FR Planned 

• 8.7.2 Implementation 
• React-i18next Configuration: 
• JavaScript 
• // frontend/src/i18n.js 
• import i18n from 'i18next'; 
• import { initReactI18next } from 'react-i18next'; 
• import Backend from 'i18next-http-backend'; 
• import LanguageDetector from 'i18next-browser-languagedetector'; 
•  
• i18n 
•   .use(Backend) 
•   .use(LanguageDetector) 
•   .use(initReactI18next) 
•   .init({ 
•     fallbackLng: 'en', 
•     supportedLngs: ['en', 'hi'], 
•     debug: process.env.NODE_ENV === 'development', 
•      
•     interpolation: { 
•       escapeValue: false 
•     }, 
•      
•     backend: { 
•       loadPath: '/locales/{{lng}}/{{ns}}.json' 
•     } 
•   }); 
•  
• export default i18n; 
• Translation Files: 
• JSON 
• // frontend/public/locales/en/common.json 
• { 



•   "app": { 
•     "name": "DocuChain", 
•     "tagline": "Blockchain Document Management" 
•   }, 
•   "auth": { 
•     "login": "Login", 
•     "logout": "Logout", 
•     "register": "Register", 
•     "email": "Email Address", 
•     "password": "Password", 
•     "forgotPassword": "Forgot Password?" 
•   }, 
•   "dashboard": { 
•     "welcome": "Welcome back, {{name}}!", 
•     "totalUsers": "Total Users", 
•     "totalDocuments": "Total Documents", 
•     "pendingApprovals": "Pending Approvals" 
•   }, 
•   "fileManager": { 
•     "upload": "Upload Document", 
•     "myFiles": "My Files", 
•     "sharedWithMe": "Shared With Me", 
•     "recent": "Recent Files", 
•     "deleteConfirm": "Are you sure you want to delete this file?" 
•   } 
• } 
• JSON 
• // frontend/public/locales/hi/common.json 
• { 
•   "app": { 
•     "name": "डॉकू्यचेन", 
•     "tagline": "ब्लॉकचेन दस्तावेज़ प्रबंधन" 
•   }, 
•   "auth": { 
•     "login": "लॉग इन करें", 
•     "logout": "लॉग आउट", 
•     "register": "पंजीकरण करें", 
•     "email": "ईमेल पता", 
•     "password": "पासवडड", 
•     "forgotPassword": "पासवडड भूल गए?" 
•   }, 
•   "dashboard": { 
•     "welcome": "स्वागत है, {{name}}!", 
•     "totalUsers": "कुल उपयोगकताड", 
•     "totalDocuments": "कुल दस्तावेज़", 
•     "pendingApprovals": "लंबबत अनुमोदन" 
•   } 
• } 
• Usage in Components: 
• React 
• import { useTranslation } from 'react-i18next'; 
•  
• function Dashboard() { 
•   const { t, i18n } = useTranslation(); 
•  



•   const changeLanguage = (lng) => { 
•     i18n.changeLanguage(lng); 
•   }; 
•  
•   return ( 
•     <div> 
•       <h1>{t('dashboard.welcome', { name: user.name })}</h1> 
•        
•       <div className="language-selector"> 
•         <button onClick={() => changeLanguage('en')}>English</button> 
•         <button onClick={() => changeLanguage('hi')}>बहन्दी</button> 
•       </div> 
•        
•       <div className="stats"> 
•         <div className="stat-card"> 
•           <span>{t('dashboard.totalUsers')}</span> 
•           <span>{stats.totalUsers}</span> 
•         </div> 
•       </div> 
•     </div> 
•   ); 
• } 
• 8.7.3 Date & Number Formatting 
• JavaScript 
• // Locale-aware formatting 
• import { format } from 'date-fns'; 
• import { enUS, hi } from 'date-fns/locale'; 
•  
• const locales = { en: enUS, hi: hi }; 
•  
• const formatDate = (date, formatStr, language) => { 
•   return format(date, formatStr, { locale: locales[language] }); 
• }; 
•  
• // Usage 
• formatDate(new Date(), 'PPP', 'en'); // "January 20, 2024" 
• formatDate(new Date(), 'PPP', 'hi'); // "20 जनवरी 2024" 
•  
• // Number formatting 
• const formatNumber = (number, language) => { 
•   return new Intl.NumberFormat(language).format(number); 
• }; 
•  
• formatNumber(1234567, 'en-US'); // "1,234,567" 
• formatNumber(1234567, 'hi-IN'); // "12,34,567" 
•  

• 9. Testing Strategy 
• 9.1 Unit Testing 
• 9.1.1 Frontend Unit Tests (Vitest + React Testing Library) 
• JavaScript 
• // frontend/src/components/__tests__/FileCard.test.jsx 
• import { render, screen, fireEvent } from '@testing-library/react'; 
• import { describe, it, expect, vi } from 'vitest'; 
• import FileCard from '../FileCard'; 



•  
• describe('FileCard', () => { 
•   const mockFile = { 
•     documentId: 'DOC-001', 
•     fileName: 'test.pdf', 
•     fileSize: 2048000, 
•     createdAt: '2024-01-20T10:00:00Z' 
•   }; 
•  
•   it('renders file information correctly', () => { 
•     render(<FileCard file={mockFile} />); 
•      
•     expect(screen.getByText('test.pdf')).toBeInTheDocument(); 
•     expect(screen.getByText(/1.95 MB/)).toBeInTheDocument(); 
•   }); 
•  
•   it('calls onDownload when download button clicked', () => { 
•     const handleDownload = vi.fn(); 
•     render(<FileCard file={mockFile} onDownload={handleDownload} />); 
•      
•     const downloadBtn = screen.getByRole('button', { name: /download/i }); 
•     fireEvent.click(downloadBtn); 
•      
•     expect(handleDownload).toHaveBeenCalledWith('DOC-001'); 
•   }); 
•  
•   it('displays approval status badge', () => { 
•     const approvedFile = { ...mockFile, approvalStatus: 'approved' }; 
•     render(<FileCard file={approvedFile} />); 
•      
•     expect(screen.getByText('Approved')).toHaveClass('status-approved'); 
•   }); 
• }); 
• 9.1.2 Backend Unit Tests (pytest) 
• Python 
• # backend/tests/test_file_service.py 
• import pytest 
• from app.services.file_service import FileService 
• from app.models import Document, User 
•  
• class TestFileService: 
•     def test_upload_document_success(self, mock_user, mock_ipfs): 
•         # Arrange 
•         service = FileService() 
•         file = MockFile('test.pdf', 1024) 
•          
•         # Act 
•         result = service.upload_document( 
•             file=file, 
•             user_id=mock_user.id, 
•             folder_id=None 
•         ) 
•          
•         # Assert 
•         assert result['success'] is True 
•         assert 'documentId' in result 



•         assert 'ipfsHash' in result 
•         mock_ipfs.upload.assert_called_once() 
•      
•     def test_upload_document_exceeds_quota(self, mock_user): 
•         # Arrange 
•         service = FileService() 
•         mock_user.used_storage = 5 * 1024 * 1024 * 1024  # 5GB 
•         file = MockFile('large.pdf', 1024 * 1024 * 1024)  # 1GB 
•          
•         # Act & Assert 
•         with pytest.raises(StorageQuotaExceeded): 
•             service.upload_document(file, mock_user.id, None) 
•      
•     def test_share_document_valid_recipient(self, mock_document, mock_user): 
•         # Arrange 
•         service = FileService() 
•         recipient = User(user_id='USER-002', email='test@example.com') 
•          
•         # Act 
•         result = service.share_document( 
•             document_id=mock_document.document_id, 
•             owner_id=mock_user.id, 
•             recipient_id=recipient.user_id, 
•             permission='read' 
•         ) 
•          
•         # Assert 
•         assert result['success'] is True 
•         assert result['shareId'] is not None 
•  
• # Fixtures 
• @pytest.fixture 
• def mock_user(): 
•     return User( 
•         user_id='USER-001', 
•         email='user@test.com', 
•         role='student', 
•         used_storage=0 
•     ) 
•  
• @pytest.fixture 
• def mock_document(mock_user): 
•     return Document( 
•         document_id='DOC-001', 
•         owner_id=mock_user.id, 
•         ipfs_hash='QmTest123', 
•         file_name='test.pdf' 
•     ) 
•  
• @pytest.fixture 
• def mock_ipfs(monkeypatch): 
•     mock = MagicMock() 
•     mock.upload.return_value = {'IpfsHash': 'QmTest123'} 
•     monkeypatch.setattr('app.services.ipfs_service.IPFSService', lambda: mock) 
•     return mock 
• 9.1.3 Smart Contract Unit Tests (Hardhat) 



• JavaScript 
• // blockchain/test/DocumentManager.test.js 
• const { expect } = require("chai"); 
• const { ethers } = require("hardhat"); 
•  
• describe("DocumentManager", function () { 
•   let documentManager; 
•   let owner, user1, user2; 
•  
•   beforeEach(async function () { 
•     [owner, user1, user2] = await ethers.getSigners(); 
•      
•     const DocumentManager = await ethers.getContractFactory("DocumentManager"); 
•     documentManager = await DocumentManager.deploy(); 
•     await documentManager.deployed(); 
•   }); 
•  
•   describe("Document Upload", function () { 
•     it("Should upload document successfully", async function () { 
•       const tx = await documentManager.connect(user1).uploadDocument( 
•         "QmTest123", 
•         "test.pdf", 
•         1024, 
•         "application/pdf" 
•       ); 
•        
•       const receipt = await tx.wait(); 
•       const event = receipt.events.find(e => e.event === 'DocumentUploaded'); 
•        
•       expect(event.args.owner).to.equal(user1.address); 
•       expect(event.args.ipfsHash).to.equal("QmTest123"); 
•     }); 
•  
•     it("Should revert with empty IPFS hash", async function () { 
•       await expect( 
•         documentManager.uploadDocument("", "test.pdf", 1024, "application/pdf") 
•       ). 
• to.be.revertedWith("IPFS hash cannot be empty"); 

}); 
• text 
• it("Should emit DocumentUploaded event", async function () { 
•   await expect( 
•     documentManager.connect(user1).uploadDocument( 
•       "QmTest123", 
•       "test.pdf", 
•       1024, 
•       "application/pdf" 
•     ) 
•   ).to.emit(documentManager, "DocumentUploaded"); 
• }); 
• }); 
• describe("Document Sharing", function () { 

let documentId; 
• text 
• beforeEach(async function () { 
•   const tx = await documentManager.connect(user1).uploadDocument( 
•     "QmTest123", 



•     "test.pdf", 
•     1024, 
•     "application/pdf" 
•   ); 
•   const receipt = await tx.wait(); 
•   documentId = receipt.events[0].args.documentId; 
• }); 
•  
• it("Should share document with another user", async function () { 
•   await documentManager.connect(user1).shareDocument( 
•     documentId, 
•     user2.address, 
•     "read" 
•   ); 
•  
•   const [hasAccess, permission] = await documentManager.hasAccess( 
•     documentId, 
•     user2.address 
•   ); 
•  
•   expect(hasAccess).to.be.true; 
•   expect(permission).to.equal("read"); 
• }); 
•  
• it("Should revert when non-owner tries to share", async function () { 
•   await expect( 
•     documentManager.connect(user2).shareDocument( 
•       documentId, 
•       user2.address, 
•       "read" 
•     ) 
•   ).to.be.revertedWith("Only owner can share"); 
• }); 
•  
• it("Should prevent sharing with self", async function () { 
•   await expect( 
•     documentManager.connect(user1).shareDocument( 
•       documentId, 
•       user1.address, 
•       "read" 
•     ) 
•   ).to.be.revertedWith("Cannot share with yourself"); 
• }); 
• }); 
• describe("Document Approval", function () { 

let documentId; 
• text 
• beforeEach(async function () { 
•   const tx = await documentManager.connect(user1).uploadDocument( 
•     "QmTest123", 
•     "test.pdf", 
•     1024, 
•     "application/pdf" 
•   ); 
•   const receipt = await tx.wait(); 
•   documentId = receipt.events[0].args.documentId; 
• }); 



•  
• it("Should create approval request", async function () { 
•   const approvers = [user2.address]; 
•   const roles = ["HOD"]; 
•   const sequences = [1]; 
•  
•   const tx = await documentManager.connect(user1).createApprovalRequest( 
•     documentId, 
•     "digital_sign", 
•     "sequential", 
•     approvers, 
•     roles, 
•     sequences 
•   ); 
•  
•   await expect(tx).to.emit(documentManager, "ApprovalRequestCreated"); 
• }); 
•  
• it("Should approve document", async function () { 
•   // Create approval request 
•   const approvers = [user2.address]; 
•   const roles = ["HOD"]; 
•   const sequences = [1]; 
•  
•   const createTx = await documentManager.connect(user1).createApprovalRequest( 
•     documentId, 
•     "digital_sign", 
•     "sequential", 
•     approvers, 
•     roles, 
•     sequences 
•   ); 
•   const receipt = await createTx.wait(); 
•   const requestId = receipt.events[0].args.requestId; 
•  
•   // Approve 
•   const signature = ethers.utils.hexlify(ethers.utils.randomBytes(65)); 
•   await documentManager.connect(user2).approveDocument(requestId, signature); 
•  
•   const [, , , status] = await documentManager.getApprovalRequest(requestId); 
•   expect(status).to.equal("approved"); 
• }); 
• }); 

}); 
• text 
•  
• --- 
•  
• ## 9.2 Integration Testing 
•  
• ### **9.2.1 API Integration Tests** 
•  
• ```python 
• # backend/tests/integration/test_document_workflow.py 
• import pytest 
• from flask import url_for 
•  



• class TestDocumentWorkflow: 
•     """Test complete document lifecycle""" 
•      
•     def test_complete_upload_workflow(self, client, auth_headers, mock_ipfs, 

mock_blockchain): 
•         # Step 1: Upload to IPFS 
•         with open('tests/fixtures/test.pdf', 'rb') as f: 
•             response = client.post( 
•                 '/api/files/upload-to-ipfs', 
•                 data={'file': f}, 
•                 headers=auth_headers 
•             ) 
•          
•         assert response.status_code == 200 
•         data = response.get_json() 
•         ipfs_hash = data['data']['ipfsHash'] 
•          
•         # Step 2: Upload to blockchain 
•         response = client.post( 
•             '/api/files/upload-to-blockchain', 
•             json={ 
•                 'ipfsHash': ipfs_hash, 
•                 'fileName': 'test.pdf', 
•                 'fileSize': 1024, 
•                 'fileType': 'application/pdf', 
•                 'transactionHash': '0xabc123', 
•                 'blockNumber': 12345, 
•                 'documentId': '0x123' 
•             }, 
•             headers=auth_headers 
•         ) 
•          
•         assert response.status_code == 200 
•         document_id = response.get_json()['data']['documentId'] 
•          
•         # Step 3: Verify document appears in my files 
•         response = client.get( 
•             '/api/files/my-documents', 
•             headers=auth_headers 
•         ) 
•          
•         assert response.status_code == 200 
•         documents = response.get_json()['data']['documents'] 
•         assert any(doc['documentId'] == document_id for doc in documents) 
•      
•     def test_complete_approval_workflow(self, client, auth_headers, 

second_user_headers): 
•         # Step 1: Upload document 
•         document_id = self._upload_test_document(client, auth_headers) 
•          
•         # Step 2: Create approval request 
•         response = client.post( 
•             '/api/approvals/requests', 
•             json={ 
•                 'documentId': document_id, 
•                 'approvalType': 'digital_sign', 
•                 'workflowType': 'sequential', 



•                 'approvers': [{ 
•                     'userId': 'USER-002', 
•                     'walletAddress': '0xDEF456', 
•                     'role': 'HOD', 
•                     'sequence': 1 
•                 }] 
•             }, 
•             headers=auth_headers 
•         ) 
•          
•         assert response.status_code == 200 
•         request_id = response.get_json()['data']['approvalRequestId'] 
•          
•         # Step 3: Approver receives request 
•         response = client.get( 
•             '/api/approvals/received', 
•             headers=second_user_headers 
•         ) 
•          
•         requests = response.get_json()['data']['requests'] 
•         assert any(req['approvalRequestId'] == request_id for req in requests) 
•          
•         # Step 4: Approve document 
•         response = client.post( 
•             f'/api/approvals/requests/{request_id}/approve', 
•             json={'signature': '0xSIGNATURE'}, 
•             headers=second_user_headers 
•         ) 
•          
•         assert response.status_code == 200 
•          
•         # Step 5: Verify approval status updated 
•         response = client.get( 
•             f'/api/approvals/my-requests', 
•             headers=auth_headers 
•         ) 
•          
•         requests = response.get_json()['data']['requests'] 
•         approved_request = next( 
•             req for req in requests  
•             if req['approvalRequestId'] == request_id 
•         ) 
•         assert approved_request['status'] == 'approved' 
•      
•     def _upload_test_document(self, client, headers): 
•         """Helper to upload a test document""" 
•         response = client.post( 
•             '/api/files/upload-to-blockchain', 
•             json={ 
•                 'ipfsHash': 'QmTest123', 
•                 'fileName': 'test.pdf', 
•                 'fileSize': 1024, 
•                 'fileType': 'application/pdf', 
•                 'transactionHash': '0xabc123', 
•                 'blockNumber': 12345, 
•                 'documentId': '0x123' 
•             }, 



•             headers=headers 
•         ) 
•         return response.get_json()['data']['documentId'] 
• 9.2.2 Frontend Integration Tests 
• JavaScript 
• // frontend/src/__tests__/integration/DocumentUpload.test.jsx 
• import { render, screen, waitFor } from '@testing-library/react'; 
• import userEvent from '@testing-library/user-event'; 
• import { rest } from 'msw'; 
• import { setupServer } from 'msw/node'; 
• import FileManager from '../../pages/FileManager'; 
•  
• const server = setupServer( 
•   rest.post('/api/files/upload-to-ipfs', (req, res, ctx) => { 
•     return res(ctx.json({ 
•       success: true, 
•       data: { ipfsHash: 'QmTest123' } 
•     })); 
•   }), 
•    
•   rest.post('/api/files/upload-to-blockchain', (req, res, ctx) => { 
•     return res(ctx.json({ 
•       success: true, 
•       data: { documentId: 'DOC-001' } 
•     })); 
•   }) 
• ); 
•  
• beforeAll(() => server.listen()); 
• afterEach(() => server.resetHandlers()); 
• afterAll(() => server.close()); 
•  
• describe('Document Upload Flow', () => { 
•   it('uploads document successfully', async () => { 
•     const user = userEvent.setup(); 
•     render(<FileManager />); 
•      
•     // Select file 
•     const file = new File(['test content'], 'test.pdf', { type: 'application/pdf' 

}); 
•     const input = screen.getByLabelText(/upload/i); 
•     await user.upload(input, file); 
•      
•     // Wait for IPFS upload 
•     await waitFor(() => { 
•       expect(screen.getByText(/uploading to ipfs/i)).toBeInTheDocument(); 
•     }); 
•      
•     // Wait for blockchain confirmation 
•     await waitFor(() => { 
•       expect(screen.getByText(/confirm blockchain 

transaction/i)).toBeInTheDocument(); 
•     }); 
•      
•     // Click confirm 
•     const confirmButton = screen.getByRole('button', { name: /confirm/i }); 



•     await user.click(confirmButton); 
•      
•     // Verify success message 
•     await waitFor(() => { 
•       expect(screen.getByText(/upload successful/i)).toBeInTheDocument(); 
•     }); 
•      
•     // Verify document appears in list 
•     expect(screen.getByText('test.pdf')).toBeInTheDocument(); 
•   }); 
•  
•   it('handles upload failure gracefully', async () => { 
•     server.use( 
•       rest.post('/api/files/upload-to-ipfs', (req, res, ctx) => { 
•         return res(ctx.status(500), ctx.json({ error: 'Upload failed' })); 
•       }) 
•     ); 
•      
•     const user = userEvent.setup(); 
•     render(<FileManager />); 
•      
•     const file = new File(['test'], 'test.pdf', { type: 'application/pdf' }); 
•     const input = screen.getByLabelText(/upload/i); 
•     await user.upload(input, file); 
•      
•     await waitFor(() => { 
•       expect(screen.getByText(/upload failed/i)).toBeInTheDocument(); 
•     }); 
•   }); 
• }); 
•  

• 9.3 End-to-End Testing 
• 9.3.1 Playwright E2E Tests 
• JavaScript 
• // frontend/e2e/approval-workflow.spec.js 
• import { test, expect } from '@playwright/test'; 
•  
• test.describe('Document Approval Workflow', () => { 
•   test.beforeEach(async ({ page }) => { 
•     // Login as student 
•     await page.goto('http://localhost:3000/login'); 
•     await page.fill('input[name="email"]', 'student@test.com'); 
•     await page.fill('input[name="password"]', 'password123'); 
•     await page.click('button[type="submit"]'); 
•     await expect(page).toHaveURL(/.*dashboard/); 
•   }); 
•  
•   test('Student requests document approval from faculty', async ({ page, browser 

}) => { 
•     // Student uploads document 
•     await page.click('text=My Files'); 
•     await page.setInputFiles('input[type="file"]', 

'tests/fixtures/certificate.pdf'); 
•     await page.click('button:has-text("Upload to Blockchain")'); 
•      



•     // Wait for MetaMask popup (in real test, mock this) 
•     await page.waitForTimeout(2000); 
•      
•     // Request approval 
•     await page.click('text=Request Approval'); 
•     await page.selectOption('select[name="approver"]', 'USER-003'); 
•     await page.fill('input[name="role"]', 'HOD'); 
•     await page.click('button:has-text("Send Request")'); 
•      
•     await expect(page.locator('text=Approval request sent')).toBeVisible(); 
•      
•     // Open new context as faculty 
•     const facultyContext = await browser.newContext(); 
•     const facultyPage = await facultyContext.newPage(); 
•      
•     // Login as faculty 
•     await facultyPage.goto('http://localhost:3000/login'); 
•     await facultyPage.fill('input[name="email"]', 'faculty@test.com'); 
•     await facultyPage.fill('input[name="password"]', 'password123'); 
•     await facultyPage.click('button[type="submit"]'); 
•      
•     // Check approval requests 
•     await facultyPage.click('text=Approvals'); 
•     await facultyPage.click('text=Requests Received'); 
•      
•     // Find pending request 
•     await expect(facultyPage.locator('text=certificate.pdf')).toBeVisible(); 
•      
•     // Approve document 
•     await facultyPage.click('button:has-text("Approve")'); 
•     await facultyPage.click('button:has-text("Confirm")'); 
•      
•     // Wait for blockchain transaction 
•     await facultyPage.waitForSelector('text=Document approved successfully'); 
•      
•     // Switch back to student view 
•     await page.reload(); 
•     await page.click('text=My Requests'); 
•      
•     // Verify approval status 
•     await expect(page.locator('text=Approved')).toBeVisible(); 
•      
•     await facultyContext.close(); 
•   }); 
•  
•   test('Parallel approval workflow', async ({ page }) => { 
•     // Test parallel approval with multiple approvers 
•     await page.click('text=My Files'); 
•     await page.click('text=test-document.pdf'); 
•     await page.click('text=Request Approval'); 
•      
•     // Add multiple approvers 
•     await page.click('button:has-text("Add Approver")'); 
•     await page.selectOption('select[name="approvers[0]"]', 'USER-003'); 
•     await page.fill('input[name="roles[0]"]', 'HOD'); 
•      



•     await page.click('button:has-text("Add Approver")'); 
•     await page.selectOption('select[name="approvers[1]"]', 'USER-001'); 
•     await page.fill('input[name="roles[1]"]', 'Principal'); 
•      
•     // Select parallel workflow 
•     await page.check('input[value="parallel"]'); 
•      
•     await page.click('button:has-text("Send Request")'); 
•      
•     await expect(page.locator('text=Approval request sent to 2 

approvers')).toBeVisible(); 
•   }); 
• }); 
• 9.3.2 Cypress E2E Tests 
• JavaScript 
• // frontend/cypress/e2e/file-sharing.cy.js 
• describe('File Sharing', () => { 
•   beforeEach(() => { 
•     cy.login('user@test.com', 'password'); 
•     cy.visit('/dashboard/files'); 
•   }); 
•  
•   it('shares document with another user', () => { 
•     // Upload document first 
•     cy.uploadDocument('test-document.pdf'); 
•      
•     // Open share modal 
•     cy.get('[data-testid="document-card"]').first().within(() => { 
•       cy.get('button[aria-label="Share"]').click(); 
•     }); 
•      
•     // Select recipient 
•     cy.get('select[name="recipient"]').select('USER-002'); 
•      
•     // Set permission 
•     cy.get('input[value="read"]').check(); 
•      
•     // Add message 
•     cy.get('textarea[name="message"]').type('Please review this document'); 
•      
•     // Submit 
•     cy.get('button:contains("Share")'). 
• click(); 
• text 
• // Verify success message 
• cy.contains('Document shared successfully').should('be.visible'); 
•  
• // Verify blockchain transaction 
• cy.get('[data-testid="transaction-hash"]').should('exist'); 
•  
• // Logout and login as recipient 
• cy.logout(); 
• cy.login('user2@test.com', 'password'); 
•  
• // Check shared files 
• cy.visit('/dashboard/files/shared-with-me'); 



• cy.contains('test-document.pdf').should('be.visible'); 
•  
• // Verify read-only access 
• cy.get('[data-testid="document-card"]').first().within(() => { 
•   cy.get('button:contains("Download")').should('exist'); 
•   cy.get('button:contains("Delete")').should('not.exist'); 
• }); 
• }); 
• it('revokes sharing access', () => { 

cy.get('[data-testid="document-card"]').first().click(); 
cy.get('button:contains("View Shares")').click(); 

• text 
• // Find shared user 
• cy.get('[data-testid="shared-user"]').contains('John Doe').within(() => { 
•   cy.get('button:contains("Revoke")').click(); 
• }); 
•  
• cy.get('button:contains("Confirm Revoke")').click(); 
•  
• cy.contains('Access revoked successfully').should('be.visible'); 
• }); 

}); 
• text 
•  
• --- 
•  
• ## 9.4 Security Testing 
•  
• ### **9.4.1 SQL Injection Tests** 
•  
• ```python 
• # backend/tests/security/test_sql_injection.py 
• import pytest 
•  
• class TestSQLInjection: 
•     """Test SQL injection vulnerabilities""" 
•      
•     def test_search_query_sql_injection(self, client, auth_headers): 
•         # Attempt SQL injection in search 
•         malicious_queries = [ 
•             "'; DROP TABLE users; --", 
•             "' OR '1'='1", 
•             "admin'--", 
•             "' UNION SELECT * FROM users--" 
•         ] 
•          
•         for query in malicious_queries: 
•             response = client.get( 
•                 f'/api/files/search?q={query}', 
•                 headers=auth_headers 
•             ) 
•              
•             # Should not cause error or return unauthorized data 
•             assert response.status_code in [200, 400] 
•              
•             if response.status_code == 200: 
•                 data = response.get_json() 



•                 # Verify no sensitive data leaked 
•                 assert 'password' not in str(data).lower() 
•                 assert 'private_key' not in str(data).lower() 
•      
•     def test_user_id_sql_injection(self, client, auth_headers): 
•         # Attempt injection via user ID parameter 
•         response = client.get( 
•             "/api/users/1' OR '1'='1", 
•             headers=auth_headers 
•         ) 
•          
•         # Should return 404 or 400, not 200 
•         assert response.status_code in [400, 404] 
• 9.4.2 XSS Tests 
• Python 
• # backend/tests/security/test_xss.py 
• class TestXSS: 
•     """Test Cross-Site Scripting vulnerabilities""" 
•      
•     def test_document_name_xss(self, client, auth_headers): 
•         # Attempt XSS in document name 
•         xss_payloads = [ 
•             "<script>alert('XSS')</script>", 
•             "<img src=x onerror=alert('XSS')>", 
•             "javascript:alert('XSS')", 
•             "<svg/onload=alert('XSS')>" 
•         ] 
•          
•         for payload in xss_payloads: 
•             response = client.post( 
•                 '/api/files/upload-to-blockchain', 
•                 json={ 
•                     'fileName': payload, 
•                     'ipfsHash': 'QmTest', 
•                     'fileSize': 1024, 
•                     'fileType': 'text/plain', 
•                     'transactionHash': '0xabc', 
•                     'blockNumber': 123, 
•                     'documentId': '0x123' 
•                 }, 
•                 headers=auth_headers 
•             ) 
•              
•             # Should either sanitize or reject 
•             if response.status_code == 200: 
•                 data = response.get_json() 
•                 # Verify HTML entities are escaped 
•                 assert '<script>' not in data['data']['fileName'] 
•                 assert '&lt;script&gt;' in data['data']['fileName'] or \ 
•                        payload not in data['data']['fileName'] 
•      
•     def test_circular_content_xss(self, client, admin_headers): 
•         response = client.post( 
•             '/api/circulars', 
•             json={ 
•                 'title': 'Test', 



•                 'content': '<script>alert("XSS")</script>', 
•                 'circularNumber': 'TEST/001', 
•                 'issueDate': '2024-01-20', 
•                 'priority': 'medium', 
•                 'targetAudience': 'all' 
•             }, 
•             headers=admin_headers 
•         ) 
•          
•         # Content should be sanitized 
•         if response.status_code == 200: 
•             data = response.get_json() 
•             assert '<script>' not in data['data']['content'] 
• 9.4.3 Authentication & Authorization Tests 
• Python 
• # backend/tests/security/test_auth.py 
• class TestAuthentication: 
•     """Test authentication security""" 
•      
•     def test_access_without_token(self, client): 
•         # Attempt to access protected endpoint without token 
•         response = client.get('/api/files/my-documents') 
•         assert response.status_code == 401 
•      
•     def test_access_with_expired_token(self, client): 
•         # Use expired token 
•         expired_token = generate_expired_token() 
•         response = client.get( 
•             '/api/files/my-documents', 
•             headers={'Authorization': f'Bearer {expired_token}'} 
•         ) 
•         assert response.status_code == 401 
•      
•     def test_access_with_invalid_token(self, client): 
•         response = client.get( 
•             '/api/files/my-documents', 
•             headers={'Authorization': 'Bearer invalid.token.here'} 
•         ) 
•         assert response.status_code == 401 
•      
•     def test_role_based_access_control(self, client, student_headers, 

admin_headers): 
•         # Student cannot access admin endpoints 
•         response = client.get( 
•             '/api/admin/users', 
•             headers=student_headers 
•         ) 
•         assert response.status_code == 403 
•          
•         # Admin can access admin endpoints 
•         response = client.get( 
•             '/api/admin/users', 
•             headers=admin_headers 
•         ) 
•         assert response.status_code == 200 
•      



•     def test_cannot_access_other_users_documents(self, client, auth_headers): 
•         # Try to access document owned by another user 
•         response = client.get( 
•             '/api/files/DOC-999',  # Document owned by another user 
•             headers=auth_headers 
•         ) 
•         assert response.status_code in [403, 404] 
• 9.4.4 Smart Contract Security Tests 
• JavaScript 
• // blockchain/test/security/DocumentManager.security.test.js 
• const { expect } = require("chai"); 
• const { ethers } = require("hardhat"); 
•  
• describe("DocumentManager Security", function () { 
•   let contract, owner, attacker; 
•  
•   beforeEach(async function () { 
•     [owner, attacker] = await ethers.getSigners(); 
•     const DocumentManager = await ethers.getContractFactory("DocumentManager"); 
•     contract = await DocumentManager.deploy(); 
•   }); 
•  
•   describe("Reentrancy Protection", function () { 
•     it("should prevent reentrancy attacks", async function () { 
•       // Deploy malicious contract 
•       const Attacker = await ethers.getContractFactory("ReentrancyAttacker"); 
•       const attackerContract = await Attacker.deploy(contract.address); 
•        
•       // Attempt reentrancy attack 
•       await expect( 
•         attackerContract.attack() 
•       ).to.be.reverted; 
•     }); 
•   }); 
•  
•   describe("Access Control", function () { 
•     it("should prevent unauthorized document modification", async function () { 
•       // Upload document as owner 
•       const tx = await contract.connect(owner).uploadDocument( 
•         "QmTest", "test.pdf", 1024, "application/pdf" 
•       ); 
•       const receipt = await tx.wait(); 
•       const docId = receipt.events[0].args.documentId; 
•        
•       // Attempt to delete as attacker 
•       await expect( 
•         contract.connect(attacker).deleteDocument(docId) 
•       ).to.be.revertedWith("Only owner can delete document"); 
•     }); 
•  
•     it("should prevent approval by unauthorized user", async function () { 
•       // Create approval request 
•       const tx = await contract.connect(owner).uploadDocument( 
•         "QmTest", "test.pdf", 1024, "application/pdf" 
•       ); 
•       const receipt = await tx.wait(); 



•       const docId = receipt.events[0].args.documentId; 
•        
•       const requestTx = await contract.connect(owner).createApprovalRequest( 
•         docId, "digital_sign", "sequential", 
•         [owner.address], ["HOD"], [1] 
•       ); 
•       const requestReceipt = await requestTx.wait(); 
•       const requestId = requestReceipt.events[0].args.requestId; 
•        
•       // Attempt to approve as non-approver 
•       await expect( 
•         contract.connect(attacker).approveDocument(requestId, "0xSIG") 
•       ).to.be.revertedWith("Not authorized to approve"); 
•     }); 
•   }); 
•  
•   describe("Integer Overflow/Underflow", function () { 
•     it("should handle large file sizes safely", async function () { 
•       const maxUint256 = ethers.constants.MaxUint256; 
•        
•       await expect( 
•         contract.uploadDocument("QmTest", "huge.pdf", maxUint256, 

"application/pdf") 
•       ).to.not.be.reverted; 
•     }); 
•   }); 
•  
•   describe("Front-Running Protection", function () { 
•     it("should prevent front-running of approvals", async function () { 
•       // This would require more complex testing with mempool simulation 
•       // Placeholder for front-running tests 
•     }); 
•   }); 
• }); 
•  

• 9.5 Performance Testing 
• 9.5.1 Load Testing with Locust 
• Python 
• # backend/tests/performance/locustfile.py 
• from locust import HttpUser, task, between 
• import random 
•  
• class DocuChainUser(HttpUser): 
•     wait_time = between(1, 3) 
•      
•     def on_start(self): 
•         """Login before starting tasks""" 
•         response = self.client.post("/api/auth/login", json={ 
•             "email": "test@example.com", 
•             "password": "password123" 
•         }) 
•         self.token = response.json()['data']['token'] 
•         self.headers = {'Authorization': f'Bearer {self.token}'} 
•      
•     @task(3) 



•     def view_dashboard(self): 
•         """View dashboard - most common action""" 
•         self.client.get("/api/dashboard", headers=self.headers) 
•      
•     @task(5) 
•     def list_documents(self): 
•         """List documents - very common""" 
•         self.client.get("/api/files/my-documents", headers=self.headers) 
•      
•     @task(2) 
•     def search_documents(self): 
•         """Search documents""" 
•         query = random.choice(['report', 'certificate', 'letter']) 
•         self.client.get( 
•             f"/api/files/search?q={query}", 
•             headers=self.headers 
•         ) 
•      
•     @task(1) 
•     def upload_document(self): 
•         """Upload document - less common""" 
•         files = {'file': ('test.pdf', b'fake pdf content', 'application/pdf')} 
•         self.client.post( 
•             "/api/files/upload-to-ipfs", 
•             files=files, 
•             headers=self.headers 
•         ) 
•      
•     @task(2) 
•     def view_circulars(self): 
•         """View circular feed""" 
•         self.client.get("/api/circulars/feed", headers=self.headers) 
•      
•     @task(1) 
•     def check_notifications(self): 
•         """Check notifications""" 
•         self.client.get("/api/notifications", headers=self.headers) 
•  
• class AdminUser(HttpUser): 
•     wait_time = between(2, 5) 
•      
•     def on_start(self): 
•         response = self.client.post("/api/auth/login", json={ 
•             "email": "admin@example.com", 
•             "password": "adminpass" 
•         }) 
•         self.token = response.json()['data']['token'] 
•         self.headers = {'Authorization': f'Bearer {self.token}'} 
•      
•     @task 
•     def view_users(self): 
•         self.client.get("/api/admin/users", headers=self.headers) 
•      
•     @task 
•     def view_account_requests(self): 
•         self.client.get("/api/admin/account-requests", headers=self.headers) 



•  
• # Run with: locust -f locustfile.py --host=http://localhost:5000 
• 9.5.2 Stress Testing Scenarios 
• Python 
• # Stress test configuration 
• # Test with: locust -f locustfile.py --users 1000 --spawn-rate 50 
•  
• # Scenario 1: Normal Load 
• # - 500 concurrent users 
• # - 100 requests/second 
• # - Duration: 30 minutes 
•  
• # Scenario 2: Peak Load 
• # - 1000 concurrent users 
• # - 200 requests/second 
• # - Duration: 15 minutes 
•  
• # Scenario 3: Spike Test 
• # - Ramp from 100 to 2000 users in 5 minutes 
• # - Hold for 10 minutes 
• # - Ramp down to 100 in 5 minutes 
•  
• # Expected Results: 
• # - Response time p95 < 1 second 
• # - Error rate < 1% 
• # - No memory leaks 
• # - Database connections stable 
• 9.5.3 Database Performance Tests 
• SQL 
• -- Test query performance 
• EXPLAIN ANALYZE 
• SELECT d.*, u.first_name, u.last_name, f.name as folder_name 
• FROM documents d 
• JOIN users u ON d.owner_id = u.id 
• LEFT JOIN folders f ON d.folder_id = f.id 
• WHERE d.owner_id = 1 
•   AND d.is_deleted = FALSE 
• ORDER BY d.created_at DESC 
• LIMIT 50; 
•  
• -- Should use index: idx_documents_owner_deleted 
• -- Execution time should be < 10ms 
•  
• -- Test join performance 
• EXPLAIN ANALYZE 
• SELECT COUNT(*) 
• FROM documents d 
• JOIN document_shares ds ON d.id = ds.document_id 
• WHERE ds.shared_with = 1 
•   AND ds.is_active = TRUE; 
•  
• -- Should use indexes: idx_shares_recipient 
• -- Execution time should be < 20ms 
•  

• 9.6 Test Coverage Requirements 



• 9.6.1 Coverage Targets 

Component Target Coverage Minimum Coverage 

Backend (Python) 85% 75% 

Frontend (React) 80% 70% 

Smart Contracts 95% 90% 

API Endpoints 100% 90% 

Critical Paths 100% 100% 

• 9.6.2 Coverage Reporting 
• Backend Coverage (pytest-cov): 
• Bash 
• # Run tests with coverage 
• pytest --cov=app --cov-report=html --cov-report=term 
•  
• # Coverage report 
• Name                          Stmts   Miss  Cover 
• ------------------------------------------------- 
• app/__init__.py                  25      0   100% 
• app/models/user.py              120      5    96% 
• app/services/file_service.py    250     25    90% 
• app/api/files/routes.py         180     20    89% 
• ------------------------------------------------- 
• TOTAL                          1450    125    91% 
• Frontend Coverage (Vitest): 
• Bash 
• # Run tests with coverage 
• vitest run --coverage 
•  
• # Output 
• File                    | % Stmts | % Branch | % Funcs | % Lines 
• --------------------|---------|----------|---------|-------- 
• components/         |   82.5  |   78.3   |   85.2  |   83. 



• 1 
services/ | 88.7 | 82.5 | 90.3 | 89.2 
hooks/ | 91.2 | 87.8 | 93.5 | 91.8 

utils/ 95.3 91.2 96.7 95.8 

All files 85.4 82.1 88.9 86.2 

• text 
•  
• **Smart Contract Coverage (Hardhat):** 
• ```bash 
• # Run coverage 
• npx hardhat coverage 
•  
• # Output 
• ----------------------|----------|----------|----------|----------| 
• File                  |  % Stmts | % Branch |  % Funcs |  % Lines | 
• ----------------------|----------|----------|----------|----------| 
• contracts/            |      100 |    96.67 |      100 |      100 | 
•   DocumentManager.sol |      100 |    96.67 |      100 |      100 | 
•   AccessControl.sol   |      100 |      100 |      100 |      100 | 
•   ApprovalWorkflow.sol|      100 |    95.45 |      100 |      100 | 
• ----------------------|----------|----------|----------|----------| 
• All files             |      100 |    96.67 |      100 |      100 | 
• ----------------------|----------|----------|----------|----------| 
•  

• 10. Deployment Architecture 
• 10.1 Environment Configurations 
• 10.1.1 Development Environment 
• YAML 
• # docker-compose.dev.yml 
• version: '3.8' 
•  
• services: 
•   # PostgreSQL Development Database 
•   db: 
•     image: postgres:15-alpine 
•     container_name: docuchain-dev-db 
•     environment: 
•       POSTGRES_DB: docuchain_dev 
•       POSTGRES_USER: dev_user 
•       POSTGRES_PASSWORD: dev_password 
•     ports: 
•       - "5432:5432" 
•     volumes: 
•       - dev_postgres_data:/var/lib/postgresql/data 
•     networks: 



•       - docuchain-dev 
•  
•   # Redis Development Cache 
•   redis: 
•     image: redis:7-alpine 
•     container_name: docuchain-dev-redis 
•     ports: 
•       - "6379:6379" 
•     networks: 
•       - docuchain-dev 
•  
•   # Backend Development Server (with hot reload) 
•   backend: 
•     build: 
•       context: ./backend 
•       dockerfile: Dockerfile.dev 
•     container_name: docuchain-dev-backend 
•     environment: 
•       - FLASK_ENV=development 
•       - DATABASE_URL=postgresql://dev_user:dev_password@db:5432/docuchain_dev 
•       - REDIS_URL=redis://redis:6379/0 
•       - PINATA_API_KEY=${PINATA_API_KEY} 
•       - PINATA_SECRET_KEY=${PINATA_SECRET_KEY} 
•       - JWT_SECRET_KEY=dev-secret-key-change-in-production 
•       - ETHEREUM_RPC_URL=${SEPOLIA_RPC_URL} 
•       - CONTRACT_ADDRESS=${CONTRACT_ADDRESS} 
•       - DEBUG=True 
•     volumes: 
•       - ./backend:/app 
•       - backend_dev_logs:/app/logs 
•     ports: 
•       - "5000:5000" 
•     depends_on: 
•       - db 
•       - redis 
•     command: flask run --host=0.0.0.0 --reload 
•     networks: 
•       - docuchain-dev 
•  
•   # Frontend Development Server (with hot reload) 
•   frontend: 
•     build: 
•       context: ./frontend 
•       dockerfile: Dockerfile.dev 
•     container_name: docuchain-dev-frontend 
•     environment: 
•       - VITE_API_URL=http://localhost:5000/api 
•       - VITE_WS_URL=http://localhost:5000 
•       - VITE_CONTRACT_ADDRESS=${CONTRACT_ADDRESS} 
•       - VITE_CHAIN_ID=11155111 
•       - VITE_ENVIRONMENT=development 
•     volumes: 
•       - ./frontend:/app 
•       - /app/node_modules 
•     ports: 
•       - "3000:3000" 



•     command: npm run dev 
•     networks: 
•       - docuchain-dev 
•  
•   # Ganache Local Blockchain (for testing) 
•   ganache: 
•     image: trufflesuite/ganache:latest 
•     container_name: docuchain-dev-ganache 
•     ports: 
•       - "8545:8545" 
•     command: > 
•       --deterministic 
•       --accounts=10 
•       --defaultBalanceEther=1000 
•       --mnemonic="test test test test test test test test test test test junk" 
•     networks: 
•       - docuchain-dev 
•  
• volumes: 
•   dev_postgres_data: 
•   backend_dev_logs: 
•  
• networks: 
•   docuchain-dev: 
•     driver: bridge 
• 10.1.2 Staging Environment 
• YAML 
• # docker-compose.staging.yml 
• version: '3.8' 
•  
• services: 
•   db: 
•     image: postgres:15-alpine 
•     environment: 
•       POSTGRES_DB: docuchain_staging 
•       POSTGRES_USER: ${STAGING_DB_USER} 
•       POSTGRES_PASSWORD: ${STAGING_DB_PASSWORD} 
•     volumes: 
•       - staging_postgres_data:/var/lib/postgresql/data 
•     networks: 
•       - docuchain-staging 
•  
•   redis: 
•     image: redis:7-alpine 
•     command: redis-server --requirepass ${REDIS_PASSWORD} 
•     volumes: 
•       - staging_redis_data:/data 
•     networks: 
•       - docuchain-staging 
•  
•   backend: 
•     build: 
•       context: ./backend 
•       dockerfile: Dockerfile.prod 
•     environment: 
•       - FLASK_ENV=staging 



•       - 
DATABASE_URL=postgresql://${STAGING_DB_USER}:${STAGING_DB_PASSWORD}@db:5432/docuc
hain_staging 

•       - REDIS_URL=redis://:${REDIS_PASSWORD}@redis:6379/0 
•       - JWT_SECRET_KEY=${JWT_SECRET_KEY} 
•       - PINATA_API_KEY=${PINATA_API_KEY} 
•       - PINATA_SECRET_KEY=${PINATA_SECRET_KEY} 
•       - ETHEREUM_RPC_URL=${SEPOLIA_RPC_URL} 
•       - CONTRACT_ADDRESS=${CONTRACT_ADDRESS} 
•       - SENTRY_DSN=${SENTRY_DSN} 
•     volumes: 
•       - staging_backend_logs:/app/logs 
•     ports: 
•       - "5000:5000" 
•     depends_on: 
•       - db 
•       - redis 
•     command: gunicorn -w 4 -b 0.0.0.0:5000 wsgi:app 
•     networks: 
•       - docuchain-staging 
•     restart: always 
•  
•   frontend: 
•     build: 
•       context: ./frontend 
•       dockerfile: Dockerfile.prod 
•     environment: 
•       - VITE_API_URL=https://staging-api.docuchain.app/api 
•       - VITE_WS_URL=wss://staging-api.docuchain.app 
•       - VITE_CONTRACT_ADDRESS=${CONTRACT_ADDRESS} 
•       - VITE_CHAIN_ID=11155111 
•       - VITE_SENTRY_DSN=${FRONTEND_SENTRY_DSN} 
•       - VITE_ENVIRONMENT=staging 
•     networks: 
•       - docuchain-staging 
•     restart: always 
•  
•   nginx: 
•     image: nginx:alpine 
•     volumes: 
•       - ./nginx/staging.conf:/etc/nginx/nginx.conf 
•       - ./ssl/staging:/etc/ssl/certs 
•       - ./frontend/dist:/usr/share/nginx/html 
•     ports: 
•       - "80:80" 
•       - "443:443" 
•     depends_on: 
•       - frontend 
•       - backend 
•     networks: 
•       - docuchain-staging 
•     restart: always 
•  
• volumes: 
•   staging_postgres_data: 
•   staging_redis_data: 



•   staging_backend_logs: 
•  
• networks: 
•   docuchain-staging: 
•     driver: bridge 
• 10.1.3 Production Environment 
• YAML 
• # docker-compose.prod.yml 
• version: '3.8' 
•  
• services: 
•   db: 
•     image: postgres:15-alpine 
•     environment: 
•       POSTGRES_DB: docuchain_prod 
•       POSTGRES_USER: ${PROD_DB_USER} 
•       POSTGRES_PASSWORD: ${PROD_DB_PASSWORD} 
•       POSTGRES_INITDB_ARGS: "--encoding=UTF8 --locale=en_US.UTF-8" 
•     volumes: 
•       - prod_postgres_data:/var/lib/postgresql/data 
•     networks: 
•       - docuchain-prod 
•     deploy: 
•       replicas: 1 
•       placement: 
•         constraints: 
•           - node.role == manager 
•       resources: 
•         limits: 
•           cpus: '2' 
•           memory: 4G 
•         reservations: 
•           cpus: '1' 
•           memory: 2G 
•     restart: always 
•     healthcheck: 
•       test: ["CMD-SHELL", "pg_isready -U ${PROD_DB_USER}"] 
•       interval: 10s 
•       timeout: 5s 
•       retries: 5 
•  
•   redis: 
•     image: redis:7-alpine 
•     command: > 
•       redis-server 
•       --requirepass ${REDIS_PASSWORD} 
•       --maxmemory 2gb 
•       --maxmemory-policy allkeys-lru 
•       --appendonly yes 
•     volumes: 
•       - prod_redis_data:/data 
•     networks: 
•       - docuchain-prod 
•     deploy: 
•       replicas: 1 
•       resources: 



•         limits: 
•           cpus: '1' 
•           memory: 2G 
•     restart: always 
•     healthcheck: 
•       test: ["CMD", "redis-cli", "ping"] 
•       interval: 10s 
•       timeout: 3s 
•       retries: 5 
•  
•   backend: 
•     image: docuchain/backend:${VERSION} 
•     environment: 
•       - FLASK_ENV=production 
•       - 

DATABASE_URL=postgresql://${PROD_DB_USER}:${PROD_DB_PASSWORD}@db:5432/docuchain_p
rod 

•       - REDIS_URL=redis://:${REDIS_PASSWORD}@redis:6379/0 
•       - JWT_SECRET_KEY=${JWT_SECRET_KEY} 
•       - PINATA_API_KEY=${PINATA_API_KEY} 
•       - PINATA_SECRET_KEY=${PINATA_SECRET_KEY} 
•       - ETHEREUM_RPC_URL=${MAINNET_RPC_URL} 
•       - CONTRACT_ADDRESS=${PROD_CONTRACT_ADDRESS} 
•       - SENTRY_DSN=${BACKEND_SENTRY_DSN} 
•       - NEW_RELIC_LICENSE_KEY=${NEW_RELIC_KEY} 
•     volumes: 
•       - prod_backend_logs:/app/logs 
•     ports: 
•       - "5000:5000" 
•     depends_on: 
•       - db 
•       - redis 
•     command: gunicorn -w 8 -b 0.0.0.0:5000 --timeout 120 --graceful-timeout 30 

wsgi:app 
•     networks: 
•       - docuchain-prod 
•     deploy: 
•       replicas: 3 
•       update_config: 
•         parallelism: 1 
•         delay: 10s 
•         failure_action: rollback 
•       rollback_config: 
•         parallelism: 1 
•         delay: 10s 
•       resources: 
•         limits: 
•           cpus: '2' 
•           memory: 2G 
•         reservations: 
•           cpus: '1' 
•           memory: 1G 
•     restart: always 
•     healthcheck: 
•       test: ["CMD", "curl", "-f", "http://localhost:5000/health"] 
•       interval: 30s 



•       timeout: 10s 
•       retries: 3 
•  
•   celery-worker: 
•     image: docuchain/backend:${VERSION} 
•     environment: 
•       - FLASK_ENV=production 
•       - 

DATABASE_URL=postgresql://${PROD_DB_USER}:${PROD_DB_PASSWORD}@db:5432/docuchain_p
rod 

•       - REDIS_URL=redis://:${REDIS_PASSWORD}@redis:6379/0 
•     command: celery -A app.celery_worker worker --loglevel=info --concurrency=4 
•     depends_on: 
•       - db 
•       - redis 
•     networks: 
•       - docuchain-prod 
•     deploy: 
•       replicas: 2 
•       resources: 
•         limits: 
•           cpus: '2' 
•           memory: 2G 
•     restart: always 
•  
•   celery-beat: 
•     image: docuchain/backend:${VERSION} 
•     environment: 
•       - FLASK_ENV=production 
•       - 

DATABASE_URL=postgresql://${PROD_DB_USER}:${PROD_DB_PASSWORD}@db:5432/docuchain_p
rod 

•       - REDIS_URL=redis://:${REDIS_PASSWORD}@redis:6379/0 
•     command: celery -A app.celery_worker beat --loglevel=info 
•     depends_on: 
•       - db 
•       - redis 
•     networks: 
•       - docuchain-prod 
•     deploy: 
•       replicas: 1 
•     restart: always 
•  
•   frontend: 
•     image: docuchain/frontend:${VERSION} 
•     networks: 
•       - docuchain-prod 
•     deploy: 
•       replicas: 2 
•       resources: 
•         limits: 
•           cpus: '0.5' 
•           memory: 512M 
•     restart: always 
•  
•   nginx: 



•     image: nginx:alpine 
•     volumes: 
•       - ./nginx/production.conf:/etc/nginx/nginx.conf 
•       - ./ssl/production:/etc/ssl/certs 
•       - ./frontend/dist:/usr/share/nginx/html 
•     ports: 
•       - "80:80" 
•       - "443:443" 
•     depends_on: 
•       - frontend 
•       - backend 
•     networks: 
•       - docuchain-prod 
•     deploy: 
•       replicas: 2 
•       resources: 
•         limits: 
•           cpus: '1' 
•           memory: 512M 
•     restart: always 
•     healthcheck: 
•       test: ["CMD", "curl", "-f", "http://localhost/health"] 
•       interval: 30s 
•       timeout: 10s 
•       retries: 3 
•  
•   # Monitoring 
•   prometheus: 
•     image: prom/prometheus:latest 
•     volumes: 
•       - ./monitoring/prometheus.yml:/etc/prometheus/prometheus.yml 
•       - prometheus_data:/prometheus 
•     ports: 
•       - "9090:9090" 
•     networks: 
•       - docuchain-prod 
•     restart: always 
•  
•   grafana: 
•     image: grafana/grafana:latest 
•     environment: 
•       - GF_SECURITY_ADMIN_PASSWORD=${GRAFANA_PASSWORD} 
•     volumes: 
•       - grafana_data:/var/lib/grafana 
•     ports: 
•       - "3001:3000" 
•     networks: 
•       - docuchain-prod 
•     restart: always 
•  
• volumes: 
•   prod_postgres_data: 
•   prod_redis_data: 
•   prod_backend_logs: 
•   prometheus_data: 
•   grafana_data: 



•  
• networks: 
•   docuchain-prod: 
•     driver: overlay 
•     attachable: true 
•  

• 10.2 CI/CD Pipeline 
• 10.2.1 GitHub Actions Workflow 
• YAML 
• # .github/workflows/ci-cd.yml 
• name: CI/CD Pipeline 
•  
• on: 
•   push: 
•     branches: [main, develop, staging] 
•   pull_request: 
•     branches: [main, develop] 
•  
• env: 
•   REGISTRY: ghcr.io 
•   IMAGE_NAME: ${{ github.repository }} 
•  
• jobs: 
•   # Backend Tests 
•   backend-test: 
•     runs-on: ubuntu-latest 
•      
•     services: 
•       postgres: 
•         image: postgres:15 
•         env: 
•           POSTGRES_DB: test_db 
•           POSTGRES_USER: test_user 
•           POSTGRES_PASSWORD: test_password 
•         options: >- 
•           --health-cmd pg_isready 
•           --health-interval 10s 
•           --health-timeout 5s 
•           --health-retries 5 
•         ports: 
•           - 5432:5432 
•        
•       redis: 
•         image: redis:7-alpine 
•         options: >- 
•           --health-cmd "redis-cli ping" 
•           --health-interval 10s 
•           --health-timeout 5s 
•           --health-retries 5 
•         ports: 
•           - 6379:6379 
•      
•     steps: 
•       - uses: actions/checkout@v3 
•        



•       - name: Set up Python 
•         uses: actions/setup-python@v4 
•         with: 
•           python-version: ' 
• 3.11' 

cache: 'pip' 

• text 

•   - name: Install dependencies 
•     working-directory: ./backend 
•     run: | 
•       pip install -r requirements.txt 
•       pip install -r requirements-dev.txt 
•    
•   - name: Run linting 
•     working-directory: ./backend 
•     run: | 
•       flake8 app/ --max-line-length=100 
•       black --check app/ 
•    
•   - name: Run tests 
•     working-directory: ./backend 
•     env: 
•       DATABASE_URL: postgresql://test_user:test_password@localhost:5432/test_db 
•       REDIS_URL: redis://localhost:6379/0 
•       JWT_SECRET_KEY: test-secret-key 
•     run: | 
•       pytest --cov=app --cov-report=xml --cov-report=term 
•    
•   - name: Upload coverage to Codecov 
•     uses: codecov/codecov-action@v3 
•     with: 
•       files: ./backend/coverage.xml 
•       flags: backend 

• Frontend Tests 
• frontend-test: 

runs-on: ubuntu-latest 

• text 

• steps: 
•   - uses: actions/checkout@v3 
•    
•   - name: Set up Node.js 
•     uses: actions/setup-node@v3 
•     with: 
•       node-version: '18' 
•       cache: 'npm' 
•       cache-dependency-path: frontend/package-lock.json 



•    
•   - name: Install dependencies 
•     working-directory: ./frontend 
•     run: npm ci 
•    
•   - name: Run linting 
•     working-directory: ./frontend 
•     run: npm run lint 
•    
•   - name: Run type checking 
•     working-directory: ./frontend 
•     run: npm run type-check 
•    
•   - name: Run tests 
•     working-directory: ./frontend 
•     run: npm run test:coverage 
•    
•   - name: Upload coverage 
•     uses: codecov/codecov-action@v3 
•     with: 
•       files: ./frontend/coverage/coverage-final.json 
•       flags: frontend 

• Smart Contract Tests 
• contract-test: 

runs-on: ubuntu-latest 

• text 

• steps: 
•   - uses: actions/checkout@v3 
•    
•   - name: Set up Node.js 
•     uses: actions/setup-node@v3 
•     with: 
•       node-version: '18' 
•       cache: 'npm' 
•       cache-dependency-path: blockchain/package-lock.json 
•    
•   - name: Install dependencies 
•     working-directory: ./blockchain 
•     run: npm ci 
•    
•   - name: Compile contracts 
•     working-directory: ./blockchain 
•     run: npx hardhat compile 
•    
•   - name: Run tests 
•     working-directory: ./blockchain 
•     run: npx hardhat test 
•    
•   - name: Run coverage 
•     working-directory: ./blockchain 



•     run: npx hardhat coverage 
•    
•   - name: Upload coverage 
•     uses: codecov/codecov-action@v3 
•     with: 
•       files: ./blockchain/coverage/coverage-final.json 
•       flags: contracts 

• Security Scanning 
• security-scan: 

runs-on: ubuntu-latest 
needs: [backend-test, frontend-test] 

• text 

• steps: 
•   - uses: actions/checkout@v3 
•    
•   - name: Run Trivy vulnerability scanner 
•     uses: aquasecurity/trivy-action@master 
•     with: 
•       scan-type: 'fs' 
•       scan-ref: '.' 
•       format: 'sarif' 
•       output: 'trivy-results.sarif' 
•    
•   - name: Upload Trivy results to GitHub Security tab 
•     uses: github/codeql-action/upload-sarif@v2 
•     with: 
•       sarif_file: 'trivy-results.sarif' 
•    
•   - name: Run Snyk security scan 
•     uses: snyk/actions/node@master 
•     env: 
•       SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }} 
•     with: 
•       command: test 

• Build Docker Images 
• build-backend: 

runs-on: ubuntu-latest 
needs: [backend-test, security-scan] 
if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref 
== 'refs/heads/staging') 

• text 

• steps: 



•   - uses: actions/checkout@v3 
•    
•   - name: Set up Docker Buildx 
•     uses: docker/setup-buildx-action@v2 
•    
•   - name: Log in to Container Registry 
•     uses: docker/login-action@v2 
•     with: 
•       registry: ${{ env.REGISTRY }} 
•       username: ${{ github.actor }} 
•       password: ${{ secrets.GITHUB_TOKEN }} 
•    
•   - name: Extract metadata 
•     id: meta 
•     uses: docker/metadata-action@v4 
•     with: 
•       images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-backend 
•       tags: | 
•         type=ref,event=branch 
•         type=sha,prefix={{branch}}- 
•         type=semver,pattern={{version}} 
•    
•   - name: Build and push Docker image 
•     uses: docker/build-push-action@v4 
•     with: 
•       context: ./backend 
•       file: ./backend/Dockerfile.prod 
•       push: true 
•       tags: ${{ steps.meta.outputs.tags }} 
•       labels: ${{ steps.meta.outputs.labels }} 
•       cache-from: type=gha 
•       cache-to: type=gha,mode=max 

• build-frontend: 
runs-on: ubuntu-latest 
needs: [frontend-test, security-scan] 
if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref 
== 'refs/heads/staging') 

• text 

• steps: 
•   - uses: actions/checkout@v3 
•    
•   - name: Set up Docker Buildx 
•     uses: docker/setup-buildx-action@v2 
•    
•   - name: Log in to Container Registry 
•     uses: docker/login-action@v2 
•     with: 
•       registry: ${{ env.REGISTRY }} 
•       username: ${{ github.actor }} 
•       password: ${{ secrets.GITHUB_TOKEN }} 



•    
•   - name: Extract metadata 
•     id: meta 
•     uses: docker/metadata-action@v4 
•     with: 
•       images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-frontend 
•       tags: | 
•         type=ref,event=branch 
•         type=sha,prefix={{branch}}- 
•         type=semver,pattern={{version}} 
•    
•   - name: Build and push Docker image 
•     uses: docker/build-push-action@v4 
•     with: 
•       context: ./frontend 
•       file: ./frontend/Dockerfile.prod 
•       push: true 
•       tags: ${{ steps.meta.outputs.tags }} 
•       labels: ${{ steps.meta.outputs.labels }} 
•       cache-from: type=gha 
•       cache-to: type=gha,mode=max 

• Deploy to Staging 
• deploy-staging: 

runs-on: ubuntu-latest 
needs: [build-backend, build-frontend] 
if: github.ref == 'refs/heads/staging' 
environment: 
name: staging 
url: https://staging.docuchain.app 

• text 

• steps: 
•   - uses: actions/checkout@v3 
•    
•   - name: Deploy to staging server 
•     uses: appleboy/ssh-action@master 
•     with: 
•       host: ${{ secrets.STAGING_HOST }} 
•       username: ${{ secrets.STAGING_USER }} 
•       key: ${{ secrets.STAGING_SSH_KEY }} 
•       script: | 
•         cd /opt/docuchain 
•         docker-compose -f docker-compose.staging.yml pull 
•         docker-compose -f docker-compose.staging.yml up -d 
•         docker-compose -f docker-compose.staging.yml exec -T backend flask db 

upgrade 
•    
•   - name: Run smoke tests 
•     run: | 



•       sleep 30 
•       curl -f https://staging-api.docuchain.app/health || exit 1 
•    
•   - name: Notify deployment 
•     uses: 8398a7/action-slack@v3 
•     with: 
•       status: ${{ job.status }} 
•       text: 'Staging deployment completed' 
•       webhook_url: ${{ secrets.SLACK_WEBHOOK }} 

• Deploy to Production 
• deploy-production: 

runs-on: ubuntu-latest 
needs: [build-backend, build-frontend] 
if: github.ref == 'refs/heads/main' 
environment: 
name: production 
url: https://docuchain.app 

• text 

• steps: 
•   - uses: actions/checkout@v3 
•    
•   - name: Deploy to production (Blue-Green) 
•     uses: appleboy/ssh-action@master 
•     with: 
•       host: ${{ secrets.PROD_HOST }} 
•       username: ${{ secrets.PROD_USER }} 
•       key: ${{ secrets.PROD_SSH_KEY }} 
•       script: | 
•         cd /opt/docuchain 
•          
•         # Deploy to blue environment 
•         docker-compose -f docker-compose.prod-blue.yml pull 
•         docker-compose -f docker-compose.prod-blue.yml up -d 
•          
•         # Wait for health check 
•         sleep 30 
•         curl -f http://localhost:5001/health || exit 1 
•          
•         # Run database migrations 
•         docker-compose -f docker-compose.prod-blue.yml exec -T backend flask db 

upgrade 
•          
•         # Switch traffic to blue 
•         cp nginx/prod-blue.conf nginx/production.conf 
•         docker exec docuchain-nginx nginx -s reload 
•          
•         # Stop green environment 
•         docker-compose -f docker-compose.prod-green.yml down 



•    
•   - name: Run smoke tests 
•     run: | 
•       sleep 60 
•       curl -f https://api.docuchain.app/health || exit 1 
•       curl -f https://docuchain.app || exit 1 
•    
•   - name: Notify deployment 
•     uses: 8398a7/action-slack@v3 
•     with: 
•       status: ${{ job.status }} 
•       text: 'Production deployment completed' 
•       webhook_url: ${{ secrets.SLACK_WEBHOOK }} 
•    
•   - name: Create GitHub Release 
•     if: startsWith(github.ref, 'refs/tags/v') 
•     uses: actions/create-release@v1 
•     env: 
•       GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} 
•     with: 
•       tag_name: ${{ github.ref }} 
•       release_name: Release ${{ github.ref }} 
•       draft: false 
•       prerelease: false 

• text 

•  
• --- 
•  
• ## 10.3 Database Migration Strategy 
•  
• ### **10.3.1 Migration Scripts** 
•  
• ```python 
• # backend/migrations/versions/001_initial_schema.py 
• """Initial schema 
•  
• Revision ID: 001 
• Revises:  
• Create Date: 2024-01-20 10:00:00.000000 
• """ 
• from alembic import op 
• import sqlalchemy as sa 
•  
• revision = '001' 
• down_revision = None 
• branch_labels = None 
• depends_on = None 
•  
• def upgrade(): 
•     # Create institutions table 
•     op.create_table('institutions', 
•         sa.Column('id', sa.Integer(), nullable=False), 
•         sa.Column('institution_id', sa.String(length=50), nullable=False), 



•         sa.Column('unique_id', sa.String(length=50), nullable=False), 
•         sa.Column('name', sa.String(length=255), nullable=False), 
•         sa.Column('type', sa.String(length=50), nullable=False), 
•         sa.Column('address', sa.Text(), nullable=True), 
•         sa.Column('website', sa.String(length=255), nullable=True), 
•         sa.Column('email', sa.String(length=255), nullable=False), 
•         sa.Column('contact', sa.String(length=20), nullable=True), 
•         sa.Column('blockchain_hash', sa.String(length=66), nullable=True), 
•         sa.Column('is_verified', sa.Boolean(), nullable=True), 
•         sa.Column('created_at', sa.TIMESTAMP(), 

server_default=sa.text('CURRENT_TIMESTAMP'), nullable=True), 
•         sa.Column('updated_at', sa.TIMESTAMP(), 

server_default=sa.text('CURRENT_TIMESTAMP'), nullable=True), 
•         sa.PrimaryKeyConstraint('id'), 
•         sa.UniqueConstraint('institution_id'), 
•         sa.UniqueConstraint('unique_id') 
•     ) 
•      
•     # Create users table 
•     op.create_table('users', 
•         sa.Column('id', sa.Integer(), nullable=False), 
•         sa.Column('user_id', sa.String(length=50), nullable=False), 
•         sa.Column('institution_id', sa.Integer(), nullable=True), 
•         sa.Column('role', sa.String(length=20), nullable=False), 
•         sa.Column('first_name', sa.String(length=100), nullable=False), 
•         sa.Column('last_name', sa.String(length=100), nullable=False), 
•         sa.Column('email', sa.String(length=255), nullable=False), 
•         sa.Column('phone', sa.String(length=20), nullable=True), 
•         sa.Column('password_hash', sa.String(length=255), nullable=False), 
•         sa.Column('wallet_address', sa.String(length=42), nullable=False), 
•         sa.Column('is_active', sa.Boolean(), nullable=True), 
•         sa.Column('is_verified', sa.Boolean(), nullable=True), 
•         sa.Column('profile_image', sa.Text(), nullable=True), 
•         sa.Column('created_at', sa.TIMESTAMP(), 

server_default=sa.text('CURRENT_TIMESTAMP'), nullable=True), 
•         sa.Column('updated_at', sa.TIMESTAMP(), 

server_default=sa.text('CURRENT_TIMESTAMP'), nullable=True), 
•         sa.Column('last_login', sa.TIMESTAMP(), nullable=True), 
•         sa.ForeignKeyConstraint(['institution_id'], ['institutions.id'], ), 
•         sa.PrimaryKeyConstraint('id'), 
•         sa.UniqueConstraint('user_id'), 
•         sa.UniqueConstraint('email') 
•     ) 
•      
•     # Create indexes 
•     op.create_index(op.f('idx_users_email'), 'users', ['email'], unique=True) 
•     op.create_index(op.f('idx_users_wallet'), 'users', ['wallet_address'], 

unique=False) 
•     op.create_index(op.f('idx_users_institution'), 'users', ['institution_id'], 

unique=False) 
•  
• def downgrade(): 
•     op.drop_index(op.f('idx_users_institution'), table_name='users') 
•     op.drop_index(op.f('idx_users_wallet'), table_name='users') 
•     op.drop_index(op.f('idx_users_email'), table_name='users') 
•     op.drop_table('users') 



•     op.drop_table('institutions') 

• 10.3.2 Migration Best Practices 
• Bash 

• # Create new migration 
• flask db revision --autogenerate -m "Add new column" 
•  
• # Review migration before applying 
• cat migrations/versions/xxx_add_new_column.py 
•  
• # Test migration on development 
• flask db upgrade 
•  
• # Test rollback 
• flask db downgrade 
•  
• # Apply to production (with backup) 
• # 1. Backup database 
• pg_dump docuchain_prod > backup_$(date +%Y%m%d).sql 
•  
• # 2. Apply migration 
• flask db upgrade 
•  
• # 3. Verify 
• flask db current 
•  
• # 4. If issues, rollback 
• flask db downgrade -1 

•  

• 10.4 SSL/TLS Configuration 

• 10.4.1 Let's Encrypt Setup 
• Bash 

• # Install Certbot 
• sudo apt-get update 
• sudo apt-get install certbot python3-certbot-nginx 
•  
• # Obtain certificate 
• sudo certbot --nginx -d docuchain.app -d www.docuchain.app 
•  
• # Auto-renewal (cron job) 
• 0 0 * * * /usr/bin/certbot renew --quiet 



• 10.4.2 Nginx SSL Configuration 
• nginx 
• # nginx/production.conf 
• server { 
•     listen 80; 
•     server_name docuchain.app www.docuchain.app; 
•     return 301 https://$server_name$request_uri; 
• } 
•  
• server { 
•     listen 443 ssl http2; 
•     server_name docuchain.app www.docuchain.app; 
•      
•     ssl_certificate /etc/letsencrypt/live/docuchain.app/fullchain 
• .pem; 

ssl_certificate_key /etc/letsencrypt/live/docuchain.app/privkey.pem; 

• text 

• # SSL configuration 
• ssl_protocols TLSv1.2 TLSv1.3; 
• ssl_ciphers 'ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-

ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384'; 
• ssl_prefer_server_ciphers on; 
• ssl_session_cache shared:SSL:10m; 
• ssl_session_timeout 10m; 
• ssl_stapling on; 
• ssl_stapling_verify on; 
•  
• # Security headers 
• add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" 

always; 
• add_header X-Frame-Options "DENY" always; 
• add_header X-Content-Type-Options "nosniff" always; 
• add_header X-XSS-Protection "1; mode=block" always; 
• add_header Referrer-Policy "strict-origin-when-cross-origin" always; 
• add_header Content-Security-Policy "default-src 'self'; script-src 'self' 

'unsafe-inline' cdn.jsdelivr.net; style-src 'self' 'unsafe-inline'; img-src 
'self' data: https:; connect-src 'self' wss: https://sepolia.infura.io; frame-
ancestors 'none';" always; 

•  
• # Gzip compression 
• gzip on; 
• gzip_vary on; 
• gzip_min_length 1000; 
• gzip_types text/plain text/css application/json application/javascript text/xml 

application/xml application/xml+rss text/javascript; 
•  
• # Root directory 
• root /usr/share/nginx/html; 
• index index.html; 
•  
• # Frontend routes 



• location / { 
•     try_files $uri $uri/ /index.html; 
•      
•     # Cache static assets 
•     location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg|woff|woff2|ttf|eot)$ { 
•         expires 1y; 
•         add_header Cache-Control "public, immutable"; 
•     } 
• } 
•  
• # API proxy 
• location /api/ { 
•     proxy_pass http://backend:5000; 
•     proxy_http_version 1.1; 
•     proxy_set_header Upgrade $http_upgrade; 
•     proxy_set_header Connection 'upgrade'; 
•     proxy_set_header Host $host; 
•     proxy_set_header X-Real-IP $remote_addr; 
•     proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; 
•     proxy_set_header X-Forwarded-Proto $scheme; 
•     proxy_cache_bypass $http_upgrade; 
•      
•     # Timeouts 
•     proxy_connect_timeout 60s; 
•     proxy_send_timeout 60s; 
•     proxy_read_timeout 60s; 
•      
•     # Buffer settings 
•     proxy_buffering on; 
•     proxy_buffer_size 4k; 
•     proxy_buffers 8 4k; 
•     proxy_busy_buffers_size 8k; 
• } 
•  
• # WebSocket proxy 
• location /socket.io/ { 
•     proxy_pass http://backend:5000; 
•     proxy_http_version 1.1; 
•     proxy_set_header Upgrade $http_upgrade; 
•     proxy_set_header Connection "upgrade"; 
•     proxy_set_header Host $host; 
•     proxy_set_header X-Real-IP $remote_addr; 
•     proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; 
•      
•     # WebSocket timeouts 
•     proxy_read_timeout 86400; 
• } 
•  
• # Health check endpoint 
• location /health { 
•     access_log off; 
•     return 200 "healthy\n"; 
•     add_header Content-Type text/plain; 
• } 
•  
• # Rate limiting 



• limit_req_zone $binary_remote_addr zone=api_limit:10m rate=10r/s; 
• limit_req_zone $binary_remote_addr zone=login_limit:10m rate=5r/m; 
•  
• location /api/auth/login { 
•     limit_req zone=login_limit burst=5 nodelay; 
•     proxy_pass http://backend:5000; 
• } 
•  
• location /api/ { 
•     limit_req zone=api_limit burst=20 nodelay; 
•     proxy_pass http://backend:5000; 
• } 
•  
• # Access and error logs 
• access_log /var/log/nginx/docuchain_access.log combined; 
• error_log /var/log/nginx/docuchain_error.log warn; 

• } 

• text 

•  
• --- 
•  
• ## 10.5 Monitoring & Alerting Setup 
•  
• ### **10.5.1 Prometheus Configuration** 
•  
• ```yaml 
• # monitoring/prometheus.yml 
• global: 
•   scrape_interval: 15s 
•   evaluation_interval: 15s 
•   external_labels: 
•     cluster: 'docuchain-production' 
•     environment: 'production' 
•  
• alerting: 
•   alertmanagers: 
•     - static_configs: 
•         - targets: 
•             - alertmanager:9093 
•  
• rule_files: 
•   - 'alerts.yml' 
•  
• scrape_configs: 
•   # Backend metrics 
•   - job_name: 'backend' 
•     static_configs: 
•       - targets: ['backend-1:5000', 'backend-2:5000', 'backend-3:5000'] 
•     metrics_path: '/metrics' 
•      
•   # PostgreSQL metrics 
•   - job_name: 'postgres' 



•     static_configs: 
•       - targets: ['postgres-exporter:9187'] 
•      
•   # Redis metrics 
•   - job_name: 'redis' 
•     static_configs: 
•       - targets: ['redis-exporter:9121'] 
•      
•   # Nginx metrics 
•   - job_name: 'nginx' 
•     static_configs: 
•       - targets: ['nginx-exporter:9113'] 
•      
•   # Node exporter (system metrics) 
•   - job_name: 'node' 
•     static_configs: 
•       - targets: ['node-exporter:9100'] 
•      
•   # Blockchain node metrics (if self-hosted) 
•   - job_name: 'ethereum-node' 
•     static_configs: 
•       - targets: ['geth:6060'] 

• 10.5.2 Grafana Dashboard 
• JSON 

• // monitoring/grafana/dashboards/docuchain-overview.json 
• { 
•   "dashboard": { 
•     "title": "DocuChain Overview", 
•     "tags": ["docuchain", "overview"], 
•     "timezone": "browser", 
•     "panels": [ 
•       { 
•         "id": 1, 
•         "title": "API Request Rate", 
•         "type": "graph", 
•         "targets": [ 
•           { 
•             "expr": "rate(http_requests_total[5m])", 
•             "legendFormat": "{{method}} {{endpoint}}" 
•           } 
•         ], 
•         "gridPos": {"x": 0, "y": 0, "w": 12, "h": 8} 
•       }, 
•       { 
•         "id": 2, 
•         "title": "Response Time (p95)", 
•         "type": "graph", 
•         "targets": [ 
•           { 
•             "expr": "histogram_quantile(0.95, 

rate(http_request_duration_seconds_bucket[5m]))", 
•             "legendFormat": "95th percentile" 



•           } 
•         ], 
•         "gridPos": {"x": 12, "y": 0, "w": 12, "h": 8} 
•       }, 
•       { 
•         "id": 3, 
•         "title": "Active Users", 
•         "type": "stat", 
•         "targets": [ 
•           { 
•             "expr": "count(rate(user_login_total[5m]) > 0)" 
•           } 
•         ], 
•         "gridPos": {"x": 0, "y": 8, "w": 6, "h": 4} 
•       }, 
•       { 
•         "id": 4, 
•         "title": "Documents Uploaded (24h)", 
•         "type": "stat", 
•         "targets": [ 
•           { 
•             "expr": "increase(document_uploads_total[24h])" 
•           } 
•         ], 
•         "gridPos": {"x": 6, "y": 8, "w": 6, "h": 4} 
•       }, 
•       { 
•         "id": 5, 
•         "title": "Blockchain Transaction Success Rate", 
•         "type": "gauge", 
•         "targets": [ 
•           { 
•             "expr": 

"sum(rate(blockchain_transactions_total{status='success'}[5m])) / 
sum(rate(blockchain_transactions_total[5m]))" 

•           } 
•         ], 
•         "gridPos": {"x": 12, "y": 8, "w": 6, "h": 4} 
•       }, 
•       { 
•         "id": 6, 
•         "title": "Database Connection Pool", 
•         "type": "graph", 
•         "targets": [ 
•           { 
•             "expr": "pg_stat_activity_count", 
•             "legendFormat": "Active connections" 
•           } 
•         ], 
•         "gridPos": {"x": 18, "y": 8, "w": 6, "h": 4} 
•       }, 
•       { 
•         "id": 7, 
•         "title": "Error Rate", 
•         "type": "graph", 
•         "targets": [ 



•           { 
•             "expr": "rate(http_requests_total{status=~'5..'}[5m])", 
•             "legendFormat": "5xx errors" 
•           } 
•         ], 
•         "gridPos": {"x": 0, "y": 12, "w": 12, "h": 8} 
•       }, 
•       { 
•         "id": 8, 
•         "title": "Memory Usage", 
•         "type": "graph", 
•         "targets": [ 
•           { 
•             "expr": "process_resident_memory_bytes", 
•             "legendFormat": "{{instance}}" 
•           } 
•         ], 
•         "gridPos": {"x": 12, "y": 12, "w": 12, "h": 8} 
•       } 
•     ] 
•   } 
• } 

•  

• 10.6 Backup & Disaster Recovery 

• 10.6.1 Automated Backup Script 
• Bash 

• #!/bin/bash 
• # /opt/docuchain/scripts/backup.sh 
•  
• set -e 
•  
• BACKUP_DIR="/backups/docuchain" 
• DATE=$(date +%Y%m%d_%H%M%S) 
• S3_BUCKET="s3://docuchain-backups" 
• RETENTION_DAYS=30 
•  
• echo "Starting backup at $(date)" 
•  
• # 1. PostgreSQL Backup 
• echo "Backing up PostgreSQL..." 
• docker exec docuchain-db pg_dump -U $POSTGRES_USER -Fc docuchain_prod > \ 
•     $BACKUP_DIR/postgres/db_backup_$DATE.dump 
•  
• # Compress 
• gzip $BACKUP_DIR/postgres/db_backup_$DATE.dump 
•  



• # 2. Redis Backup 
• echo "Backing up Redis..." 
• docker exec docuchain-redis redis-cli BGSAVE 
• sleep 10 
• docker cp docuchain-redis:/data/dump.rdb $BACKUP_DIR/redis/redis_backup_$DATE.rdb 
• gzip $BACKUP_DIR/redis/redis_backup_$DATE.rdb 
•  
• # 3. Application Logs 
• echo "Backing up logs..." 
• tar -czf $BACKUP_DIR/logs/logs_backup_$DATE.tar.gz /var/log/docuchain/ 
•  
• # 4. Configuration Files 
• echo "Backing up configurations..." 
• tar -czf $BACKUP_DIR/config/config_backup_$DATE.tar.gz \ 
•     /opt/docuchain/docker-compose.yml \ 
•     /opt/docuchain/nginx/ \ 
•     /opt/docuchain/.env 
•  
• # 5. Upload to S3 
• echo "Uploading to S3..." 
• aws s3 sync $BACKUP_DIR $S3_BUCKET/$(date +%Y/%m/%d)/ \ 
•     --storage-class STANDARD_IA \ 
•     --exclude "*" \ 
•     --include "*.gz" 
•  
• # 6. Cleanup old backups 
• echo "Cleaning up old backups..." 
• find $BACKUP_DIR -type f -name "*.gz" -mtime +$RETENTION_DAYS -delete 
•  
• # 7. Verify backups 
• echo "Verifying backups..." 
• if [ -f "$BACKUP_DIR/postgres/db_backup_$DATE.dump.gz" ] && \ 
•    [ -f "$BACKUP_DIR/redis/redis_backup_$DATE.rdb.gz" ]; then 
•     echo "✓ Backup completed successfully at $(date)" 
•      
•     # Send notification 
•     curl -X POST $SLACK_WEBHOOK \ 
•         -H 'Content-Type: application/json' \ 
•         -d "{\"text\":\"✅ DocuChain backup completed successfully\"}" 
• else 
•     echo "✗ Backup failed!" 
•     curl -X POST $SLACK_WEBHOOK \ 
•         -H 'Content-Type: application/json' \ 
•         -d "{\"text\":\"❌ DocuChain backup FAILED\"}" 
•     exit 1 
• fi 

• 10.6.2 Disaster Recovery Procedure 
• Bash 

• #!/bin/bash 
• # /opt/docuchain/scripts/restore.sh 
•  
• set -e 



•  
• BACKUP_DATE=$1 
• BACKUP_DIR="/backups/docuchain" 
• S3_BUCKET="s3://docuchain-backups" 
•  
• if [ -z "$BACKUP_DATE" ]; then 
•     echo "Usage: ./restore.sh YYYYMMDD_HHMMSS" 
•     exit 1 
• fi 
•  
• echo "Starting disaster recovery for backup: $BACKUP_DATE" 
•  
• # 1. Stop services 
• echo "Stopping services..." 
• docker-compose -f docker-compose.prod.yml down 
•  
• # 2. Download backups from S3 
• echo "Downloading backups from S3..." 
• aws s3 cp $S3_BUCKET/postgres/db_backup_$BACKUP_DATE.dump.gz 

$BACKUP_DIR/postgres/ 
• aws s3 cp $S3_BUCKET/redis/redis_backup_$BACKUP_DATE.rdb.gz $BACKUP_DIR/redis/ 
•  
• # 3. Decompress backups 
• echo "Decompressing backups..." 
• gunzip $BACKUP_DIR/postgres/db_backup_$BACKUP_DATE.dump.gz 
• gunzip $BACKUP_DIR/redis/redis_backup_$BACKUP_DATE.rdb.gz 
•  
• # 4. Restore PostgreSQL 
• echo "Restoring PostgreSQL..." 
• docker-compose up -d db 
• sleep 10 
• docker exec -i docuchain-db psql -U $POSTGRES_USER -d postgres -c "DROP DATABASE 

IF EXISTS docuchain_prod;" 
• docker exec -i docuchain-db psql -U $POSTGRES_USER -d postgres -c "CREATE 

DATABASE docuchain_prod;" 
• docker exec -i docuchain-db pg_restore -U $POSTGRES_USER -d docuchain_prod < \ 
•     $BACKUP_DIR/postgres/db_backup_$BACKUP_DATE.dump 
•  
• # 5. Restore Redis 
• echo "Restoring Redis..." 
• docker-compose up -d redis 
• sleep 5 
• docker cp $BACKUP_DIR/redis/redis_backup_$BACKUP_DATE.rdb docuchain-

redis:/data/dump.rdb 
• docker restart docuchain-redis 
•  
• # 6. Restart all services 
• echo "Starting all services..." 
• docker-compose -f docker-compose.prod.yml up -d 
•  
• # 7. Verify services 
• echo "Verifying services..." 
• sleep 30 
• curl -f http://localhost:5000/health || exit 1 
• curl -f http://localhost:80/health || exit 1 
•  



• echo "✓ Disaster recovery completed successfully at $(date)" 
•  
• # Send notification 
• curl -X POST $SLACK_WEBHOOK \ 
•     -H 'Content-Type: application/json' \ 
•     -d "{\"text\":\"✅ DocuChain disaster recovery completed. Backup date: 

$BACKUP_DATE\"}" 

•  

• 10.7 Scaling Strategy 

• **10.7.1 Auto- 
• Scaling Configuration** 

• YAML 

• # kubernetes/deployment.yml 
• apiVersion: apps/v1 
• kind: Deployment 
• metadata: 
•   name: docuchain-backend 
•   namespace: docuchain 
• spec: 
•   replicas: 3 
•   selector: 
•     matchLabels: 
•       app: docuchain-backend 
•   template: 
•     metadata: 
•       labels: 
•         app: docuchain-backend 
•     spec: 
•       containers: 
•       - name: backend 
•         image: docuchain/backend:latest 
•         ports: 
•         - containerPort: 5000 
•         env: 
•         - name: FLASK_ENV 
•           value: "production" 
•         - name: DATABASE_URL 
•           valueFrom: 
•             secretKeyRef: 
•               name: docuchain-secrets 
•               key: database-url 
•         resources: 
•           requests: 
•             memory: "512Mi" 
•             cpu: "500m" 



•           limits: 
•             memory: "2Gi" 
•             cpu: "2000m" 
•         livenessProbe: 
•           httpGet: 
•             path: /health 
•             port: 5000 
•           initialDelaySeconds: 30 
•           periodSeconds: 10 
•         readinessProbe: 
•           httpGet: 
•             path: /health/ready 
•             port: 5000 
•           initialDelaySeconds: 5 
•           periodSeconds: 5 
•  
• --- 
• apiVersion: autoscaling/v2 
• kind: HorizontalPodAutoscaler 
• metadata: 
•   name: docuchain-backend-hpa 
•   namespace: docuchain 
• spec: 
•   scaleTargetRef: 
•     apiVersion: apps/v1 
•     kind: Deployment 
•     name: docuchain-backend 
•   minReplicas: 3 
•   maxReplicas: 10 
•   metrics: 
•   - type: Resource 
•     resource: 
•       name: cpu 
•       target: 
•         type: Utilization 
•         averageUtilization: 70 
•   - type: Resource 
•     resource: 
•       name: memory 
•       target: 
•         type: Utilization 
•         averageUtilization: 80 
•   - type: Pods 
•     pods: 
•       metric: 
•         name: http_requests_per_second 
•       target: 
•         type: AverageValue 
•         averageValue: "1000" 
•   behavior: 
•     scaleDown: 
•       stabilizationWindowSeconds: 300 
•       policies: 
•       - type: Percent 
•         value: 50 
•         periodSeconds: 60 



•     scaleUp: 
•       stabilizationWindowSeconds: 0 
•       policies: 
•       - type: Percent 
•         value: 100 
•         periodSeconds: 30 
•       - type: Pods 
•         value: 2 
•         periodSeconds: 30 
•       selectPolicy: Max 

• 10.7.2 Database Read Replicas 

• YAML 

• # kubernetes/postgres-statefulset.yml 
• apiVersion: apps/v1 
• kind: StatefulSet 
• metadata: 
•   name: postgres-replica 
•   namespace: docuchain 
• spec: 
•   serviceName: postgres-replica 
•   replicas: 2 
•   selector: 
•     matchLabels: 
•       app: postgres-replica 
•   template: 
•     metadata: 
•       labels: 
•         app: postgres-replica 
•     spec: 
•       containers: 
•       - name: postgres 
•         image: postgres:15-alpine 
•         env: 
•         - name: POSTGRES_REPLICATION_MODE 
•           value: "slave" 
•         - name: POSTGRES_MASTER_HOST 
•           value: "postgres-master" 
•         - name: POSTGRES_MASTER_PORT 
•           value: "5432" 
•         - name: POSTGRES_REPLICATION_USER 
•           valueFrom: 
•             secretKeyRef: 
•               name: postgres-secrets 
•               key: replication-user 
•         - name: POSTGRES_REPLICATION_PASSWORD 
•           valueFrom: 
•             secretKeyRef: 
•               name: postgres-secrets 
•               key: replication-password 
•         ports: 
•         - containerPort: 5432 
•         volumeMounts: 



•         - name: postgres-data 
•           mountPath: /var/lib/postgresql/data 
•   volumeClaimTemplates: 
•   - metadata: 
•       name: postgres-data 
•     spec: 
•       accessModes: ["ReadWriteOnce"] 
•       resources: 
•         requests: 
•           storage: 100Gi 
•  
• --- 
• apiVersion: v1 
• kind: Service 
• metadata: 
•   name: postgres-replica-service 
•   namespace: docuchain 
• spec: 
•   selector: 
•     app: postgres-replica 
•   ports: 
•   - port: 5432 
•     targetPort: 5432 
•   type: ClusterIP 

•  

• 11. Success Metrics & KPIs 

• 11.1 User Adoption Metrics 

• 11.1.1 Primary Metrics 

Metric Target Measurement Method 

Daily Active Users (DAU) 70% of registered users Track unique logins per day 

Monthly Active Users (MAU) 90% of registered users Track unique logins per month 



Metric Target Measurement Method 

User Retention (30-day) > 80% Users active after 30 days of registration 

User Retention (90-day) > 70% Users active after 90 days of registration 

New User Onboarding Completion > 85% Users completing profile setup 

Feature Adoption Rate > 60% Users using core features (upload, share, approve) 

• Tracking Implementation: 

• Python 

• # backend/app/services/analytics_service.py 
• from datetime import datetime, timedelta 
• from sqlalchemy import func 
•  
• class AnalyticsService: 
•     def calculate_dau(self, date=None): 
•         """Calculate Daily Active Users""" 
•         date = date or datetime.utcnow().date() 
•          
•         return db.session.query(func.count(func.distinct(ActivityLog.user_id)))\ 
•             .filter( 
•                 func.date(ActivityLog.created_at) == date, 
•                 ActivityLog.action.in_(['login', 'document_upload', 

'document_view']) 
•             ).scalar() 
•      
•     def calculate_retention(self, days=30): 
•         """Calculate user retention rate""" 
•         cutoff_date = datetime.utcnow() - timedelta(days=days) 
•          
•         # Users registered before cutoff 
•         registered_users = db.session.query(func.count(User.id))\ 
•             .filter(User.created_at <= cutoff_date).scalar() 
•          
•         # Users still active 



•         active_users = 
db.session.query(func.count(func.distinct(ActivityLog.user_id)))\ 

•             .join(User, User.id == ActivityLog.user_id)\ 
•             .filter( 
•                 User.created_at <= cutoff_date, 
•                 ActivityLog.created_at >= cutoff_date 
•             ).scalar() 
•          
•         return (active_users / registered_users * 100) if registered_users > 0 

else 0 
•      
•     def feature_adoption_rate(self, feature_name): 
•         """Calculate feature adoption rate""" 
•         total_users = db.session.query(func.count(User.id)).scalar() 
•          
•         users_using_feature = 

db.session.query(func.count(func.distinct(ActivityLog.user_id)))\ 
•             .filter(ActivityLog.action == feature_name).scalar() 
•          
•         return (users_using_feature / total_users * 100) if total_users > 0 else 

0 

• 11.2 System Performance Metrics 

• 11.2.1 Technical KPIs 

Metric Target Alert Threshold 

API Response Time (p95) < 500ms > 1000ms 

API Response Time (p99) < 1s > 2s 

System Uptime 99.9% < 99.5% 

Error Rate < 0.5% > 1% 

Database Query Time (p95) < 100ms > 500ms 



Metric Target Alert Threshold 

IPFS Upload Success Rate > 99% < 95% 

Blockchain Transaction Success Rate > 98% < 95% 

WebSocket Connection Stability > 99% < 97% 

• Monitoring Dashboard: 

• JavaScript 

• // frontend/src/pages/admin/SystemMetrics.jsx 
• import { useEffect, useState } from 'react'; 
• import { Line, Bar } from 'recharts'; 
• import { getSystemMetrics } from '../../services/adminService'; 
•  
• export default function SystemMetrics() { 
•   const [metrics, setMetrics] = useState(null); 
•  
•   useEffect(() => { 
•     const fetchMetrics = async () => { 
•       const data = await getSystemMetrics(); 
•       setMetrics(data); 
•     }; 
•      
•     fetchMetrics(); 
•     const interval = setInterval(fetchMetrics, 60000); // Update every minute 
•      
•     return () => clearInterval(interval); 
•   }, []); 
•  
•   return ( 
•     <div className="system-metrics"> 
•       <div className="metrics-grid"> 
•         <MetricCard 
•           title="API Response Time (p95)" 
•           value={`${metrics?.responseTime.p95}ms`} 
•           target="< 500ms" 
•           status={metrics?.responseTime.p95 < 500 ? 'healthy' : 'warning'} 
•         /> 
•          
•         <MetricCard 



•           title="System Uptime" 
•           value={`${metrics?.uptime}%`} 
•           target="99.9%" 
•           status={metrics?.uptime >= 99.9 ? 'healthy' : 'critical'} 
•         /> 
•          
•         <MetricCard 
•           title="Error Rate" 
•           value={`${metrics?.errorRate}%`} 
•           target="< 0.5%" 
•           status={metrics?.errorRate < 0.5 ? 'healthy' : 'warning'} 
•         /> 
•          
•         <MetricCard 
•           title="Active Users" 
•           value={metrics?.activeUsers} 
•           target="N/A" 
•           status="info" 
•         /> 
•       </div> 
•        
•       <div className="charts-section"> 
•         <ResponseTimeChart data={metrics?.responseTimeHistory} /> 
•         <ErrorRateChart data={metrics?.errorRateHistory} /> 
•       </div> 
•     </div> 
•   ); 
• } 

• 11.3 Business Impact Metrics 

• 11.3.1 Document Management KPIs 

Metric Target Business Value 

Documents Uploaded per Day 1000+ Usage indicator 

Documents Approved per Day 500+ Workflow efficiency 

Average Approval Time < 24 hours Process efficiency 



Metric Target Business Value 

Document Verification Rate > 95% Trust & authenticity 

Storage Cost per Document < $0.01 Cost efficiency 

Circular Reach Rate > 85% Communication effectiveness 

• 11.3.2 User Engagement Metrics 

Metric Target Calculation 

Session Duration (avg) > 10 minutes Time spent per session 

Pages per Session > 5 User engagement depth 

Chat Messages per User per Day > 3 Communication activity 

File Shares per User per Week > 2 Collaboration indicator 

Approval Requests per Faculty per Week > 5 System utility 



• 11.4 Cost Metrics 

• 11.4.1 Infrastructure Costs 

• Python 

• # backend/app/services/cost_tracking_service.py 
• class CostTrackingService: 
•     def calculate_monthly_costs(self): 
•         """Calculate estimated monthly costs""" 
•          
•         # Server costs 
•         server_cost = { 
•             'aws_ec2': 150.00,  # t3.medium instances 
•             'database': 200.00,  # RDS PostgreSQL 
•             'redis': 50.00,      # ElastiCache 
•             'load_balancer': 30.00, 
•             'storage': 100.00    # EBS volumes 
•         } 
•          
•         # Third-party services 
•         service_cost = { 
•             'pinata_ipfs': 20.00,  # Pro plan 
•             'infura': 50.00,       # Growth plan 
•             'sentry': 26.00,       # Team plan 
•             'sendgrid': 15.00      # Email service 
•         } 
•          
•         # Blockchain costs (variable) 
•         blockchain_cost = self._calculate_gas_costs() 
•          
•         total_cost = ( 
•             sum(server_cost.values()) + 
•             sum(service_cost.values()) + 
•             blockchain_cost 
•         ) 
•          
•         # Calculate cost per user 
•         total_users = User.query.count() 
•         cost_per_user = total_cost / total_users if total_users > 0 else 0 
•          
•         return { 
•             'total_monthly_cost': total_cost, 
•             'cost_per_user': cost_per_user, 
•             'breakdown': { 
•                 'infrastructure': server_cost, 
•                 'services': service_cost, 
•                 'blockchain': blockchain_cost 
•             } 
•         } 
•      
•     def _calculate_gas_costs(self): 
•         """Calculate blockchain transaction costs""" 
•         # Get transactions from last 30 days 
•         transactions = BlockchainTransaction.query.filter( 



•             BlockchainTransaction.created_at >= datetime.utcnow() - 
timedelta(days=30) 

•         ).all() 
•          
•         total_gas_cost = sum([tx.gas_cost_eth for tx in transactions]) 
•         eth_to_usd = self._get_eth_price()  # Get current ETH price 
•          
•         return total_gas_cost * eth_to_usd 

• 11.4.2 Cost Optimization Targets 

Category Current Target Strategy 

Server Costs $530/month $400/month Auto-scaling, reserved instances 

Storage Costs $100/month $75/month Lifecycle policies, compression 

Blockchain Costs $500/month $350/month Batch transactions, gas optimization 

Third-party Services $111/month $100/month Plan optimization 

Total Monthly Cost $1241 $925 25% reduction 

Cost per User $2.48 $1.85 Improve user base 

•  

• 11.5 Analytics Dashboard 

• 11.5.1 Admin Analytics View 

• React 



• // frontend/src/pages/admin/Analytics.jsx 
• import { useState, useEffect } from 'react'; 
• import { 
•   LineChart, Line, BarChart, Bar, PieChart, Pie, 
•   XAxis, YAxis, CartesianGrid, Tooltip, Legend, 
•   ResponsiveContainer 
• } from 'recharts'; 
• import { getAnalytics } from '../../services/adminService'; 
•  
• export default function Analytics() { 
•   const [timeRange, setTimeRange] = useState('30d'); 
•   const [analytics, setAnalytics] = useState(null); 
•  
•   useEffect(() => { 
•     loadAnalytics(); 
•   }, [timeRange]); 
•  
•   const loadAnalytics = async () => { 
•     const data = await getAnalytics(timeRange); 
•     setAnalytics(data); 
•   }; 
•  
•   return ( 
•     <div className="analytics-dashboard"> 
•       <div className="dashboard-header"> 
•         <h1>Analytics Dashboard</h1> 
•         <select value={timeRange} onChange={(e) => setTimeRange(e.target.value)}> 
•           <option value="7d">Last 7 Days</option> 
•           <option value="30d">Last 30 Days</option> 
•           <option value="90d">Last 90 Days</option> 
•           <option value="1y">Last Year</option> 
•         </select> 
•       </div> 
•  
•       {/* Key Metrics */} 
•       <div className="metrics-overview"> 
•         <MetricCard 
•           title="Total Users" 
•           value={analytics?.totalUsers} 
•           change={analytics?.userGrowth} 
•           trend="up" 
•         /> 
•         <MetricCard 
•           title="Documents Uploaded" 
•           value={analytics?.documentsUploaded} 
•           change={analytics?.documentGrowth} 
•           trend="up" 
•         /> 
•         <MetricCard 
•           title="Approvals Processed" 
•           value={analytics?.approvalsProcessed} 
•           change={analytics?.approvalGrowth} 
•           trend="up" 
•         /> 

<MetricCard title="Active Users (Daily)" value={analytics?.dailyActiveUsers} 
change={analytics?.dauChange} trend={analytics?.dauChange > 0 ? 'up' : 'down'} 



/> 
</div> 

text 

  {/* User Growth Chart */} 

  <div className="chart-container"> 

    <h3>User Growth Over Time</h3> 

    <ResponsiveContainer width="100%" height={300}> 

      <LineChart data={analytics?.userGrowthData}> 

        <CartesianGrid strokeDasharray="3 3" /> 

        <XAxis dataKey="date" /> 

        <YAxis /> 

        <Tooltip /> 

        <Legend /> 

        <Line type="monotone" dataKey="totalUsers" stroke="#10B981" strokeWidth={2} /> 

        <Line type="monotone" dataKey="activeUsers" stroke="#3B82F6" strokeWidth={2} /> 

      </LineChart> 

    </ResponsiveContainer> 

  </div> 

 

  {/* Document Activity */} 

  <div className="chart-container"> 

    <h3>Document Activity</h3> 

    <ResponsiveContainer width="100%" height={300}> 

      <BarChart data={analytics?.documentActivity}> 

        <CartesianGrid strokeDasharray="3 3" /> 

        <XAxis dataKey="date" /> 

        <YAxis /> 

        <Tooltip /> 

        <Legend /> 

        <Bar dataKey="uploaded" fill="#10B981" /> 

        <Bar dataKey="shared" fill="#3B82F6" /> 



        <Bar dataKey="approved" fill="#8B5CF6" /> 

      </BarChart> 

    </ResponsiveContainer> 

  </div> 

 

  {/* User Distribution by Role */} 

  <div className="chart-container"> 

    <h3>User Distribution</h3> 

    <ResponsiveContainer width="100%" height={300}> 

      <PieChart> 

        <Pie 

          data={analytics?.userDistribution} 

          dataKey="value" 

          nameKey="role" 

          cx="50%" 

          cy="50%" 

          outerRadius={100} 

          fill="#8884d8" 

          label 

        /> 

        <Tooltip /> 

        <Legend /> 

      </PieChart> 

    </ResponsiveContainer> 

  </div> 

 

  {/* Department Activity */} 

  <div className="chart-container"> 

    <h3>Department-wise Activity</h3> 

    <ResponsiveContainer width="100%" height={300}> 

      <BarChart data={analytics?.departmentActivity} layout="vertical"> 



        <CartesianGrid strokeDasharray="3 3" /> 

        <XAxis type="number" /> 

        <YAxis dataKey="department" type="category" /> 

        <Tooltip /> 

        <Legend /> 

        <Bar dataKey="documents" fill="#10B981" /> 

        <Bar dataKey="approvals" fill="#F59E0B" /> 

      </BarChart> 

    </ResponsiveContainer> 

  </div> 

 

  {/* Approval Workflow Metrics */} 

  <div className="metrics-section"> 

    <h3>Approval Workflow Performance</h3> 

    <div className="workflow-metrics"> 

      <div className="metric-item"> 

        <span className="metric-label">Average Approval Time</span> 

        <span className="metric-value">{analytics?.avgApprovalTime} hours</span> 

      </div> 

      <div className="metric-item"> 

        <span className="metric-label">Approval Success Rate</span> 

        <span className="metric-value">{analytics?.approvalSuccessRate}%</span> 

      </div> 

      <div className="metric-item"> 

        <span className="metric-label">Pending Approvals</span> 

        <span className="metric-value">{analytics?.pendingApprovals}</span> 

      </div> 

    </div> 

  </div> 

 

  {/* System Health */} 



  <div className="system-health-section"> 

    <h3>System Health</h3> 

    <div className="health-grid"> 

      <HealthIndicator 

        label="API Response Time" 

        value={`${analytics?.apiResponseTime}ms`} 

        status={analytics?.apiResponseTime < 500 ? 'healthy' : 'warning'} 

      /> 

      <HealthIndicator 

        label="Blockchain Sync" 

        value="Synced" 

        status="healthy" 

      /> 

      <HealthIndicator 

        label="IPFS Uptime" 

        value={`${analytics?.ipfsUptime}%`} 

        status={analytics?.ipfsUptime > 99 ? 'healthy' : 'warning'} 

      /> 

      <HealthIndicator 

        label="Database Performance" 

        value={`${analytics?.dbQueryTime}ms`} 

        status={analytics?.dbQueryTime < 100 ? 'healthy' : 'warning'} 

      /> 

    </div> 

  </div> 

 

  {/* Export Options */} 

  <div className="export-section"> 

    <button onClick={() => exportReport('pdf')}> 

      Export as PDF 

    </button> 



    <button onClick={() => exportReport('csv')}> 

      Export as CSV 

    </button> 

    <button onClick={() => exportReport('excel')}> 

      Export as Excel 

    </button> 

  </div> 

</div> 

); 
} 

function MetricCard({ title, value, change, trend }) { 
return ( 
<div className="metric-card"> 
<h4>{title}</h4> 
<div className="metric-value">{value}</div> 
{change && ( 
<div className={metric-change ${trend}}> 
{trend === 'up' ? '↑' : '↓'} {Math.abs(change)}% 
</div> 
)} 
</div> 
); 
} 

function HealthIndicator({ label, value, status }) { 
return ( 
<div className={health-indicator ${status}}> 
<div className="health-label">{label}</div> 
<div className="health-value">{value}</div> 
<div className={health-status ${status}}> 
{status === 'healthy' ? '✓' : '⚠'} 
</div> 
</div> 
); 
} 

text 

 

--- 

 



# 12. Future Roadmap 

 

## 12.1 Phase 1 - MVP (Months 1-3) 

 

**Status: Current Phase** 

 

| Feature | Priority | Status | 

|---------|----------|--------| 

| User Authentication & Registration | P0 |  Complete | 

| Institution Management | P0 |  Complete | 

| File Upload to IPFS + Blockchain | P0 |  Complete | 

| Basic File Management | P0 |  Complete | 

| Document Sharing | P0 |  Complete | 

| Digital Signature Approval System | P0 |  Complete | 

| Chat Interface (1-on-1) | P0 |  Complete | 

| Circular Management | P0 |  Complete | 

| Document Verification Tool | P0 |  Complete | 

| Admin Dashboard | P0 |  Complete | 

 

**Success Criteria:** 

-  100 institutions onboarded 

-  5,000 documents uploaded 

-  System uptime > 99% 

 

--- 

 

## 12.2 Phase 2 - Enhancement (Months 4-6) 

 

**Target Date: Q2 2024** 

 



### **12.2.1 Advanced Features** 

 

| Feature | Description | Priority | 

|---------|-------------|----------| 

| **Mobile Application** | Native iOS/Android apps with full feature parity | P0 | 

| **Advanced Search** | Full-text search with filters, OCR for scanned documents | P0 | 

| **Bulk Operations** | Bulk upload, share, approve documents | P1 | 

| **Document Templates Library** | Expanded template collection with customization | P1 | 

| **API for Third-party Integration** | REST API for external system integration | P1 | 

| **Advanced Analytics** | Predictive analytics, usage patterns, recommendations | P2 | 

| **Offline Mode** | PWA offline functionality | P2 | 

 

### **12.2.2 Mobile Application Specifications** 

Mobile App Features: 
├── Authentication 
│ ├── Biometric login (Face ID, Touch ID, Fingerprint) 
│ ├── PIN code 
│ └── MetaMask mobile wallet integration 
├── Core Features 
│ ├── Document upload via camera 
│ ├── OCR text extraction 
│ ├── Push notifications 
│ ├── Offline document viewing 
│ └── QR code scanner for verification 
├── UI/UX 
│ ├── Native iOS (SwiftUI) 
│ ├── Native Android (Kotlin) 
│ └── Shared React Native components 
└── Performance 
├── Fast startup time (< 2s) 
├── Smooth animations (60fps) 
└── Efficient battery usage 

text 

 

### **12.2.3 API Documentation** 

 



```yaml 

# OpenAPI 3.0 Specification 

openapi: 3.0.0 

info: 

  title: DocuChain Public API 

  version: 2.0.0 

  description: Public API for third-party integrations 

 

servers: 

  - url: https://api.docuchain.app/v2 

    description: Production server 

 

paths: 

  /documents: 

    post: 

      summary: Upload document 

      security: 

        - ApiKeyAuth: [] 

      requestBody: 

        content: 

          multipart/form-data: 

            schema: 

              type: object 

              properties: 

                file: 

                  type: string 

                  format: binary 

                metadata: 

                  type: object 

      responses: 

        '201': 



          description: Document uploaded successfully 

          content: 

            application/json: 

              schema: 

                $ref: '#/components/schemas/Document' 

 

components: 

  securitySchemes: 

    ApiKeyAuth: 

      type: apiKey 

      in: header 

      name: X-API-Key 

   

  schemas: 

    Document: 

      type: object 

      properties: 

        documentId: 

          type: string 

        ipfsHash: 

          type: string 

        blockchainTxHash: 

          type: string 

 
12.3 Phase 3 - Scale & Optimize (Months 7-9) 

Target Date: Q3 2024 

12.3.1 Performance Enhancements 

Feature Goal Implementation 

CDN Integration Reduce load time by 50% Cloudflare/AWS CloudFront 

Database Sharding Support 1M+ users Horizontal partitioning 



Feature Goal Implementation 

Microservices Architecture Improved scalability Split monolith into services 

GraphQL API Reduce API calls Replace REST with GraphQL 

Edge Computing Lower latency Deploy edge functions 

12.3.2 AI/ML Features 

Feature Description Use Case 

Document Classification Auto-categorize documents using ML Automatic folder organization 

OCR & Text Extraction Extract text from images/PDFs Searchable scanned documents 

Duplicate Detection Identify duplicate documents Storage optimization 

Anomaly Detection Detect fraudulent documents Security enhancement 

Smart Recommendations Suggest approvers based on content Workflow optimization 

AI Service Architecture: 

Python 

# backend/app/services/ai_service.py 

from transformers import pipeline 

import torch 

 

class AIService: 

    def __init__(self): 

        self.classifier = pipeline( 

            "zero-shot-classification", 

            model="facebook/bart-large-mnli" 

        ) 

        self.ocr_model = pipeline( 

            "image-to-text", 

            model="microsoft/trocr-base-handwritten" 

        ) 

     

    def classify_document(self, text): 

        """Classify document into categories""" 



        categories = [ 

            "Certificate", "Report", "Application", 

            "Circular", "Letter", "Invoice" 

        ] 

        result = self.classifier(text, categories) 

        return result['labels'][0] 

     

    def extract_text(self, image): 

        """Extract text from document image""" 

        result = self.ocr_model(image) 

        return result[0]['generated_text'] 

     

    def detect_duplicates(self, document_hash): 

        """Find similar documents using embeddings""" 

        # Use sentence transformers for semantic similarity 

        pass 

 
12.4 Phase 4 - Enterprise Features (Months 10-12) 

Target Date: Q4 2024 

12.4.1 Enterprise Additions 

Feature Description Target Customers 

Multi-Institution Support Single account across institutions University networks 

SSO Integration SAML, OAuth2, LDAP integration Large institutions 

Advanced Permissions Role-based access control (RBAC) Enterprise clients 

Compliance Reporting GDPR, FERPA compliance reports Regulated institutions 

White Label Solution Customizable branding Partner institutions 

Dedicated Hosting Private cloud deployment Security-focused clients 

SLA Guarantees 99.99% uptime with support Premium tier 

12.4.2 Blockchain Enhancements 



Feature Description Benefit 

Layer 2 Integration Polygon, Arbitrum support Lower gas fees 

Multi-Chain Support Ethereum, BSC, Polygon User choice 

NFT Certificates Issue documents as NFTs Unique digital assets 

Smart Contract Upgrades Proxy pattern implementation Future-proof contracts 

Cross-Chain Bridge Transfer documents across chains Interoperability 

 
12.5 Long-term Vision (Year 2-3) 

12.5.1 Ecosystem Expansion 

Marketplace: 

text 

DocuChain Marketplace 

├── Template Marketplace 

│   ├── User-created templates 

│   ├── Paid premium templates 

│   └── Template rating system 

├── Plugin System 

│   ├── Third-party integrations 

│   ├── Custom workflows 

│   └── API extensions 

└── Service Providers 

    ├── Legal verification services 

    ├── Translation services 

    └── Notarization services 

Partnerships: 

• Government institutions for official document verification 

• Educational boards for certificate standardization 

• Banks for loan document processing 

• Embassies for visa document authentication 

12.5.2 Global Expansion 



Region Target Markets Localization 

Asia India, Singapore, Malaysia Hindi, Chinese, Malay 

Europe UK, Germany, France English, German, French 

Middle East UAE, Saudi Arabia Arabic, English 

Latin America Brazil, Mexico Portuguese, Spanish 

Africa South Africa, Nigeria English, French 

12.5.3 Revenue Model Evolution 

Pricing Tiers: 

Tier Price Features Target 

Free $0 100 documents, 1GB storage Small schools 

Basic $49/month 1,000 documents, 10GB storage Medium institutions 

Professional $199/month 10,000 documents, 100GB storage Large colleges 

Enterprise Custom Unlimited, dedicated support Universities 

Additional Revenue Streams: 

• API usage fees 

• Premium templates 

• Custom development 

• Training & onboarding services 

• Blockchain transaction fees (markup) 

 
12.6 Research & Development 

12.6.1 Emerging Technologies 

Technology Potential Application Timeline 

Zero-Knowledge Proofs Privacy-preserving verification 2025 Q2 

Decentralized Identity (DID) Self-sovereign identity 2025 Q3 

IPFS Cluster Enhanced redundancy 2024 Q4 

Quantum-Resistant Cryptography Future-proof security 2026 

Q1 | 
| Homomorphic Encryption | Process encrypted data | 2026 Q2 | 
| WebAssembly Smart Contracts | Cross-chain compatibility | 2025 Q4 | 



12.6.2 Innovation Lab Projects 

text 

Innovation Pipeline: 

├── Blockchain Innovations 

│   ├── ZK-SNARK document verification 

│   ├── Decentralized storage alternatives (Arweave, Filecoin) 

│   ├── DAO governance for institutions 

│   └── Tokenomics for document ecosystem 

│ 

├── AI/ML Research 

│   ├── Automated document summarization 

│   ├── Sentiment analysis for feedback 

│   ├── Predictive approval workflows 

│   └── Natural language document generation 

│ 

├── Security Research 

│   ├── Post-quantum cryptography 

│   ├── Biometric blockchain authentication 

│   ├── Distributed key management 

│   └── Advanced threat detection 

│ 

└── User Experience 

    ├── Voice-controlled interface 

    ├── AR document preview 

    ├── Gesture-based navigation 

    └── Accessibility enhancements (WCAG 2.2 AAA) 

 
13. Risk Management 

13.1 Technical Risks 

13.1.1 Blockchain-Related Risks 



Risk Impact Likelihood Mitigation Strategy 

Layer 2 solutions, batch transactions, gas 
High Gas Fees High cost for users High optimization 

Delayed 
Network Congestion transactions Medium Multiple chain support, transaction queuing 

Smart Contract 
Vulnerabilities Security breach Low Audits, bug bounties, formal verification 

Blockchain Fork Data inconsistency Low Monitor network, rapid response plan 

Compatibility 
Ethereum 2.0 Migration issues Medium Test on testnets, gradual migration 

Mitigation Implementation: 

solidity 

// Gas optimization example 

contract OptimizedDocumentManager { 

    // Use events instead of storage for logs 

    event DocumentBatchUploaded(bytes32[] documentIds, uint256 timestamp); 

     

    // Batch operations to reduce gas 

    function uploadDocumentBatch( 

        string[] memory ipfsHashes, 

        string[] memory fileNames 

    ) public returns (bytes32[] memory) { 

        bytes32[] memory documentIds = new bytes32[](ipfsHashes.length); 

         

        for (uint i = 0; i < ipfsHashes.length; i++) { 

            documentIds[i] = _uploadSingleDocument(ipfsHashes[i], fileNames[i]); 

        } 

         

        emit DocumentBatchUploaded(documentIds, block.timestamp); 

        return documentIds; 

    } 

     



    // Use uint256 packing 

    struct PackedDocument { 

        uint128 fileSize;  // Instead of uint256 

        uint64 timestamp;  // Instead of uint256 

        uint32 version;    // Instead of uint256 

        bool isActive;     // 1 byte 

        // Total: 29 bytes instead of 97 bytes 

    } 

} 

13.1.2 Infrastructure Risks 

Risk Impact Likelihood Mitigation Strategy 

Server Downtime Service unavailable Medium Multi-region deployment, auto-failover 

Database Failure Data loss Low Regular backups, replication, point-in-time recovery 

IPFS Gateway Failure Files inaccessible Medium Multiple gateways, local caching 

DDoS Attack Service disruption Medium Cloudflare protection, rate limiting 

Data Breach Privacy violation Low Encryption, security audits, compliance 

DDoS Protection: 

nginx 

# nginx rate limiting configuration 

limit_req_zone $binary_remote_addr zone=general:10m rate=10r/s; 

limit_req_zone $binary_remote_addr zone=login:10m rate=5r/m; 

limit_req_zone $binary_remote_addr zone=api:10m rate=100r/m; 

 

# Connection limits 

limit_conn_zone $binary_remote_addr zone=addr:10m; 

limit_conn addr 10; 

 

# Geographic blocking (optional) 

geo $block_ip { 

    default 0; 



    # Block specific countries if needed 

} 

 

server { 

    # Apply rate limiting 

    location /api/auth/ { 

        limit_req zone=login burst=3 nodelay; 

    } 

     

    location /api/ { 

        limit_req zone=api burst=50 nodelay; 

    } 

     

    # Block if flagged 

    if ($block_ip) { 

        return 403; 

    } 

} 

 
13.2 Business Risks 

13.2.1 Market Risks 

Risk Impact Likelihood Mitigation Strategy 

Low User Adoption Revenue shortfall Medium Marketing campaigns, free tier, user education 

Competitor Entry Market share loss High Continuous innovation, strong partnerships 

Regulatory Changes Compliance costs Medium Legal advisory, flexible architecture 

Cryptocurrency Volatility Unpredictable costs High Stablecoin integration, fiat gateway 

Economic Downturn Budget cuts in institutions Medium Flexible pricing, essential features focus 

User Adoption Strategy: 

text 

Onboarding Funnel: 



1. Awareness (Marketing) 

   ├── Content marketing (blogs, videos) 

   ├── Social media campaigns 

   ├── Webinars & demos 

   └── Partnership announcements 

 

2. Interest (Landing Page) 

   ├── Clear value proposition 

   ├── Use case demonstrations 

   ├── Testimonials & case studies 

   └── Free trial signup 

 

3. Evaluation (Trial Period) 

   ├── Guided onboarding 

   ├── Sample templates 

   ├── 1-on-1 support 

   └── Feature walkthrough 

 

4. Purchase (Conversion) 

   ├── Flexible pricing 

   ├── Easy upgrade path 

   ├── Volume discounts 

   └── Money-back guarantee 

 

5. Retention (Customer Success) 

   ├── Regular training 

   ├── Feature updates 

   ├── Community building 

   └── Feedback incorporation 

13.2.2 Legal & Compliance Risks 



Risk Impact Likelihood Mitigation Strategy 

GDPR Non-Compliance Fines, lawsuits Low Privacy by design, DPO appointment 

Data Sovereignty Issues Regional restrictions Medium Multi-region deployment, data localization 

Intellectual Property Disputes Legal costs Low IP clearance, licensing agreements 

Liability for Document Fraud Reputation damage Medium Clear ToS, verification disclaimers 

Cryptocurrency Regulations Operational restrictions High Compliance monitoring, legal counsel 

GDPR Compliance Checklist: 

text 

  Data Protection Impact Assessment (DPIA) 

  Privacy Policy (transparent, accessible) 

  Cookie Consent (granular, opt-in) 

  Right to Access (user data export) 

  Right to Erasure (account deletion, data purging) 

  Right to Portability (JSON/CSV export) 

  Right to Rectification (profile editing) 

  Consent Management (audit trail) 

  Data Breach Notification (72-hour protocol) 

  Data Processing Agreement (with vendors) 

  Privacy by Design (encryption, anonymization) 

  Data Protection Officer (appointed) 

Implementation: 

Python 

# backend/app/services/gdpr_service.py 

class GDPRService: 

    def export_user_data(self, user_id): 

        """Export all user data (GDPR Right to Access)""" 

        user = User.query.get(user_id) 

         

        data = { 



            'profile': { 

                'email': user.email, 

                'name': f"{user.first_name} {user.last_name}", 

                'created_at': user.created_at.isoformat(), 

            }, 

            'documents': [ 

                { 

                    'id': doc.document_id, 

                    'name': doc.file_name, 

                    'ipfs_hash': doc.ipfs_hash, 

                    'created_at': doc.created_at.isoformat() 

                } 

                for doc in user.documents 

            ], 

            'activity_logs': [ 

                { 

                    'action': log.action, 

                    'timestamp': log.created_at.isoformat() 

                } 

                for log in user.activity_logs 

            ] 

        } 

         

        return json.dumps(data, indent=2) 

     

    def delete_user_account(self, user_id): 

        """Delete user account (GDPR Right to Erasure)""" 

        user = User.query.get(user_id) 

         

        # Anonymize instead of delete (blockchain immutability) 

        user.email = f"deleted_{user_id}@anonymized.local" 



        user.first_name = "Deleted" 

        user.last_name = "User" 

        user.phone = None 

        user.is_active = False 

         

        # Note: Blockchain records remain (immutable) 

        # But personal identifiers are removed 

         

        db.session.commit() 

         

        # Log deletion for audit 

        log_gdpr_deletion(user_id) 

 
13.3 Security Risks 

13.3.1 Application Security 

Vulnerability Severity Detection Prevention 

SQL Injection Critical Code review, automated scanning Parameterized queries, ORM 

XSS High Security testing Input sanitization, CSP headers 

CSRF High Penetration testing CSRF tokens, SameSite cookies 

Authentication Bypass Critical Security audit MFA, secure session management 

Insecure File Upload High File validation Type checking, antivirus scanning 

Security Testing Schedule: 

text 

Weekly: 

├── Automated vulnerability scanning (Snyk, Dependabot) 

├── SAST (Static Application Security Testing) 

└── Dependency updates 

 

Monthly: 

├── DAST (Dynamic Application Security Testing) 



├── Penetration testing (internal) 

└── Security code review 

 

Quarterly: 

├── Third-party penetration testing 

├── Security audit 

└── Compliance assessment (SOC 2, ISO 27001) 

 

Annually: 

├── Smart contract audit 

├── Infrastructure security review 

└── Disaster recovery drill 

13.3.2 Incident Response Plan 

text 

Security Incident Response: 

 

Phase 1: Detection & Analysis (0-30 minutes) 

├── Monitoring alerts triggered 

├── Security team notified 

├── Incident severity assessed 

└── Incident commander assigned 

 

Phase 2: Containment (30 minutes - 2 hours) 

├── Isolate affected systems 

├── Block malicious traffic 

├── Revoke compromised credentials 

└── Document all actions 

 

Phase 3: Eradication (2-24 hours) 

├── Remove malware/backdoors 



├── Patch vulnerabilities 

├── Reset passwords 

└── Restore from clean backups 

 

Phase 4: Recovery (24-72 hours) 

├── Restore services gradually 

├── Monitor for suspicious activity 

├── Verify system integrity 

└── Update security measures 

 

Phase 5: Post-Incident (1 week) 

├── Incident report documentation 

├── Root cause analysis 

├── Security improvements 

└── Stakeholder communication 

Incident Response Playbook: 

Python 

# backend/app/security/incident_response.py 

from datetime import datetime 

from enum import Enum 

 

class IncidentSeverity(Enum): 

    LOW = 1 

    MEDIUM = 2 

    HIGH = 3 

    CRITICAL = 4 

 

class IncidentResponseManager: 

    def __init__(self): 

        self.incidents = [] 



        self.notification_channels = { 

            'slack': os.getenv('SECURITY_SLACK_WEBHOOK'), 

            'email': os.getenv('SECURITY_EMAIL'), 

            'pagerduty': os.getenv('PAGERDUTY_KEY') 

        } 

     

    def report_incident(self, incident_type, severity, details): 

        """Report security incident""" 

        incident = { 

            'id': generate_incident_id(), 

            'type': incident_type, 

            'severity': severity, 

            'details': details, 

            'timestamp': datetime.utcnow(), 

            'status': 'detected' 

        } 

         

        self.incidents.append(incident) 

         

        # Notify based on severity 

        if severity >= IncidentSeverity.HIGH: 

            self.notify_security_team(incident) 

            self.auto_containment(incident) 

         

        return incident['id'] 

     

    def auto_containment(self, incident): 

        """Automated containment actions""" 

        if incident['type'] == 'bruteforce_attack': 

            # Block IP 

            self.block_ip(incident['details']['ip']) 



         

        elif incident['type'] == 'data_breach': 

            # Revoke all sessions 

            self.revoke_all_sessions() 

             

        elif incident['type'] == 'malware_detected': 

            # Isolate affected server 

            self.isolate_server(incident['details']['server_id']) 

     

    def notify_security_team(self, incident): 

        """Send alerts to security team""" 

        message = f""" 

         SECURITY INCIDENT DETECTED 

        Severity: {incident['severity'].name} 

        Type: {incident['type']} 

        Time: {incident['timestamp']} 

        Details: {incident['details']} 

        """ 

         

        # Send to all channels 

        for channel, endpoint in self.notification_channels.items(): 

            send_notification(channel, endpoint, message) 

 
13.4 Operational Risks 

13.4.1 Team & Resource Risks 

Risk Impact Likelihood Mitigation Strategy 

Key Person Dependency Knowledge loss Medium Documentation, cross-training, pair programming 

Team Burnout Productivity drop Medium Work-life balance, resource planning 

Skill Gap Development delays Medium Training programs, hiring 

Remote Work Challenges Communication issues Low Tools, processes, regular sync 



Knowledge Management: 

text 

Documentation Structure: 

├── README.md (Project overview) 

├── ARCHITECTURE.md (System design) 

├── API.md (API documentation) 

├── DEPLOYMENT.md (Deployment guide) 

├── TROUBLESHOOTING.md (Common issues) 

├── CONTRIBUTING.md (Development guide) 

└── docs/ 

    ├── onboarding/ (New developer guide) 

    ├── runbooks/ (Operational procedures) 

    ├── decisions/ (Architecture decision records) 

    └── postmortems/ (Incident analysis) 

 
14. Conclusion 

14.1 Project Summary 

DocuChain represents a comprehensive, blockchain-based document management solution 
designed specifically for educational institutions. By combining the immutability of blockchain 
technology with the decentralization of IPFS storage, the platform provides: 

  Tamper-Proof Document Storage 
  Transparent Approval Workflows 
  Secure Digital Signatures 
  Instant Document Verification 
  Scalable Multi-Institution Architecture 

14.2 Key Differentiators 

1. Blockchain Verification: Every document is cryptographically secured and verifiable 

2. Institutional Focus: Purpose-built for educational workflows 

3. User-Friendly: No blockchain knowledge required for end users 

4. Compliance Ready: GDPR, FERPA compliant by design 

5. Cost-Effective: Significantly cheaper than traditional document management systems 

14.3 Success Metrics Summary 



Category Target Timeline 

Institutions Onboarded 100 Month 3 

Active Users 10,000 Month 6 

Documents Managed 100,000 Month 9 

System Uptime | 99.9% | Continuous | 
| User Satisfaction (NPS) | > 50 | Month 12 | 
| Cost per User | < $2.00 | Month 12 | 

14.4 Investment & Resources Required 

14.4.1 Development Team 

Role Count Responsibility 

Full-Stack Developers 3 Frontend & Backend development 

Blockchain Developer 1 Smart contract development & optimization 

DevOps Engineer 1 Infrastructure, CI/CD, monitoring 

UI/UX Designer 1 Design system, user research 

QA Engineer 1 Testing, quality assurance 

Product Manager 1 Roadmap, stakeholder management 

Project Manager 1 Timeline, resource management 

Total Team Size: 9 members 

14.4.2 Infrastructure Costs (Monthly) 

Service Cost Notes 

AWS/Cloud Hosting $530 EC2, RDS, ElastiCache, S3 

IPFS (Pinata) $20 Pro plan, 1TB storage 

Blockchain RPC (Infura) $50 Growth plan 

Monitoring (Sentry, DataDog) $75 Error tracking, APM 

Email Service (SendGrid) $15 Transactional emails 

CDN (Cloudflare) $20 Pro plan 

Domain & SSL $10 Domain registration, SSL certs 

Backup Storage $30 S3 for backups 

Development Tools $50 GitHub, CI/CD, tools 



Service Cost Notes 

Blockchain Gas Fees $200-500 Variable based on usage 

Total $1,000-1,300 
 

14.4.3 Annual Budget Projection 

text 

Year 1 Budget: 

 

Development Costs: 

├── Salaries (9 team members × $80K avg) ......... $720,000 

├── Benefits & Insurance (25%) ................... $180,000 

├── Office/Remote Setup .......................... $50,000 

├── Software Licenses & Tools .................... $30,000 

└── Training & Development ....................... $20,000 

    Subtotal: $1,000,000 

 

Infrastructure Costs: 

├── Cloud Hosting (12 months × $800) ............. $9,600 

├── Third-party Services (12 months × $500) ...... $6,000 

├── Blockchain Costs (12 months × $400) .......... $4,800 

└── Security & Compliance ........................ $20,000 

    Subtotal: $40,400 

 

Marketing & Sales: 

├── Digital Marketing ............................ $50,000 

├── Content Creation ............................. $20,000 

├── Events & Conferences ......................... $15,000 

└── Sales Commissions ............................ $25,000 

    Subtotal: $110,000 

 

Legal & Administrative: 



├── Legal Fees ................................... $30,000 

├── Accounting & Compliance ...................... $15,000 

├── Insurance .................................... $10,000 

└── Miscellaneous ................................ $10,000 

    Subtotal: $65,000 

 

TOTAL YEAR 1 BUDGET: $1,215,400 

14.5 Revenue Model 

14.5.1 Pricing Strategy 

Freemium Model: 

text 

Free Tier (Forever Free): 

├── 1 institution 

├── 50 users 

├── 500 documents 

├── 5GB storage 

├── Basic features 

└── Community support 

 

Basic Tier ($49/month): 

├── 1 institution 

├── 500 users 

├── 5,000 documents 

├── 50GB storage 

├── All core features 

├── Email support 

└── SLA: 99.5% 

 

Professional Tier ($199/month): 

├── 1 institution 



├── 2,000 users 

├── 20,000 documents 

├── 200GB storage 

├── Advanced features (API, Analytics) 

├── Priority support 

├── SLA: 99.9% 

└── Custom branding 

 

Enterprise Tier (Custom Pricing): 

├── Multiple institutions 

├── Unlimited users 

├── Unlimited documents 

├── Custom storage 

├── White label 

├── Dedicated support 

├── SLA: 99.99% 

├── Custom integrations 

└── On-premise deployment option 

14.5.2 Revenue Projections 

text 

Year 1 Revenue Forecast: 

 

Quarter 1 (MVP Launch): 

├── Free Tier Users: 50 institutions (0 revenue) 

├── Basic Tier: 5 × $49 = $245/month × 3 = $735 

└── Q1 Total: $735 

 

Quarter 2: 

├── Free Tier: 100 institutions 

├── Basic Tier: 20 × $49 = $980/month × 3 = $2,940 



├── Professional: 2 × $199 = $398/month × 3 = $1,194 

└── Q2 Total: $4,134 

 

Quarter 3: 

├── Free Tier: 200 institutions 

├── Basic Tier: 50 × $49 = $2,450/month × 3 = $7,350 

├── Professional: 8 × $199 = $1,592/month × 3 = $4,776 

├── Enterprise: 1 × $2,000/month × 3 = $6,000 

└── Q3 Total: $18,126 

 

Quarter 4: 

├── Free Tier: 300 institutions 

├── Basic Tier: 80 × $49 = $3,920/month × 3 = $11,760 

├── Professional: 15 × $199 = $2,985/month × 3 = $8,955 

├── Enterprise: 3 × $2,500/month × 3 = $22,500 

└── Q4 Total: $43,215 

 

Year 1 Total Revenue: $66,210 

Year 1 Net Loss: -$1,149,190 

 

Year 2 Projections (Conservative): 

├── Monthly Recurring Revenue (MRR): $15,000 

├── Annual Recurring Revenue (ARR): $180,000 

└── Net Loss: -$870,000 

 

Year 3 Projections: 

├── MRR: $50,000 

├── ARR: $600,000 

└── Break-even target 

14.6 Go-to-Market Strategy 



14.6.1 Target Market Segmentation 

Primary Markets: 

1. Tier 2 & Tier 3 Universities (India) 

• 500+ universities 

• Budget-conscious 

• Technology adoption increasing 

• Pain point: Manual processes, document fraud 

2. International Schools 

• 100+ schools globally 

• High technology adoption 

• Pain point: Cross-border verification 

3. Coaching Institutes 

• 1000+ institutes 

• Growing digital presence 

• Pain point: Certificate management 

Secondary Markets: 

4. Professional Training Centers 

5. Government Educational Boards 

6. Corporate Training Departments 

14.6.2 Marketing Channels 

text 

Marketing Mix: 

 

Content Marketing (40% budget): 

├── SEO-optimized blog posts 

├── Video tutorials on YouTube 

├── Webinars and workshops 

├── Case studies and whitepapers 

└── Educational email series 

 

Paid Advertising (25% budget): 



├── Google Ads (search & display) 

├── LinkedIn sponsored content 

├── Facebook/Instagram ads 

└── Education-focused platforms 

 

Partnerships (20% budget): 

├── University associations 

├── Educational technology consortiums 

├── Government education initiatives 

└── Integration partners (LMS platforms) 

 

Events & PR (15% budget): 

├── Education technology conferences 

├── University roadshows 

├── Press releases 

└── Industry awards participation 

14.6.3 Sales Strategy 

Sales Funnel: 

text 

Awareness → Interest → Evaluation → Purchase → Retention 

 

1. Awareness (Inbound): 

   ├── Content marketing 

   ├── Social media presence 

   └── SEO ranking 

 

2. Interest (Lead Generation): 

   ├── Free tier signup 

   ├── Demo request 

   ├── Webinar registration 



   └── Content downloads 

 

3. Evaluation (Trial): 

   ├── 30-day free trial (Basic tier) 

   ├── Onboarding call 

   ├── Success metrics tracking 

   └── Feature adoption monitoring 

 

4. Purchase (Conversion): 

   ├── Self-service upgrade 

   ├── Sales-assisted for Enterprise 

   ├── Contract signing 

   └── Payment setup 

 

5. Retention (Customer Success): 

   ├── Regular check-ins 

   ├── Usage reports 

   ├── Feature training 

   ├── Community building 

   └── Renewal reminders 

Sales Team Structure: 

text 

Sales Organization (Year 1): 

├── Sales Lead (1) 

│   ├── Inbound Sales Rep (1) 

│   └── Outbound Sales Rep (1) 

└── Customer Success Manager (1) 

 

Sales Targets (Year 1): 

├── Q1: 5 paid customers 



├── Q2: 15 paid customers 

├── Q3: 35 paid customers 

└── Q4: 60 paid customers 

14.7 Competitive Analysis 

14.7.1 Direct Competitors 

Competitor Strengths Weaknesses Our Advantage 

Traditional DMS (Alfresco, Established, No blockchain, expensive, Blockchain verification, 
SharePoint) feature-rich complex education-focused 

Blockchain DMS (ProofStack) Blockchain-based Generic, poor UX, expensive Education workflows, better UX 

Cloud Storage (Google Drive, Easy to use, No verification, not Document authenticity, 
Dropbox) familiar institution-focused approval workflows 

Legacy systems, not Modern tech, blockchain, 
University-specific Systems Domain expertise scalable scalable 

14.7.2 Competitive Positioning 

Positioning Statement: 

"DocuChain is the only blockchain-based document management system purpose-built for 
educational institutions, providing tamper-proof document storage, transparent approval workflows, 
and instant verification—all at a fraction of the cost of traditional systems." 

Unique Value Propositions: 

1.   Blockchain-Verified: Every document cryptographically secured 

2.   Education-First: Built specifically for institutional workflows 

3.   Cost-Effective: 70% cheaper than traditional DMS 

4.   User-Friendly: No blockchain expertise required 

5.   Instant Verification: QR-based document authentication 

6.   Open Ecosystem: API for integrations, template marketplace 

14.8 Exit Strategy & Long-term Vision 

14.8.1 Potential Exit Scenarios (5-7 years) 

Option 1: Acquisition 

• Potential Acquirers: EdTech giants (Coursera, Udemy), Enterprise software (Microsoft, 
Google), Blockchain companies (Consensys) 

• Valuation Target: $50-100M 

• Timeline: Year 5-7 



Option 2: IPO 

• Requirements: $50M+ ARR, profitability, market leadership 

• Timeline: Year 7+ 

Option 3: Sustainable Business 

• Target: $20M+ ARR, 30% profit margin 

• Timeline: Year 5 

• Outcome: Continue as independent profitable business 

14.8.2 Long-term Vision (10 years) 

Mission: 

"To become the global standard for educational document management, ensuring every academic 
credential is verifiable, portable, and owned by the individual." 

Vision 2034: 

text 

Global Reach: 

├── 50,000+ institutions 

├── 50M+ users worldwide 

├── 500M+ documents managed 

└── 100+ countries 

 

Technology Leadership: 

├── Industry-standard verification protocol 

├── Largest education blockchain network 

├── AI-powered document intelligence 

└── Quantum-resistant security 

 

Ecosystem: 

├── 1000+ integration partners 

├── 10,000+ template marketplace listings 

├── Developer community of 5000+ 

└── Annual developer conference 

14.9 Critical Success Factors 



For achieving our vision, we must: 

  Maintain Technical Excellence 

• Continuous innovation in blockchain and AI 

• 99.9%+ uptime and reliability 

• World-class security and compliance 

  Build Strong Partnerships 

• University associations and boards 

• Government education initiatives 

• Technology integration partners 

  Focus on User Experience 

• Simplify blockchain complexity 

• Mobile-first design 

• Accessibility for all users 

  Establish Market Leadership 

• Thought leadership in education + blockchain 

• Case studies and success stories 

• Industry awards and recognition 

  Create Network Effects 

• Multi-institution support 

• Cross-institutional verification 

• Employer integration for credential verification 

  Ensure Financial Sustainability 

• Path to profitability by Year 3 

• Diversified revenue streams 

• Efficient cost management 

 
14.10 Conclusion & Call to Action 

DocuChain is positioned to revolutionize educational document management by leveraging 
blockchain technology to solve critical problems of authenticity, accessibility, and trust. With a clear 
roadmap, experienced team, and validated market need, we are ready to transform how educational 
institutions manage and verify documents. 



Next Steps: 

1.   Complete MVP Development (Month 3) 

2.   Launch Beta Program (Month 4) 

3.   Public Launch (Month 6) 

4.   Scale to 100 Institutions (Month 12) 

5.   International Expansion (Year 2) 

Contact Information: 

text 

DocuChain Team 

Email: info@docuchain.app 

Website: https://docuchain.app 

GitHub: https://github.com/docuchain 

LinkedIn: https://linkedin.com/company/docuchain 

Twitter: @docuchain_app 

 
Document Version: 1.0 
Last Updated: January 2024 
Status: Final Draft 
Approver: Product Team 

 
END OF PRODUCT REQUIREMENTS DOCUMENT